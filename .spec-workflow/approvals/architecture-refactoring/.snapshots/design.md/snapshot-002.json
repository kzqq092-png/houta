{
  "id": "snapshot_1758812968802_v8ojdkqq7",
  "approvalId": "approval_1758812912428_urozg7ohv",
  "approvalTitle": "Architecture Refactoring Design Document",
  "version": 2,
  "timestamp": "2025-09-25T15:09:28.802Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Architecture Refactoring Design Document\r\n\r\n## Overview\r\n\r\nThis design transforms the FactorWeave-Quant system from a chaotic 226-Manager architecture to a clean, service-oriented design with proper dependency injection, unified plugin management, and controlled service lifecycles. The refactoring follows a three-phase approach: stabilization, architecture selection, and systematic refactoring.\r\n\r\n## Steering Document Alignment\r\n\r\n### Technical Standards (tech.md)\r\nThis design follows established patterns for:\r\n- Python service architecture with proper abstract base classes\r\n- Dependency injection using container patterns\r\n- Configuration management through centralized services\r\n- Error handling with structured logging and proper exception hierarchies\r\n\r\n### Project Structure (structure.md) \r\nImplementation maintains existing directory structure while consolidating:\r\n- `core/services/` - Unified service layer (15 services max)\r\n- `core/containers/` - Dependency injection framework\r\n- `core/interfaces/` - Service contracts and abstractions\r\n- `plugins/` - Unified plugin system\r\n\r\n## Code Reuse Analysis\r\n\r\n### Existing Components to Leverage\r\n- **ServiceContainer**: Extend existing container with proper lifecycle management\r\n- **EventBus**: Utilize for decoupled service communication\r\n- **BaseService**: Establish as foundation for all new services\r\n- **ConfigService**: Enhance with validation and change notification\r\n- **LoguruManager**: Standardize as the single logging solution\r\n\r\n### Integration Points\r\n- **Database Layer**: Maintain existing DuckDB and SQLite connections\r\n- **Plugin Interfaces**: Extend current plugin contracts with lifecycle methods\r\n- **UI Components**: Preserve existing Qt/PyQt5 integration patterns\r\n- **Data Sources**: Unify multiple data source managers into single DataService\r\n\r\n## Architecture\r\n\r\nThe new architecture follows Domain-Driven Design principles with clear service boundaries:\r\n\r\n### Modular Design Principles\r\n- **Service Segregation**: Each service handles one business domain\r\n- **Interface-First Design**: All services implement well-defined contracts\r\n- **Dependency Inversion**: Services depend on abstractions, not implementations\r\n- **Single Initialization**: Each service initializes exactly once through DI container\r\n\r\n```mermaid\r\ngraph TD\r\n    Container[ServiceContainer] --> CoreServices[Core Services Layer]\r\n    Container --> BusinessServices[Business Services Layer]\r\n    Container --> InfraServices[Infrastructure Services Layer]\r\n    \r\n    CoreServices --> ConfigService[ConfigService]\r\n    CoreServices --> LoggingService[LoggingService]\r\n    CoreServices --> EventService[EventService]\r\n    \r\n    BusinessServices --> DataService[DataService]\r\n    BusinessServices --> PluginService[PluginService]\r\n    BusinessServices --> TradingService[TradingService]\r\n    BusinessServices --> AnalysisService[AnalysisService]\r\n    BusinessServices --> StrategyService[StrategyService]\r\n    \r\n    InfraServices --> DatabaseService[DatabaseService]\r\n    InfraServices --> CacheService[CacheService]\r\n    InfraServices --> NetworkService[NetworkService]\r\n    InfraServices --> FileService[FileService]\r\n    InfraServices --> PerformanceService[PerformanceService]\r\n    \r\n    PluginService --> PluginManager[Unified Plugin Manager]\r\n    DataService --> DataRouter[Data Router]\r\n    ConfigService --> ConfigValidator[Config Validator]\r\n```\r\n\r\n## Components and Interfaces\r\n\r\n### Core Services Layer\r\n\r\n#### ConfigService\r\n- **Purpose:** Centralized configuration management with validation\r\n- **Interfaces:** `IConfigService` with get/set/validate/notify methods  \r\n- **Dependencies:** FileService for persistence, EventService for change notifications\r\n- **Reuses:** Existing config.json structure, SQLite storage patterns\r\n\r\n#### LoggingService  \r\n- **Purpose:** Unified logging using Loguru with structured output\r\n- **Interfaces:** `ILoggingService` with standard logging levels and structured data\r\n- **Dependencies:** ConfigService for log levels and output configuration\r\n- **Reuses:** Existing LoguruManager implementation\r\n\r\n#### EventService\r\n- **Purpose:** Decoupled inter-service communication\r\n- **Interfaces:** `IEventService` with publish/subscribe patterns\r\n- **Dependencies:** LoggingService for event auditing\r\n- **Reuses:** Current EventBus implementation with enhancements\r\n\r\n### Business Services Layer\r\n\r\n#### DataService\r\n- **Purpose:** Unified data access consolidating all Manager classes\r\n- **Interfaces:** `IDataService` with standardized data retrieval methods\r\n- **Dependencies:** DatabaseService, CacheService, NetworkService, PluginService\r\n- **Reuses:** Existing data source connections, TET pipeline, DuckDB operations\r\n\r\n#### PluginService\r\n- **Purpose:** Single plugin management system replacing multiple managers\r\n- **Interfaces:** `IPluginService` with discovery/lifecycle/management methods\r\n- **Dependencies:** ConfigService for plugin settings, EventService for lifecycle events\r\n- **Reuses:** Current plugin interfaces with standardized lifecycle\r\n\r\n#### TradingService\r\n- **Purpose:** Trading operations and portfolio management\r\n- **Interfaces:** `ITradingService` with order management and risk controls\r\n- **Dependencies:** DataService for market data, ConfigService for trading rules\r\n- **Reuses:** Existing trading engine, risk management, position tracking\r\n\r\n#### AnalysisService\r\n- **Purpose:** Technical and fundamental analysis capabilities\r\n- **Interfaces:** `IAnalysisService` with indicator calculation and pattern recognition\r\n- **Dependencies:** DataService for historical data, CacheService for performance\r\n- **Reuses:** Current indicator libraries, pattern recognition algorithms\r\n\r\n#### StrategyService\r\n- **Purpose:** Strategy development and execution management\r\n- **Interfaces:** `IStrategyService` with strategy lifecycle and execution\r\n- **Dependencies:** TradingService for execution, AnalysisService for signals\r\n- **Reuses:** Existing strategy framework, backtest engine\r\n\r\n### Infrastructure Services Layer\r\n\r\n#### DatabaseService\r\n- **Purpose:** Database connection and operation management\r\n- **Interfaces:** `IDatabaseService` with transaction and query management\r\n- **Dependencies:** ConfigService for connection strings\r\n- **Reuses:** Current DuckDB and SQLite connections, table schemas\r\n\r\n#### CacheService\r\n- **Purpose:** Multi-level caching for performance optimization\r\n- **Interfaces:** `ICacheService` with TTL and invalidation support\r\n- **Dependencies:** ConfigService for cache settings\r\n- **Reuses:** Existing cache implementations with proper eviction\r\n\r\n#### NetworkService\r\n- **Purpose:** HTTP/WebSocket connections and API management\r\n- **Interfaces:** `INetworkService` with request/response handling\r\n- **Dependencies:** ConfigService for endpoints and timeouts\r\n- **Reuses:** Current network configurations, retry mechanisms\r\n\r\n#### FileService\r\n- **Purpose:** File system operations and resource management\r\n- **Interfaces:** `IFileService` with CRUD operations and monitoring\r\n- **Dependencies:** ConfigService for paths and permissions\r\n- **Reuses:** Existing file handling patterns\r\n\r\n#### PerformanceService\r\n- **Purpose:** System monitoring and performance metrics\r\n- **Interfaces:** `IPerformanceService` with metrics collection and reporting\r\n- **Dependencies:** LoggingService for metric output\r\n- **Reuses:** Current performance monitoring tools\r\n\r\n## Data Models\r\n\r\n### Service Registration Model\r\n```python\r\n@dataclass\r\nclass ServiceRegistration:\r\n    interface_type: Type[ABC]\r\n    implementation_type: Type\r\n    lifecycle: ServiceLifecycle  # Singleton, Transient, Scoped\r\n    dependencies: List[Type[ABC]]\r\n    initialization_order: int\r\n```\r\n\r\n### Service Health Model\r\n```python\r\n@dataclass  \r\nclass ServiceHealth:\r\n    service_name: str\r\n    status: ServiceStatus  # Healthy, Degraded, Failed\r\n    last_check: datetime\r\n    error_message: Optional[str]\r\n    metrics: Dict[str, Any]\r\n```\r\n\r\n### Plugin Lifecycle Model\r\n```python\r\n@dataclass\r\nclass PluginState:\r\n    plugin_id: str\r\n    name: str\r\n    version: str\r\n    status: PluginStatus  # Discovered, Validated, Initialized, Active, Failed\r\n    dependencies: List[str]\r\n    error_info: Optional[Exception]\r\n```\r\n\r\n## Error Handling\r\n\r\n### Error Scenarios\r\n\r\n1. **Service Initialization Failure**\r\n   - **Handling:** Log detailed error, mark service as failed, prevent dependent services from starting\r\n   - **User Impact:** Clear error message indicating which service failed and suggested actions\r\n\r\n2. **Plugin Loading Failure**\r\n   - **Handling:** Log plugin error, continue loading other plugins, provide degraded functionality\r\n   - **User Impact:** Notification of unavailable plugins with option to retry or disable\r\n\r\n3. **Configuration Validation Error**\r\n   - **Handling:** Stop startup, display specific validation errors with field references\r\n   - **User Impact:** Clear indication of invalid configuration with suggestions for correction\r\n\r\n4. **Circular Dependency Detection**\r\n   - **Handling:** Analyze dependency graph, report circular chains, fail fast\r\n   - **User Impact:** Developer-focused error with dependency chain visualization\r\n\r\n5. **Resource Exhaustion**\r\n   - **Handling:** Implement circuit breakers, graceful degradation, resource cleanup\r\n   - **User Impact:** Performance warnings with guidance on resource optimization\r\n\r\n## Testing Strategy\r\n\r\n### Unit Testing\r\n- Each service implementation tested in isolation with mocked dependencies\r\n- Configuration validation tested with various valid/invalid scenarios\r\n- Plugin lifecycle tested with mock plugins and error conditions\r\n- Service container tested for proper registration and resolution\r\n\r\n### Integration Testing\r\n- Service startup sequence tested end-to-end\r\n- Plugin loading tested with real plugin implementations\r\n- Data flow tested through service layers\r\n- Error propagation tested across service boundaries\r\n\r\n### End-to-End Testing\r\n- Full system startup and shutdown cycles\r\n- User workflow testing with new service architecture\r\n- Performance regression testing comparing old vs new architecture\r\n- Load testing to verify resource usage improvements\r\n\r\n## Migration Strategy\r\n\r\n### Phase 1: Stabilization (Weeks 1-2)\r\n- Implement ServiceContainer with lifecycle management\r\n- Add initialization guards to prevent duplicate service creation\r\n- Create service health monitoring\r\n- Establish baseline performance metrics\r\n\r\n### Phase 2: Service Consolidation (Weeks 3-8)\r\n- Group related Manager classes into service domains\r\n- Implement new service interfaces and contracts\r\n- Create adapter pattern for backward compatibility\r\n- Migrate one service domain at a time\r\n\r\n### Phase 3: Plugin Unification (Weeks 9-12)\r\n- Consolidate multiple plugin managers into PluginService\r\n- Implement standardized plugin lifecycle\r\n- Migrate existing plugins to new interfaces\r\n- Remove legacy plugin management code\r\n\r\n### Phase 4: Optimization (Weeks 13-16)\r\n- Remove backward compatibility adapters\r\n- Optimize service initialization order\r\n- Implement advanced caching strategies\r\n- Performance tuning and monitoring enhancement\r\n\r\n## Performance Targets\r\n\r\n- **Startup Time**: Reduce from 20-30s to <15s\r\n- **Memory Usage**: Reduce by 200-300MB through singleton enforcement\r\n- **Service Resolution**: <1ms for registered services\r\n- **Plugin Loading**: Parallel loading where dependencies allow\r\n- **Configuration Loading**: <500ms for full configuration validation\r\n\r\n## Monitoring and Health Checks\r\n\r\nEach service will implement:\r\n- Health check endpoint returning detailed status\r\n- Performance metrics collection (response times, resource usage)\r\n- Error rate monitoring with alert thresholds\r\n- Dependency health validation\r\n- Graceful degradation capabilities when dependencies fail\r\n",
  "fileStats": {
    "size": 11825,
    "lines": 283,
    "lastModified": "2025-09-25T15:08:58.839Z"
  },
  "comments": []
}