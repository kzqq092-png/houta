"""
统一网络服务

整合所有网络管理器为单一服务，提供：
- HTTP/HTTPS请求管理
- 智能重试策略
- 熔断器保护
- 请求队列和速率限制
- 连接池管理
- 网络健康监控
- 代理配置管理
"""

import asyncio
import threading
import time
import json
from contextlib import asynccontextmanager
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from enum import Enum
from pathlib import Path
from typing import Any, Dict, List, Optional, Union, Callable, Tuple
from collections import deque, defaultdict
import aiohttp
import requests
from loguru import logger

from ..services.smart_retry_manager import (
    SmartRetryManager, RetryConfig, RetryStrategy, ErrorCategory
)
from ..risk.enhanced_circuit_breaker import (
    EnhancedCircuitBreaker, CircuitBreakerConfig, CircuitState, FailureType
)
from ..network.universal_network_config import (
    UniversalNetworkConfigManager, PluginNetworkConfig, NetworkEndpoint
)
from ..services.base_service import BaseService
from ..events import EventBus, get_event_bus
from ..containers import ServiceContainer, get_service_container


class RequestMethod(Enum):
    """HTTP请求方法"""
    GET = "GET"
    POST = "POST"
    PUT = "PUT"
    DELETE = "DELETE"
    PATCH = "PATCH"
    HEAD = "HEAD"
    OPTIONS = "OPTIONS"


class RequestPriority(Enum):
    """请求优先级"""
    LOW = 1
    NORMAL = 2
    HIGH = 3
    CRITICAL = 4


class ConnectionPoolType(Enum):
    """连接池类型"""
    HTTP = "http"
    HTTPS = "https"
    HTTP2 = "http2"


@dataclass
class NetworkRequest:
    """网络请求"""
    request_id: str
    method: RequestMethod
    url: str
    headers: Dict[str, str] = field(default_factory=dict)
    params: Dict[str, Any] = field(default_factory=dict)
    data: Any = None
    json: Any = None
    timeout: float = 30.0
    priority: RequestPriority = RequestPriority.NORMAL
    retries: int = 3
    retry_config: Optional[RetryConfig] = None
    circuit_breaker_key: Optional[str] = None
    metadata: Dict[str, Any] = field(default_factory=dict)
    created_at: datetime = field(default_factory=datetime.now)


@dataclass
class NetworkResponse:
    """网络响应"""
    request_id: str
    status_code: int
    headers: Dict[str, str]
    content: bytes
    text: str
    json_data: Any = None
    response_time_ms: float = 0.0
    from_cache: bool = False
    endpoint_used: str = ""
    retry_count: int = 0
    error: Optional[str] = None
    timestamp: datetime = field(default_factory=datetime.now)


@dataclass
class NetworkMetrics:
    """网络指标"""
    total_requests: int = 0
    successful_requests: int = 0
    failed_requests: int = 0
    timeout_requests: int = 0
    retry_requests: int = 0
    circuit_breaker_opens: int = 0
    avg_response_time_ms: float = 0.0
    total_bytes_sent: int = 0
    total_bytes_received: int = 0
    active_connections: int = 0
    queue_size: int = 0
    last_updated: datetime = field(default_factory=datetime.now)


@dataclass
class RateLimitConfig:
    """速率限制配置"""
    requests_per_second: float = 10.0
    requests_per_minute: int = 600
    requests_per_hour: int = 36000
    burst_size: int = 50
    enabled: bool = True


@dataclass
class ProxyConfig:
    """代理配置"""
    http_proxy: Optional[str] = None
    https_proxy: Optional[str] = None
    proxy_auth: Optional[Tuple[str, str]] = None
    proxy_rotation_enabled: bool = False
    proxy_list: List[str] = field(default_factory=list)
    current_proxy_index: int = 0


class UnifiedNetworkService(BaseService):
    """
    统一网络服务

    整合所有网络管理功能，提供统一的网络通信接口：
    - HTTP客户端管理
    - 智能重试机制
    - 熔断器保护
    - 请求队列和优先级
    - 速率限制
    - 连接池优化
    - 代理管理
    - 网络监控
    """

    def __init__(self,
                 service_container: Optional[ServiceContainer] = None,
                 event_bus: Optional[EventBus] = None):
        """
        初始化统一网络服务

        Args:
            service_container: 服务容器
            event_bus: 事件总线
        """
        super().__init__(event_bus)

        self._service_container = service_container or get_service_container()

        # 核心组件
        self._retry_manager: Optional[SmartRetryManager] = None
        self._circuit_breakers: Dict[str, EnhancedCircuitBreaker] = {}
        self._network_config: Optional[UniversalNetworkConfigManager] = None

        # HTTP客户端
        self._session: Optional[requests.Session] = None
        self._async_session: Optional[aiohttp.ClientSession] = None

        # 请求队列和管理
        self._request_queue: deque = deque()
        self._active_requests: Dict[str, NetworkRequest] = {}
        self._request_counter = 0

        # 速率限制
        self._rate_limiters: Dict[str, deque] = defaultdict(deque)
        self._rate_limit_config = RateLimitConfig()

        # 代理配置
        self._proxy_config = ProxyConfig()

        # 连接池配置
        self._connection_pools: Dict[ConnectionPoolType, Any] = {}
        self._max_connections = 100
        self._max_connections_per_host = 30

        # 网络指标
        self._metrics = NetworkMetrics()

        # 缓存
        self._response_cache: Dict[str, NetworkResponse] = {}
        self._cache_ttl = timedelta(minutes=5)

        # 线程和锁
        self._queue_lock = threading.RLock()
        self._metrics_lock = threading.RLock()
        self._cache_lock = threading.RLock()

        # 后台任务
        self._request_processor_task: Optional[asyncio.Task] = None
        self._monitoring_task: Optional[asyncio.Task] = None
        self._cleanup_task: Optional[asyncio.Task] = None

        logger.info("Unified network service initialized")

    async def initialize(self) -> None:
        """初始化统一网络服务"""
        try:
            logger.info("Initializing unified network service...")

            # 初始化核心组件
            await self._initialize_core_components()

            # 设置HTTP客户端
            await self._setup_http_clients()

            # 设置熔断器
            await self._setup_circuit_breakers()

            # 启动后台任务
            await self._start_background_tasks()

            self._initialized = True
            logger.info("✅ Unified network service initialized successfully")

        except Exception as e:
            logger.error(f"Failed to initialize unified network service: {e}")
            raise

    async def _initialize_core_components(self) -> None:
        """初始化核心组件"""
        try:
            # 智能重试管理器
            self._retry_manager = SmartRetryManager()

            # 网络配置管理器
            try:
                self._network_config = UniversalNetworkConfigManager()
                await asyncio.to_thread(self._network_config.load_config)
            except Exception as e:
                logger.warning(f"Network config initialization failed: {e}")
                self._network_config = None

            logger.info("Core network components initialized")

        except Exception as e:
            logger.error(f"Failed to initialize core components: {e}")
            raise

    async def _setup_http_clients(self) -> None:
        """设置HTTP客户端"""
        try:
            # 同步HTTP客户端
            self._session = requests.Session()

            # 设置连接池
            adapter = requests.adapters.HTTPAdapter(
                pool_connections=self._max_connections_per_host,
                pool_maxsize=self._max_connections,
                max_retries=0  # 我们自己处理重试
            )
            self._session.mount('http://', adapter)
            self._session.mount('https://', adapter)

            # 异步HTTP客户端
            connector = aiohttp.TCPConnector(
                limit=self._max_connections,
                limit_per_host=self._max_connections_per_host,
                ttl_dns_cache=300,
                use_dns_cache=True
            )

            timeout = aiohttp.ClientTimeout(total=30)
            self._async_session = aiohttp.ClientSession(
                connector=connector,
                timeout=timeout
            )

            logger.info("HTTP clients setup complete")

        except Exception as e:
            logger.error(f"Failed to setup HTTP clients: {e}")
            raise

    async def _setup_circuit_breakers(self) -> None:
        """设置熔断器"""
        try:
            # 默认熔断器配置
            default_config = CircuitBreakerConfig(
                failure_threshold=5,
                success_threshold=3,
                timeout_seconds=60,
                enable_adaptive_threshold=True
            )

            # 为不同的服务域创建熔断器
            service_domains = [
                'default', 'data_source', 'api_gateway',
                'external_api', 'internal_service'
            ]

            for domain in service_domains:
                self._circuit_breakers[domain] = EnhancedCircuitBreaker(
                    name=f"{domain}_circuit_breaker",
                    config=default_config
                )

            logger.info("Circuit breakers setup complete")

        except Exception as e:
            logger.error(f"Failed to setup circuit breakers: {e}")
            raise

    async def _start_background_tasks(self) -> None:
        """启动后台任务"""
        try:
            # 请求处理任务
            self._request_processor_task = asyncio.create_task(self._process_request_queue())

            # 监控任务
            self._monitoring_task = asyncio.create_task(self._monitor_network())

            # 清理任务
            self._cleanup_task = asyncio.create_task(self._cleanup_resources())

            logger.info("Background tasks started")

        except Exception as e:
            logger.error(f"Failed to start background tasks: {e}")

    async def request(self,
                      method: Union[RequestMethod, str],
                      url: str,
                      **kwargs) -> NetworkResponse:
        """
        发送网络请求

        Args:
            method: HTTP方法
            url: 请求URL
            **kwargs: 其他请求参数

        Returns:
            网络响应
        """
        if isinstance(method, str):
            method = RequestMethod(method.upper())

        request_id = f"req_{self._request_counter}"
        self._request_counter += 1

        # 创建请求对象
        network_request = NetworkRequest(
            request_id=request_id,
            method=method,
            url=url,
            headers=kwargs.get('headers', {}),
            params=kwargs.get('params', {}),
            data=kwargs.get('data'),
            json=kwargs.get('json'),
            timeout=kwargs.get('timeout', 30.0),
            priority=kwargs.get('priority', RequestPriority.NORMAL),
            retries=kwargs.get('retries', 3),
            retry_config=kwargs.get('retry_config'),
            circuit_breaker_key=kwargs.get('circuit_breaker_key', 'default'),
            metadata=kwargs.get('metadata', {})
        )

        # 检查缓存
        if method == RequestMethod.GET:
            cached_response = await self._get_cached_response(url, kwargs.get('params', {}))
            if cached_response:
                return cached_response

        # 检查速率限制
        if not await self._check_rate_limit(url):
            raise Exception("Rate limit exceeded")

        # 检查熔断器
        circuit_breaker = self._circuit_breakers.get(network_request.circuit_breaker_key or 'default')
        if circuit_breaker and circuit_breaker.state == CircuitState.OPEN:
            raise Exception("Circuit breaker is open")

        # 执行请求
        try:
            response = await self._execute_request(network_request)

            # 记录成功
            if circuit_breaker:
                await asyncio.to_thread(circuit_breaker.record_success)

            # 缓存响应
            if method == RequestMethod.GET and response.status_code == 200:
                await self._cache_response(url, kwargs.get('params', {}), response)

            return response

        except Exception as e:
            # 记录失败
            if circuit_breaker:
                failure_type = self._classify_error(e)
                await asyncio.to_thread(circuit_breaker.record_failure, failure_type)

            # 重试逻辑
            if network_request.retries > 0:
                return await self._retry_request(network_request, e)

            raise

    async def get(self, url: str, **kwargs) -> NetworkResponse:
        """GET请求"""
        return await self.request(RequestMethod.GET, url, **kwargs)

    async def post(self, url: str, **kwargs) -> NetworkResponse:
        """POST请求"""
        return await self.request(RequestMethod.POST, url, **kwargs)

    async def put(self, url: str, **kwargs) -> NetworkResponse:
        """PUT请求"""
        return await self.request(RequestMethod.PUT, url, **kwargs)

    async def delete(self, url: str, **kwargs) -> NetworkResponse:
        """DELETE请求"""
        return await self.request(RequestMethod.DELETE, url, **kwargs)

    def set_rate_limit(self, requests_per_second: float = 10.0, burst_size: int = 50) -> None:
        """设置速率限制"""
        self._rate_limit_config.requests_per_second = requests_per_second
        self._rate_limit_config.burst_size = burst_size
        logger.info(f"Rate limit set: {requests_per_second} req/s, burst: {burst_size}")

    def set_proxy(self, http_proxy: Optional[str] = None, https_proxy: Optional[str] = None) -> None:
        """设置代理"""
        self._proxy_config.http_proxy = http_proxy
        self._proxy_config.https_proxy = https_proxy

        if self._session:
            proxies = {}
            if http_proxy:
                proxies['http'] = http_proxy
            if https_proxy:
                proxies['https'] = https_proxy
            self._session.proxies.update(proxies)

        logger.info(f"Proxy configured: HTTP={http_proxy}, HTTPS={https_proxy}")

    def add_circuit_breaker(self, key: str, config: CircuitBreakerConfig) -> None:
        """添加熔断器"""
        self._circuit_breakers[key] = EnhancedCircuitBreaker(
            name=f"{key}_circuit_breaker",
            config=config
        )
        logger.info(f"Circuit breaker added: {key}")

    def get_circuit_breaker_status(self, key: str = 'default') -> Dict[str, Any]:
        """获取熔断器状态"""
        circuit_breaker = self._circuit_breakers.get(key)
        if not circuit_breaker:
            return {'error': 'Circuit breaker not found'}

        return {
            'name': circuit_breaker.name,
            'state': circuit_breaker.state.value,
            'failure_count': circuit_breaker.failure_count,
            'success_count': circuit_breaker.success_count,
            'last_failure_time': circuit_breaker.last_failure_time.isoformat() if circuit_breaker.last_failure_time else None,
            'next_attempt_time': circuit_breaker.next_attempt_time.isoformat() if circuit_breaker.next_attempt_time else None
        }

    def get_network_metrics(self) -> Dict[str, Any]:
        """获取网络指标"""
        with self._metrics_lock:
            metrics = {
                'total_requests': self._metrics.total_requests,
                'successful_requests': self._metrics.successful_requests,
                'failed_requests': self._metrics.failed_requests,
                'timeout_requests': self._metrics.timeout_requests,
                'retry_requests': self._metrics.retry_requests,
                'circuit_breaker_opens': self._metrics.circuit_breaker_opens,
                'avg_response_time_ms': self._metrics.avg_response_time_ms,
                'total_bytes_sent': self._metrics.total_bytes_sent,
                'total_bytes_received': self._metrics.total_bytes_received,
                'active_connections': self._metrics.active_connections,
                'queue_size': len(self._request_queue),
                'success_rate': (
                    self._metrics.successful_requests / self._metrics.total_requests * 100
                    if self._metrics.total_requests > 0 else 0
                ),
                'last_updated': self._metrics.last_updated.isoformat()
            }

            # 添加熔断器状态
            metrics['circuit_breakers'] = {
                key: self.get_circuit_breaker_status(key)
                for key in self._circuit_breakers.keys()
            }

            return metrics

    async def _execute_request(self, request: NetworkRequest) -> NetworkResponse:
        """执行网络请求"""
        start_time = time.time()

        try:
            # 记录请求开始
            with self._metrics_lock:
                self._metrics.total_requests += 1
                self._metrics.active_connections += 1

            self._active_requests[request.request_id] = request

            # 选择endpoint
            endpoint_url = await self._select_endpoint(request.url)

            # 准备请求参数
            request_kwargs = {
                'url': endpoint_url,
                'headers': request.headers,
                'timeout': request.timeout
            }

            if request.params:
                request_kwargs['params'] = request.params
            if request.data:
                request_kwargs['data'] = request.data
            if request.json:
                request_kwargs['json'] = request.json

            # 添加代理
            if self._proxy_config.http_proxy or self._proxy_config.https_proxy:
                request_kwargs['proxies'] = {
                    'http': self._proxy_config.http_proxy,
                    'https': self._proxy_config.https_proxy
                }

            # 执行请求
            if self._async_session:
                response = await self._async_session.request(
                    request.method.value,
                    **request_kwargs
                )

                content = await response.read()
                text = await response.text()

                # 尝试解析JSON
                json_data = None
                if 'application/json' in response.headers.get('content-type', ''):
                    try:
                        json_data = await response.json()
                    except:
                        pass

                headers = dict(response.headers)
                status_code = response.status

            else:
                # 同步fallback
                response = self._session.request(
                    request.method.value,
                    **request_kwargs
                )

                content = response.content
                text = response.text
                headers = dict(response.headers)
                status_code = response.status_code

                # 尝试解析JSON
                json_data = None
                try:
                    if response.headers.get('content-type', '').startswith('application/json'):
                        json_data = response.json()
                except:
                    pass

            # 计算响应时间
            response_time_ms = (time.time() - start_time) * 1000

            # 创建响应对象
            network_response = NetworkResponse(
                request_id=request.request_id,
                status_code=status_code,
                headers=headers,
                content=content,
                text=text,
                json_data=json_data,
                response_time_ms=response_time_ms,
                endpoint_used=endpoint_url
            )

            # 更新指标
            with self._metrics_lock:
                self._metrics.successful_requests += 1
                self._metrics.total_bytes_received += len(content)

                # 更新平均响应时间
                total_ops = self._metrics.successful_requests + self._metrics.failed_requests
                self._metrics.avg_response_time_ms = (
                    (self._metrics.avg_response_time_ms * (total_ops - 1) + response_time_ms) / total_ops
                )

                self._metrics.last_updated = datetime.now()

            return network_response

        except Exception as e:
            # 更新失败指标
            with self._metrics_lock:
                self._metrics.failed_requests += 1

                if 'timeout' in str(e).lower():
                    self._metrics.timeout_requests += 1

            logger.error(f"Request failed: {e}")
            raise

        finally:
            # 清理
            if request.request_id in self._active_requests:
                del self._active_requests[request.request_id]

            with self._metrics_lock:
                self._metrics.active_connections = max(0, self._metrics.active_connections - 1)

    async def _retry_request(self, request: NetworkRequest, error: Exception) -> NetworkResponse:
        """重试请求"""
        if self._retry_manager and request.retry_config:
            # 使用智能重试管理器
            retry_allowed = await asyncio.to_thread(
                self._retry_manager.should_retry,
                error, request.retry_config
            )

            if retry_allowed:
                with self._metrics_lock:
                    self._metrics.retry_requests += 1

                # 计算延迟
                delay = await asyncio.to_thread(
                    self._retry_manager.get_retry_delay,
                    request.retry_config
                )

                await asyncio.sleep(delay)

                # 减少重试次数并重新执行
                request.retries -= 1
                return await self._execute_request(request)

        raise error

    async def _check_rate_limit(self, url: str) -> bool:
        """检查速率限制"""
        if not self._rate_limit_config.enabled:
            return True

        now = time.time()
        window = 1.0 / self._rate_limit_config.requests_per_second

        # 清理过期的请求记录
        rate_limiter = self._rate_limiters[url]
        while rate_limiter and rate_limiter[0] < now - window:
            rate_limiter.popleft()

        # 检查是否超过限制
        if len(rate_limiter) >= self._rate_limit_config.burst_size:
            return False

        # 记录当前请求
        rate_limiter.append(now)
        return True

    async def _get_cached_response(self, url: str, params: Dict[str, Any]) -> Optional[NetworkResponse]:
        """获取缓存响应"""
        cache_key = self._generate_cache_key(url, params)

        with self._cache_lock:
            if cache_key in self._response_cache:
                response = self._response_cache[cache_key]

                # 检查是否过期
                if datetime.now() - response.timestamp < self._cache_ttl:
                    response.from_cache = True
                    return response
                else:
                    del self._response_cache[cache_key]

        return None

    async def _cache_response(self, url: str, params: Dict[str, Any], response: NetworkResponse) -> None:
        """缓存响应"""
        cache_key = self._generate_cache_key(url, params)

        with self._cache_lock:
            self._response_cache[cache_key] = response

    def _generate_cache_key(self, url: str, params: Dict[str, Any]) -> str:
        """生成缓存键"""
        import hashlib
        content = f"{url}:{json.dumps(params, sort_keys=True)}"
        return hashlib.md5(content.encode()).hexdigest()

    async def _select_endpoint(self, url: str) -> str:
        """选择最佳endpoint"""
        # 简化实现，实际可以根据网络配置选择最佳endpoint
        return url

    def _classify_error(self, error: Exception) -> FailureType:
        """分类错误类型"""
        error_str = str(error).lower()

        if 'timeout' in error_str:
            return FailureType.TIMEOUT
        elif 'connection' in error_str:
            return FailureType.CONNECTION_ERROR
        elif 'rate limit' in error_str:
            return FailureType.RATE_LIMIT
        elif 'server' in error_str or '5' in error_str:
            return FailureType.SERVER_ERROR
        else:
            return FailureType.UNKNOWN

    async def _process_request_queue(self) -> None:
        """处理请求队列"""
        while True:
            try:
                await asyncio.sleep(0.1)

                # 处理队列中的请求（如果有优先级队列功能的话）
                # 目前的实现是直接处理请求，不使用队列

            except asyncio.CancelledError:
                break
            except Exception as e:
                logger.error(f"Error in request queue processing: {e}")

    async def _monitor_network(self) -> None:
        """网络监控任务"""
        while True:
            try:
                await asyncio.sleep(30)  # 每30秒监控一次

                # 监控连接池状态
                if self._async_session and hasattr(self._async_session, '_connector'):
                    connector = self._async_session._connector
                    with self._metrics_lock:
                        # 更新连接池指标
                        pass

                # 监控熔断器状态
                for key, circuit_breaker in self._circuit_breakers.items():
                    if circuit_breaker.state == CircuitState.OPEN:
                        logger.warning(f"Circuit breaker '{key}' is open")

            except asyncio.CancelledError:
                break
            except Exception as e:
                logger.error(f"Error in network monitoring: {e}")

    async def _cleanup_resources(self) -> None:
        """清理资源"""
        while True:
            try:
                await asyncio.sleep(300)  # 每5分钟清理一次

                # 清理过期缓存
                now = datetime.now()
                with self._cache_lock:
                    expired_keys = [
                        key for key, response in self._response_cache.items()
                        if now - response.timestamp > self._cache_ttl
                    ]

                    for key in expired_keys:
                        del self._response_cache[key]

                # 清理速率限制记录
                cutoff_time = time.time() - 3600  # 清理1小时前的记录
                for url, rate_limiter in self._rate_limiters.items():
                    while rate_limiter and rate_limiter[0] < cutoff_time:
                        rate_limiter.popleft()

            except asyncio.CancelledError:
                break
            except Exception as e:
                logger.error(f"Error in resource cleanup: {e}")

    async def health_check(self) -> Dict[str, Any]:
        """健康检查"""
        health_status = {
            'status': 'healthy',
            'timestamp': datetime.now().isoformat(),
            'components': {},
            'issues': []
        }

        try:
            # 检查HTTP客户端
            if self._session:
                health_status['components']['sync_session'] = 'healthy'
            else:
                health_status['components']['sync_session'] = 'unhealthy'
                health_status['issues'].append('Sync HTTP session not available')

            if self._async_session:
                health_status['components']['async_session'] = 'healthy'
            else:
                health_status['components']['async_session'] = 'unhealthy'
                health_status['issues'].append('Async HTTP session not available')

            # 检查熔断器
            open_circuit_breakers = [
                key for key, cb in self._circuit_breakers.items()
                if cb.state == CircuitState.OPEN
            ]

            if open_circuit_breakers:
                health_status['components']['circuit_breakers'] = 'degraded'
                health_status['issues'].append(f'Open circuit breakers: {open_circuit_breakers}')
            else:
                health_status['components']['circuit_breakers'] = 'healthy'

            # 检查连接池
            active_connections = self._metrics.active_connections
            if active_connections > self._max_connections * 0.9:
                health_status['components']['connection_pool'] = 'degraded'
                health_status['issues'].append(f'High connection usage: {active_connections}/{self._max_connections}')
            else:
                health_status['components']['connection_pool'] = 'healthy'

            # 检查总体状态
            if health_status['issues']:
                health_status['status'] = 'degraded'

        except Exception as e:
            health_status['status'] = 'unhealthy'
            health_status['issues'].append(f"Health check failed: {e}")

        return health_status

    async def shutdown(self) -> None:
        """关闭服务"""
        try:
            logger.info("Shutting down unified network service...")

            # 取消后台任务
            tasks = [self._request_processor_task, self._monitoring_task, self._cleanup_task]
            for task in tasks:
                if task:
                    task.cancel()
                    try:
                        await task
                    except asyncio.CancelledError:
                        pass

            # 关闭HTTP客户端
            if self._async_session:
                await self._async_session.close()

            if self._session:
                self._session.close()

            # 清理资源
            self._request_queue.clear()
            self._active_requests.clear()
            self._response_cache.clear()
            self._rate_limiters.clear()

            logger.info("✅ Unified network service shutdown complete")

        except Exception as e:
            logger.error(f"Error during network service shutdown: {e}")


# 全局实例获取函数
_unified_network_service: Optional[UnifiedNetworkService] = None


def get_unified_network_service() -> UnifiedNetworkService:
    """获取统一网络服务实例"""
    global _unified_network_service

    if _unified_network_service is None:
        _unified_network_service = UnifiedNetworkService()

    return _unified_network_service
