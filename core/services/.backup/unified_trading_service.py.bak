#!/usr/bin/env python3
"""
Unified Trading Service

Consolidates TradingManager, PositionManager, RiskManager into unified service
with proper transaction boundaries and integrated risk controls.

Created for: FactorWeave-Quant Architecture Refactoring Project
Phase: 2 - Service Consolidation
Task: 8 - Implement TradingService consolidating trading managers
"""

import asyncio
import threading
import time
from datetime import datetime, timedelta
from typing import Dict, List, Any, Optional, Union, Callable
from decimal import Decimal
from dataclasses import dataclass, field
from enum import Enum
from concurrent.futures import ThreadPoolExecutor
from contextlib import contextmanager
from loguru import logger

from ..services.base_service import BaseService
from ..events import EventBus, get_event_bus
from ..containers import ServiceContainer, get_service_container

logger = logger.bind(module=__name__)


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"
    LIMIT = "limit"
    STOP = "stop"
    STOP_LIMIT = "stop_limit"


class OrderSide(Enum):
    """订单方向"""
    BUY = "buy"
    SELL = "sell"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"
    PARTIAL_FILLED = "partial_filled"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


class PositionStatus(Enum):
    """持仓状态"""
    OPEN = "open"
    CLOSING = "closing"
    CLOSED = "closed"


@dataclass
class Order:
    """订单信息"""
    order_id: str
    symbol: str
    side: OrderSide
    order_type: OrderType
    quantity: Decimal
    price: Optional[Decimal] = None
    stop_price: Optional[Decimal] = None
    status: OrderStatus = OrderStatus.PENDING
    filled_quantity: Decimal = Decimal('0')
    average_price: Optional[Decimal] = None
    commission: Decimal = Decimal('0')
    created_at: datetime = field(default_factory=datetime.now)
    updated_at: Optional[datetime] = None
    metadata: Dict[str, Any] = field(default_factory=dict)


@dataclass
class Position:
    """持仓信息"""
    position_id: str
    symbol: str
    side: OrderSide
    quantity: Decimal
    entry_price: Decimal
    current_price: Decimal
    unrealized_pnl: Decimal = Decimal('0')
    realized_pnl: Decimal = Decimal('0')
    commission: Decimal = Decimal('0')
    status: PositionStatus = PositionStatus.OPEN
    opened_at: datetime = field(default_factory=datetime.now)
    closed_at: Optional[datetime] = None
    metadata: Dict[str, Any] = field(default_factory=dict)


@dataclass
class RiskLimits:
    """风险限制"""
    max_position_size: Decimal = Decimal('1000000')  # 最大持仓金额
    max_daily_loss: Decimal = Decimal('10000')       # 最大日损失
    max_leverage: Decimal = Decimal('10')            # 最大杠杆
    max_concentration: Decimal = Decimal('0.1')      # 最大集中度 (10%)
    stop_loss_threshold: Decimal = Decimal('0.05')   # 止损阈值 (5%)


@dataclass
class TradingMetrics:
    """交易指标"""
    total_trades: int = 0
    winning_trades: int = 0
    losing_trades: int = 0
    total_pnl: Decimal = Decimal('0')
    total_commission: Decimal = Decimal('0')
    max_drawdown: Decimal = Decimal('0')
    sharpe_ratio: Optional[float] = None
    win_rate: float = 0.0
    average_win: Decimal = Decimal('0')
    average_loss: Decimal = Decimal('0')
    last_updated: datetime = field(default_factory=datetime.now)


class UnifiedTradingService(BaseService):
    """
    统一交易服务

    整合交易管理器、持仓管理器和风险管理器的功能，提供：
    - 统一的订单管理和执行
    - 实时持仓跟踪和更新
    - 集成的风险控制和监控
    - 交易性能分析和报告
    - 事务边界和数据一致性保证
    """

    def __init__(self,
                 service_container: Optional[ServiceContainer] = None,
                 event_bus: Optional[EventBus] = None):
        super().__init__()
        self.service_name = "UnifiedTradingService"

        # 依赖注入
        self._service_container = service_container or get_service_container()
        self._event_bus = event_bus or get_event_bus()

        # 核心存储
        self._orders: Dict[str, Order] = {}
        self._positions: Dict[str, Position] = {}
        self._risk_limits = RiskLimits()
        self._trading_metrics = TradingMetrics()

        # 同步控制
        self._order_lock = threading.RLock()
        self._position_lock = threading.RLock()
        self._metrics_lock = threading.RLock()

        # 执行器
        self._executor = ThreadPoolExecutor(max_workers=4, thread_name_prefix="TradingService")

        # 风险监控
        self._risk_monitor_active = False
        self._risk_monitor_thread: Optional[threading.Thread] = None

        # 价格更新回调
        self._price_callbacks: List[Callable[[str, Decimal], None]] = []

        logger.info(f"{self.service_name} initialized")

    async def _do_initialize(self) -> bool:
        """初始化交易服务"""
        try:
            logger.info("Initializing UnifiedTradingService...")

            # 加载历史数据
            await self._load_trading_data()

            # 初始化风险监控
            self._start_risk_monitoring()

            # 注册事件监听器
            self._register_event_listeners()

            logger.info("UnifiedTradingService initialized successfully")
            return True

        except Exception as e:
            logger.error(f"Failed to initialize UnifiedTradingService: {e}")
            return False

    async def _load_trading_data(self) -> None:
        """加载交易历史数据"""
        try:
            # 这里可以从数据库或文件加载历史订单和持仓
            # 目前使用空实现，实际项目中需要连接数据存储
            logger.info("Trading data loaded successfully")

        except Exception as e:
            logger.warning(f"Failed to load trading data: {e}")

    def _start_risk_monitoring(self) -> None:
        """启动风险监控"""
        try:
            self._risk_monitor_active = True
            self._risk_monitor_thread = threading.Thread(
                target=self._risk_monitor_loop,
                name="RiskMonitor",
                daemon=True
            )
            self._risk_monitor_thread.start()
            logger.info("Risk monitoring started")

        except Exception as e:
            logger.error(f"Failed to start risk monitoring: {e}")

    def _risk_monitor_loop(self) -> None:
        """风险监控循环"""
        while self._risk_monitor_active:
            try:
                self._check_risk_limits()
                time.sleep(1)  # 每秒检查一次

            except Exception as e:
                logger.error(f"Risk monitoring error: {e}")
                time.sleep(5)  # 出错时延长等待时间

    def _check_risk_limits(self) -> None:
        """检查风险限制"""
        try:
            with self._position_lock:
                total_exposure = sum(
                    pos.quantity * pos.current_price
                    for pos in self._positions.values()
                    if pos.status == PositionStatus.OPEN
                )

                # 检查最大持仓限制
                if total_exposure > self._risk_limits.max_position_size:
                    self._emit_risk_alert("MAX_POSITION_EXCEEDED", {
                        "current_exposure": float(total_exposure),
                        "limit": float(self._risk_limits.max_position_size)
                    })

                # 检查日损失限制
                daily_pnl = self._calculate_daily_pnl()
                if daily_pnl < -self._risk_limits.max_daily_loss:
                    self._emit_risk_alert("DAILY_LOSS_EXCEEDED", {
                        "daily_pnl": float(daily_pnl),
                        "limit": float(self._risk_limits.max_daily_loss)
                    })

        except Exception as e:
            logger.error(f"Risk limit check failed: {e}")

    def _calculate_daily_pnl(self) -> Decimal:
        """计算当日盈亏"""
        today = datetime.now().date()
        daily_pnl = Decimal('0')

        with self._position_lock:
            for position in self._positions.values():
                if position.opened_at.date() == today:
                    daily_pnl += position.unrealized_pnl + position.realized_pnl

        return daily_pnl

    def _emit_risk_alert(self, alert_type: str, data: Dict[str, Any]) -> None:
        """发送风险警报"""
        try:
            self._event_bus.emit("trading.risk_alert", {
                "alert_type": alert_type,
                "timestamp": datetime.now().isoformat(),
                "data": data
            })
            logger.warning(f"Risk alert: {alert_type} - {data}")

        except Exception as e:
            logger.error(f"Failed to emit risk alert: {e}")

    def _register_event_listeners(self) -> None:
        """注册事件监听器"""
        try:
            # 监听价格更新事件
            self._event_bus.on("market.price_update", self._on_price_update)

            # 监听订单状态更新事件
            self._event_bus.on("trading.order_update", self._on_order_update)

            logger.info("Event listeners registered")

        except Exception as e:
            logger.error(f"Failed to register event listeners: {e}")

    def _on_price_update(self, event_data: Dict[str, Any]) -> None:
        """处理价格更新事件"""
        try:
            symbol = event_data.get("symbol")
            price = Decimal(str(event_data.get("price", 0)))

            if symbol and price > 0:
                self._update_position_prices(symbol, price)

                # 调用价格更新回调
                for callback in self._price_callbacks:
                    try:
                        callback(symbol, price)
                    except Exception as e:
                        logger.error(f"Price callback error: {e}")

        except Exception as e:
            logger.error(f"Price update handling failed: {e}")

    def _update_position_prices(self, symbol: str, price: Decimal) -> None:
        """更新持仓价格"""
        try:
            with self._position_lock:
                for position in self._positions.values():
                    if position.symbol == symbol and position.status == PositionStatus.OPEN:
                        position.current_price = price

                        # 计算未实现盈亏
                        if position.side == OrderSide.BUY:
                            position.unrealized_pnl = (price - position.entry_price) * position.quantity
                        else:
                            position.unrealized_pnl = (position.entry_price - price) * position.quantity

        except Exception as e:
            logger.error(f"Position price update failed: {e}")

    def _on_order_update(self, event_data: Dict[str, Any]) -> None:
        """处理订单状态更新事件"""
        try:
            order_id = event_data.get("order_id")
            if order_id and order_id in self._orders:
                order = self._orders[order_id]
                order.status = OrderStatus(event_data.get("status", order.status.value))
                order.filled_quantity = Decimal(str(event_data.get("filled_quantity", order.filled_quantity)))
                order.updated_at = datetime.now()

                # 如果订单完全成交，更新持仓
                if order.status == OrderStatus.FILLED:
                    self._update_position_from_order(order)

        except Exception as e:
            logger.error(f"Order update handling failed: {e}")

    # ================================
    # 公共API - 订单管理
    # ================================

    def create_order(self,
                     symbol: str,
                     side: OrderSide,
                     order_type: OrderType,
                     quantity: Decimal,
                     price: Optional[Decimal] = None,
                     stop_price: Optional[Decimal] = None,
                     metadata: Optional[Dict[str, Any]] = None) -> str:
        """创建订单"""
        try:
            # 风险检查
            if not self._validate_order_risk(symbol, side, quantity, price):
                raise ValueError("Order rejected by risk management")

            # 创建订单
            order_id = f"order_{int(time.time() * 1000)}_{symbol}"
            order = Order(
                order_id=order_id,
                symbol=symbol,
                side=side,
                order_type=order_type,
                quantity=quantity,
                price=price,
                stop_price=stop_price,
                metadata=metadata or {}
            )

            with self._order_lock:
                self._orders[order_id] = order

            # 发送订单创建事件
            self._event_bus.emit("trading.order_created", {
                "order_id": order_id,
                "symbol": symbol,
                "side": side.value,
                "type": order_type.value,
                "quantity": float(quantity)
            })

            logger.info(f"Order created: {order_id}")
            return order_id

        except Exception as e:
            logger.error(f"Failed to create order: {e}")
            raise

    def cancel_order(self, order_id: str) -> bool:
        """取消订单"""
        try:
            with self._order_lock:
                if order_id not in self._orders:
                    logger.warning(f"Order not found: {order_id}")
                    return False

                order = self._orders[order_id]
                if order.status in [OrderStatus.FILLED, OrderStatus.CANCELLED]:
                    logger.warning(f"Cannot cancel order in status: {order.status}")
                    return False

                order.status = OrderStatus.CANCELLED
                order.updated_at = datetime.now()

            # 发送订单取消事件
            self._event_bus.emit("trading.order_cancelled", {
                "order_id": order_id
            })

            logger.info(f"Order cancelled: {order_id}")
            return True

        except Exception as e:
            logger.error(f"Failed to cancel order: {e}")
            return False

    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        with self._order_lock:
            return self._orders.get(order_id)

    def get_orders(self,
                   symbol: Optional[str] = None,
                   status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        with self._order_lock:
            orders = list(self._orders.values())

            if symbol:
                orders = [o for o in orders if o.symbol == symbol]
            if status:
                orders = [o for o in orders if o.status == status]

            return orders

    # ================================
    # 公共API - 持仓管理
    # ================================

    def get_position(self, symbol: str) -> Optional[Position]:
        """获取持仓信息"""
        with self._position_lock:
            for position in self._positions.values():
                if position.symbol == symbol and position.status == PositionStatus.OPEN:
                    return position
            return None

    def get_positions(self, status: Optional[PositionStatus] = None) -> List[Position]:
        """获取持仓列表"""
        with self._position_lock:
            positions = list(self._positions.values())

            if status:
                positions = [p for p in positions if p.status == status]

            return positions

    def close_position(self, symbol: str, quantity: Optional[Decimal] = None) -> bool:
        """平仓"""
        try:
            position = self.get_position(symbol)
            if not position:
                logger.warning(f"No open position found for symbol: {symbol}")
                return False

            close_quantity = quantity or position.quantity
            if close_quantity > position.quantity:
                close_quantity = position.quantity

            # 创建平仓订单
            close_side = OrderSide.SELL if position.side == OrderSide.BUY else OrderSide.BUY
            order_id = self.create_order(
                symbol=symbol,
                side=close_side,
                order_type=OrderType.MARKET,
                quantity=close_quantity,
                metadata={"close_position": True}
            )

            logger.info(f"Close position order created: {order_id} for {symbol}")
            return True

        except Exception as e:
            logger.error(f"Failed to close position: {e}")
            return False

    # ================================
    # 公共API - 风险管理
    # ================================

    def update_risk_limits(self, risk_limits: RiskLimits) -> None:
        """更新风险限制"""
        self._risk_limits = risk_limits
        logger.info("Risk limits updated")

    def get_risk_limits(self) -> RiskLimits:
        """获取风险限制"""
        return self._risk_limits

    def _validate_order_risk(self, symbol: str, side: OrderSide, quantity: Decimal, price: Optional[Decimal]) -> bool:
        """验证订单风险"""
        try:
            # 计算订单价值
            estimated_price = price or self._get_market_price(symbol)
            if not estimated_price:
                logger.warning(f"Cannot validate risk: no price for {symbol}")
                return True  # 如果无法获取价格，允许订单通过

            order_value = quantity * estimated_price

            # 检查单笔订单大小
            if order_value > self._risk_limits.max_position_size * Decimal('0.1'):  # 单笔不超过10%
                logger.warning(f"Order too large: {order_value}")
                return False

            # 检查总敞口
            current_exposure = sum(
                pos.quantity * pos.current_price
                for pos in self._positions.values()
                if pos.status == PositionStatus.OPEN
            )

            if side == OrderSide.BUY:
                new_exposure = current_exposure + order_value
            else:
                new_exposure = current_exposure - order_value

            if new_exposure > self._risk_limits.max_position_size:
                logger.warning(f"Total exposure would exceed limit: {new_exposure}")
                return False

            return True

        except Exception as e:
            logger.error(f"Risk validation failed: {e}")
            return False

    def _get_market_price(self, symbol: str) -> Optional[Decimal]:
        """获取市场价格"""
        try:
            # 这里应该从市场数据服务获取最新价格
            # 目前返回模拟价格
            return Decimal('100.0')

        except Exception as e:
            logger.error(f"Failed to get market price for {symbol}: {e}")
            return None

    # ================================
    # 公共API - 交易指标
    # ================================

    def get_trading_metrics(self) -> TradingMetrics:
        """获取交易指标"""
        with self._metrics_lock:
            self._update_trading_metrics()
            return self._trading_metrics

    def _update_trading_metrics(self) -> None:
        """更新交易指标"""
        try:
            filled_orders = [o for o in self._orders.values() if o.status == OrderStatus.FILLED]
            closed_positions = [p for p in self._positions.values() if p.status == PositionStatus.CLOSED]

            self._trading_metrics.total_trades = len(filled_orders)
            self._trading_metrics.winning_trades = len([p for p in closed_positions if p.realized_pnl > 0])
            self._trading_metrics.losing_trades = len([p for p in closed_positions if p.realized_pnl < 0])

            if self._trading_metrics.total_trades > 0:
                self._trading_metrics.win_rate = self._trading_metrics.winning_trades / self._trading_metrics.total_trades

            total_pnl = sum(p.realized_pnl for p in closed_positions)
            self._trading_metrics.total_pnl = total_pnl

            total_commission = sum(o.commission for o in filled_orders)
            self._trading_metrics.total_commission = total_commission

            self._trading_metrics.last_updated = datetime.now()

        except Exception as e:
            logger.error(f"Failed to update trading metrics: {e}")

    def _update_position_from_order(self, order: Order) -> None:
        """根据订单更新持仓"""
        try:
            with self._position_lock:
                symbol = order.symbol
                existing_position = self.get_position(symbol)

                if existing_position:
                    # 更新现有持仓
                    if order.side == existing_position.side:
                        # 加仓
                        total_value = (existing_position.quantity * existing_position.entry_price +
                                       order.filled_quantity * order.average_price)
                        total_quantity = existing_position.quantity + order.filled_quantity
                        existing_position.entry_price = total_value / total_quantity
                        existing_position.quantity = total_quantity
                    else:
                        # 减仓或平仓
                        if order.filled_quantity >= existing_position.quantity:
                            # 完全平仓
                            existing_position.status = PositionStatus.CLOSED
                            existing_position.closed_at = datetime.now()
                            existing_position.realized_pnl = self._calculate_realized_pnl(existing_position, order)
                        else:
                            # 部分平仓
                            existing_position.quantity -= order.filled_quantity
                            partial_pnl = self._calculate_partial_pnl(existing_position, order)
                            existing_position.realized_pnl += partial_pnl
                else:
                    # 创建新持仓
                    position_id = f"pos_{int(time.time() * 1000)}_{symbol}"
                    position = Position(
                        position_id=position_id,
                        symbol=symbol,
                        side=order.side,
                        quantity=order.filled_quantity,
                        entry_price=order.average_price,
                        current_price=order.average_price
                    )
                    self._positions[position_id] = position

        except Exception as e:
            logger.error(f"Failed to update position from order: {e}")

    def _calculate_realized_pnl(self, position: Position, close_order: Order) -> Decimal:
        """计算已实现盈亏"""
        if position.side == OrderSide.BUY:
            return (close_order.average_price - position.entry_price) * position.quantity
        else:
            return (position.entry_price - close_order.average_price) * position.quantity

    def _calculate_partial_pnl(self, position: Position, close_order: Order) -> Decimal:
        """计算部分平仓盈亏"""
        if position.side == OrderSide.BUY:
            return (close_order.average_price - position.entry_price) * close_order.filled_quantity
        else:
            return (position.entry_price - close_order.average_price) * close_order.filled_quantity

    # ================================
    # 公共API - 工具方法
    # ================================

    def add_price_callback(self, callback: Callable[[str, Decimal], None]) -> None:
        """添加价格更新回调"""
        self._price_callbacks.append(callback)

    def remove_price_callback(self, callback: Callable[[str, Decimal], None]) -> None:
        """移除价格更新回调"""
        if callback in self._price_callbacks:
            self._price_callbacks.remove(callback)

    @contextmanager
    def transaction(self):
        """交易事务上下文管理器"""
        try:
            # 开始事务
            yield self
            # 提交事务 (在实际实现中，这里会提交数据库事务)

        except Exception as e:
            # 回滚事务
            logger.error(f"Transaction rolled back: {e}")
            raise

    async def shutdown(self) -> None:
        """关闭服务"""
        try:
            logger.info("Shutting down UnifiedTradingService...")

            # 停止风险监控
            self._risk_monitor_active = False
            if self._risk_monitor_thread:
                self._risk_monitor_thread.join(timeout=5)

            # 关闭执行器
            self._executor.shutdown(wait=True)

            # 保存交易数据
            await self._save_trading_data()

            logger.info("UnifiedTradingService shutdown completed")

        except Exception as e:
            logger.error(f"Error during UnifiedTradingService shutdown: {e}")

    async def _save_trading_data(self) -> None:
        """保存交易数据"""
        try:
            # 这里应该将订单和持仓数据保存到数据库
            # 目前使用空实现
            logger.info("Trading data saved successfully")

        except Exception as e:
            logger.error(f"Failed to save trading data: {e}")


# ================================
# 服务工厂函数
# ================================

_unified_trading_service: Optional[UnifiedTradingService] = None


def get_unified_trading_service(
    service_container: Optional[ServiceContainer] = None,
    event_bus: Optional[EventBus] = None
) -> UnifiedTradingService:
    """获取统一交易服务实例"""
    global _unified_trading_service

    if _unified_trading_service is None:
        _unified_trading_service = UnifiedTradingService(
            service_container=service_container,
            event_bus=event_bus
        )

    return _unified_trading_service
