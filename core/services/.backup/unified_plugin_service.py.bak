"""
统一插件服务模块

整合PluginManager、PluginCenter和AsyncPluginDiscovery功能，
提供统一的插件管理接口和标准化的插件生命周期管理。
"""

import asyncio
import threading
import time
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union, Callable, Set, Tuple
from dataclasses import dataclass, field
from enum import Enum
from concurrent.futures import ThreadPoolExecutor, Future
import json
import os
from pathlib import Path

from loguru import logger

from .base_service import BaseService
from ..events import EventBus, get_event_bus
from ..containers import ServiceContainer, get_service_container
from ..plugin_types import PluginType, AssetType, DataType
from ..plugin_manager import PluginManager
from ..plugin_center import PluginCenter
from ..data_source_extensions import IDataSourcePlugin, PluginInfo, HealthCheckResult


class PluginState(Enum):
    """插件状态枚举"""
    UNKNOWN = "unknown"
    DISCOVERED = "discovered"
    VALIDATED = "validated"
    INITIALIZED = "initialized"
    ACTIVATED = "activated"
    DEACTIVATED = "deactivated"
    FAILED = "failed"
    REMOVED = "removed"


class PluginLifecycleStage(Enum):
    """插件生命周期阶段"""
    DISCOVER = "discover"
    VALIDATE = "validate"
    INITIALIZE = "initialize"
    ACTIVATE = "activate"
    DEACTIVATE = "deactivate"
    REMOVE = "remove"


@dataclass
class PluginMetadata:
    """插件元数据"""
    plugin_id: str
    name: str
    version: str
    description: str
    plugin_type: PluginType
    state: PluginState
    discovery_time: datetime
    initialization_time: Optional[datetime] = None
    activation_time: Optional[datetime] = None
    error_message: Optional[str] = None
    dependencies: List[str] = field(default_factory=list)
    supported_assets: List[AssetType] = field(default_factory=list)
    supported_data_types: List[DataType] = field(default_factory=list)
    health_status: Optional[HealthCheckResult] = None
    plugin_instance: Optional[Any] = None
    plugin_info: Optional[PluginInfo] = None


@dataclass
class PluginLifecycleEvent:
    """插件生命周期事件"""
    plugin_id: str
    stage: PluginLifecycleStage
    timestamp: datetime
    success: bool
    details: Dict[str, Any] = field(default_factory=dict)
    error_message: Optional[str] = None


class UnifiedPluginService(BaseService):
    """
    统一插件服务

    整合所有插件管理功能，提供标准化的插件生命周期管理。
    """

    def __init__(self,
                 plugin_dir: str = "plugins",
                 service_container: Optional[ServiceContainer] = None,
                 event_bus: Optional[EventBus] = None):
        """
        初始化统一插件服务

        Args:
            plugin_dir: 插件目录
            service_container: 服务容器
            event_bus: 事件总线
        """
        super().__init__(event_bus)

        self._plugin_dir = Path(plugin_dir)
        self._service_container = service_container or get_service_container()

        # 核心组件
        self._plugin_manager: Optional[PluginManager] = None
        self._plugin_center: Optional[PluginCenter] = None

        # 插件管理
        self._plugins: Dict[str, PluginMetadata] = {}
        self._plugin_states: Dict[str, PluginState] = {}
        self._plugin_dependencies: Dict[str, Set[str]] = {}
        self._plugin_dependents: Dict[str, Set[str]] = {}

        # 生命周期管理
        self._lifecycle_events: List[PluginLifecycleEvent] = []
        self._lifecycle_callbacks: Dict[PluginLifecycleStage, List[Callable]] = {
            stage: [] for stage in PluginLifecycleStage
        }

        # 异步管理
        self._discovery_executor = ThreadPoolExecutor(max_workers=5, thread_name_prefix="PluginDiscovery")
        self._initialization_executor = ThreadPoolExecutor(max_workers=3, thread_name_prefix="PluginInit")

        # 同步控制
        self._lock = threading.RLock()
        self._discovery_lock = threading.Lock()

        # 监控状态
        self._auto_discovery_enabled = True
        self._discovery_interval = 30  # 30秒
        self._discovery_thread: Optional[threading.Thread] = None

        logger.info(f"Unified plugin service initialized with plugin dir: {self._plugin_dir}")

    def initialize(self) -> None:
        """初始化服务"""
        if self._initialized:
            return

        try:
            with self._lock:
                logger.info("Initializing unified plugin service...")

                # 初始化核心组件
                self._initialize_core_components()

                # 初始化插件目录
                self._initialize_plugin_directory()

                # 执行初始插件发现
                self._perform_initial_discovery()

                # 启动自动发现
                if self._auto_discovery_enabled:
                    self._start_auto_discovery()

                self._initialized = True

                logger.info("✅ Unified plugin service initialized successfully")

        except Exception as e:
            logger.error(f"Failed to initialize unified plugin service: {e}")
            raise

    def _initialize_core_components(self) -> None:
        """初始化核心组件"""
        try:
            # 创建或获取插件管理器
            if self._service_container.is_registered(PluginManager):
                self._plugin_manager = self._service_container.resolve(PluginManager)
                logger.info("Using existing PluginManager from service container")
            else:
                self._plugin_manager = PluginManager(
                    plugin_dir=str(self._plugin_dir),
                    main_window=None,
                    data_manager=None
                )
                logger.info("Created new PluginManager")

            # 创建插件中心
            self._plugin_center = PluginCenter(self._plugin_manager)

            logger.info("Core plugin components initialized")

        except Exception as e:
            logger.error(f"Failed to initialize core plugin components: {e}")
            raise

    def _initialize_plugin_directory(self) -> None:
        """初始化插件目录"""
        try:
            self._plugin_dir.mkdir(parents=True, exist_ok=True)

            # 检查插件目录结构
            subdirs = ['data_sources', 'indicators', 'strategies', 'ui_extensions']
            for subdir in subdirs:
                (self._plugin_dir / subdir).mkdir(exist_ok=True)

            logger.info(f"Plugin directory structure initialized: {self._plugin_dir}")

        except Exception as e:
            logger.error(f"Failed to initialize plugin directory: {e}")
            raise

    def _perform_initial_discovery(self) -> None:
        """执行初始插件发现"""
        try:
            logger.info("Performing initial plugin discovery...")

            # 异步发现插件
            future = self._discovery_executor.submit(self._discover_plugins)
            discovered_plugins = future.result(timeout=30)  # 30秒超时

            logger.info(f"Initial discovery completed: {len(discovered_plugins)} plugins found")

        except Exception as e:
            logger.error(f"Initial plugin discovery failed: {e}")

    def _start_auto_discovery(self) -> None:
        """启动自动发现"""
        try:
            self._discovery_thread = threading.Thread(
                target=self._auto_discovery_loop,
                name="PluginAutoDiscovery",
                daemon=True
            )
            self._discovery_thread.start()

            logger.info("Auto plugin discovery started")

        except Exception as e:
            logger.error(f"Failed to start auto discovery: {e}")

    def _auto_discovery_loop(self) -> None:
        """自动发现循环"""
        while not self._disposed and self._auto_discovery_enabled:
            try:
                time.sleep(self._discovery_interval)

                if not self._disposed:
                    self._discover_plugins()

            except Exception as e:
                logger.error(f"Error in auto discovery loop: {e}")
                time.sleep(5)  # 错误时短暂等待

    def discover_plugins(self) -> List[PluginMetadata]:
        """
        手动触发插件发现

        Returns:
            发现的插件列表
        """
        try:
            future = self._discovery_executor.submit(self._discover_plugins)
            return future.result(timeout=30)

        except Exception as e:
            logger.error(f"Manual plugin discovery failed: {e}")
            return []

    def _discover_plugins(self) -> List[PluginMetadata]:
        """发现插件（内部方法）"""
        discovered = []

        try:
            with self._discovery_lock:
                # 使用插件中心发现插件
                if self._plugin_center:
                    registration_results = self._plugin_center.discover_and_register_plugins()

                    for plugin_id, status in registration_results.items():
                        if status == "success" and plugin_id not in self._plugins:
                            metadata = PluginMetadata(
                                plugin_id=plugin_id,
                                name=plugin_id,
                                version='1.0.0',
                                description=f'Auto-discovered plugin: {plugin_id}',
                                plugin_type=PluginType.DATA_SOURCE,  # 默认为数据源类型
                                state=PluginState.DISCOVERED,
                                discovery_time=datetime.now(),
                                plugin_info=None
                            )

                            self._plugins[plugin_id] = metadata
                            self._plugin_states[plugin_id] = PluginState.DISCOVERED

                            # 记录生命周期事件
                            self._record_lifecycle_event(
                                plugin_id, PluginLifecycleStage.DISCOVER, True
                            )

                            discovered.append(metadata)

                            logger.info(f"Discovered plugin: {plugin_id}")

        except Exception as e:
            logger.error(f"Plugin discovery failed: {e}")

        return discovered

    def validate_plugin(self, plugin_id: str) -> bool:
        """
        验证插件

        Args:
            plugin_id: 插件ID

        Returns:
            验证是否成功
        """
        try:
            if plugin_id not in self._plugins:
                logger.error(f"Plugin {plugin_id} not found")
                return False

            metadata = self._plugins[plugin_id]

            # 基本验证
            if not metadata.plugin_info:
                self._record_lifecycle_event(
                    plugin_id, PluginLifecycleStage.VALIDATE, False,
                    error_message="No plugin info available"
                )
                return False

            # 验证插件类型
            if not isinstance(metadata.plugin_type, PluginType):
                self._record_lifecycle_event(
                    plugin_id, PluginLifecycleStage.VALIDATE, False,
                    error_message="Invalid plugin type"
                )
                return False

            # 更新状态
            metadata.state = PluginState.VALIDATED
            self._plugin_states[plugin_id] = PluginState.VALIDATED

            self._record_lifecycle_event(
                plugin_id, PluginLifecycleStage.VALIDATE, True
            )

            logger.info(f"Plugin {plugin_id} validated successfully")
            return True

        except Exception as e:
            logger.error(f"Plugin validation failed for {plugin_id}: {e}")
            self._record_lifecycle_event(
                plugin_id, PluginLifecycleStage.VALIDATE, False,
                error_message=str(e)
            )
            return False

    def initialize_plugin(self, plugin_id: str) -> bool:
        """
        初始化插件

        Args:
            plugin_id: 插件ID

        Returns:
            初始化是否成功
        """
        try:
            if plugin_id not in self._plugins:
                logger.error(f"Plugin {plugin_id} not found")
                return False

            metadata = self._plugins[plugin_id]

            # 检查状态
            if metadata.state not in [PluginState.DISCOVERED, PluginState.VALIDATED]:
                logger.warning(f"Plugin {plugin_id} not in valid state for initialization: {metadata.state}")
                return False

            # 先验证
            if metadata.state == PluginState.DISCOVERED:
                if not self.validate_plugin(plugin_id):
                    return False

            # 使用插件管理器初始化
            if self._plugin_manager:
                success = self._plugin_manager.initialize_plugin(plugin_id)

                if success:
                    metadata.state = PluginState.INITIALIZED
                    metadata.initialization_time = datetime.now()
                    self._plugin_states[plugin_id] = PluginState.INITIALIZED

                    self._record_lifecycle_event(
                        plugin_id, PluginLifecycleStage.INITIALIZE, True
                    )

                    logger.info(f"Plugin {plugin_id} initialized successfully")
                    return True
                else:
                    self._record_lifecycle_event(
                        plugin_id, PluginLifecycleStage.INITIALIZE, False,
                        error_message="Plugin manager initialization failed"
                    )
                    return False

            return False

        except Exception as e:
            logger.error(f"Plugin initialization failed for {plugin_id}: {e}")
            self._record_lifecycle_event(
                plugin_id, PluginLifecycleStage.INITIALIZE, False,
                error_message=str(e)
            )
            return False

    def activate_plugin(self, plugin_id: str) -> bool:
        """
        激活插件

        Args:
            plugin_id: 插件ID

        Returns:
            激活是否成功
        """
        try:
            if plugin_id not in self._plugins:
                logger.error(f"Plugin {plugin_id} not found")
                return False

            metadata = self._plugins[plugin_id]

            # 检查状态
            if metadata.state != PluginState.INITIALIZED:
                logger.warning(f"Plugin {plugin_id} not initialized, cannot activate")
                return False

            # 检查依赖
            if not self._check_dependencies(plugin_id):
                self._record_lifecycle_event(
                    plugin_id, PluginLifecycleStage.ACTIVATE, False,
                    error_message="Dependencies not satisfied"
                )
                return False

            # 激活插件
            if self._plugin_manager:
                plugin_instance = self._plugin_manager.get_plugin(plugin_id)

                if plugin_instance:
                    # 如果插件有activate方法，调用它
                    if hasattr(plugin_instance, 'activate'):
                        plugin_instance.activate()

                    metadata.state = PluginState.ACTIVATED
                    metadata.activation_time = datetime.now()
                    metadata.plugin_instance = plugin_instance
                    self._plugin_states[plugin_id] = PluginState.ACTIVATED

                    self._record_lifecycle_event(
                        plugin_id, PluginLifecycleStage.ACTIVATE, True
                    )

                    logger.info(f"Plugin {plugin_id} activated successfully")
                    return True

            return False

        except Exception as e:
            logger.error(f"Plugin activation failed for {plugin_id}: {e}")
            self._record_lifecycle_event(
                plugin_id, PluginLifecycleStage.ACTIVATE, False,
                error_message=str(e)
            )
            return False

    def deactivate_plugin(self, plugin_id: str) -> bool:
        """
        停用插件

        Args:
            plugin_id: 插件ID

        Returns:
            停用是否成功
        """
        try:
            if plugin_id not in self._plugins:
                logger.error(f"Plugin {plugin_id} not found")
                return False

            metadata = self._plugins[plugin_id]

            if metadata.state != PluginState.ACTIVATED:
                logger.warning(f"Plugin {plugin_id} not activated, cannot deactivate")
                return False

            # 停用插件
            if metadata.plugin_instance:
                if hasattr(metadata.plugin_instance, 'deactivate'):
                    metadata.plugin_instance.deactivate()

            metadata.state = PluginState.DEACTIVATED
            self._plugin_states[plugin_id] = PluginState.DEACTIVATED

            self._record_lifecycle_event(
                plugin_id, PluginLifecycleStage.DEACTIVATE, True
            )

            logger.info(f"Plugin {plugin_id} deactivated successfully")
            return True

        except Exception as e:
            logger.error(f"Plugin deactivation failed for {plugin_id}: {e}")
            self._record_lifecycle_event(
                plugin_id, PluginLifecycleStage.DEACTIVATE, False,
                error_message=str(e)
            )
            return False

    def _check_dependencies(self, plugin_id: str) -> bool:
        """检查插件依赖"""
        try:
            dependencies = self._plugin_dependencies.get(plugin_id, set())

            for dep_id in dependencies:
                if dep_id not in self._plugins:
                    logger.warning(f"Dependency {dep_id} not found for plugin {plugin_id}")
                    return False

                dep_state = self._plugin_states.get(dep_id)
                if dep_state != PluginState.ACTIVATED:
                    logger.warning(f"Dependency {dep_id} not activated for plugin {plugin_id}")
                    return False

            return True

        except Exception as e:
            logger.error(f"Error checking dependencies for {plugin_id}: {e}")
            return False

    def _record_lifecycle_event(self, plugin_id: str, stage: PluginLifecycleStage,
                                success: bool, error_message: Optional[str] = None,
                                details: Optional[Dict[str, Any]] = None) -> None:
        """记录生命周期事件"""
        try:
            event = PluginLifecycleEvent(
                plugin_id=plugin_id,
                stage=stage,
                timestamp=datetime.now(),
                success=success,
                details=details or {},
                error_message=error_message
            )

            self._lifecycle_events.append(event)

            # 限制事件数量
            if len(self._lifecycle_events) > 1000:
                self._lifecycle_events = self._lifecycle_events[-500:]

            # 调用回调
            callbacks = self._lifecycle_callbacks.get(stage, [])
            for callback in callbacks:
                try:
                    callback(event)
                except Exception as e:
                    logger.error(f"Error in lifecycle callback: {e}")

        except Exception as e:
            logger.error(f"Error recording lifecycle event: {e}")

    def get_plugin_metadata(self, plugin_id: Optional[str] = None) -> Union[PluginMetadata, Dict[str, PluginMetadata]]:
        """
        获取插件元数据

        Args:
            plugin_id: 插件ID，为None时返回所有插件

        Returns:
            插件元数据
        """
        if plugin_id:
            return self._plugins.get(plugin_id)
        return self._plugins.copy()

    def get_plugins_by_type(self, plugin_type: PluginType) -> List[PluginMetadata]:
        """
        根据类型获取插件

        Args:
            plugin_type: 插件类型

        Returns:
            指定类型的插件列表
        """
        return [
            metadata for metadata in self._plugins.values()
            if metadata.plugin_type == plugin_type
        ]

    def get_plugins_by_state(self, state: PluginState) -> List[PluginMetadata]:
        """
        根据状态获取插件

        Args:
            state: 插件状态

        Returns:
            指定状态的插件列表
        """
        return [
            metadata for metadata in self._plugins.values()
            if metadata.state == state
        ]

    def get_service_status(self) -> Dict[str, Any]:
        """获取服务状态"""
        with self._lock:
            total_plugins = len(self._plugins)
            state_counts = {}

            for state in PluginState:
                state_counts[state.value] = len(self.get_plugins_by_state(state))

            type_counts = {}
            for plugin_type in PluginType:
                type_counts[plugin_type.value] = len(self.get_plugins_by_type(plugin_type))

            return {
                'total_plugins': total_plugins,
                'state_distribution': state_counts,
                'type_distribution': type_counts,
                'auto_discovery_enabled': self._auto_discovery_enabled,
                'discovery_interval': self._discovery_interval,
                'plugin_directory': str(self._plugin_dir),
                'lifecycle_events_count': len(self._lifecycle_events),
                'initialized': self._initialized
            }

    def add_lifecycle_callback(self, stage: PluginLifecycleStage, callback: Callable) -> None:
        """
        添加生命周期回调

        Args:
            stage: 生命周期阶段
            callback: 回调函数
        """
        if stage not in self._lifecycle_callbacks:
            self._lifecycle_callbacks[stage] = []

        self._lifecycle_callbacks[stage].append(callback)
        logger.info(f"Added lifecycle callback for stage: {stage.value}")

    def remove_lifecycle_callback(self, stage: PluginLifecycleStage, callback: Callable) -> None:
        """
        移除生命周期回调

        Args:
            stage: 生命周期阶段
            callback: 回调函数
        """
        if stage in self._lifecycle_callbacks:
            try:
                self._lifecycle_callbacks[stage].remove(callback)
                logger.info(f"Removed lifecycle callback for stage: {stage.value}")
            except ValueError:
                logger.warning(f"Callback not found for stage: {stage.value}")

    def perform_full_lifecycle(self, plugin_id: str) -> bool:
        """
        执行完整的插件生命周期

        Args:
            plugin_id: 插件ID

        Returns:
            是否成功完成整个生命周期
        """
        try:
            logger.info(f"Starting full lifecycle for plugin: {plugin_id}")

            # 发现（如果需要）
            if plugin_id not in self._plugins:
                self._discover_plugins()
                if plugin_id not in self._plugins:
                    logger.error(f"Plugin {plugin_id} not found after discovery")
                    return False

            # 验证
            if not self.validate_plugin(plugin_id):
                return False

            # 初始化
            if not self.initialize_plugin(plugin_id):
                return False

            # 激活
            if not self.activate_plugin(plugin_id):
                return False

            logger.info(f"Full lifecycle completed successfully for plugin: {plugin_id}")
            return True

        except Exception as e:
            logger.error(f"Full lifecycle failed for plugin {plugin_id}: {e}")
            return False

    def dispose(self) -> None:
        """释放服务资源"""
        logger.info("Disposing unified plugin service...")

        # 停用所有激活的插件
        activated_plugins = self.get_plugins_by_state(PluginState.ACTIVATED)
        for metadata in activated_plugins:
            try:
                self.deactivate_plugin(metadata.plugin_id)
            except Exception as e:
                logger.error(f"Error deactivating plugin {metadata.plugin_id}: {e}")

        # 停止自动发现
        self._auto_discovery_enabled = False

        # 关闭线程池
        if hasattr(self, '_discovery_executor'):
            self._discovery_executor.shutdown(wait=True)
        if hasattr(self, '_initialization_executor'):
            self._initialization_executor.shutdown(wait=True)

        super().dispose()
        logger.info("Unified plugin service disposed")


# 全局实例管理
_unified_plugin_service: Optional[UnifiedPluginService] = None
_service_lock = threading.Lock()


def get_unified_plugin_service() -> UnifiedPluginService:
    """获取全局统一插件服务实例"""
    global _unified_plugin_service
    if _unified_plugin_service is None:
        with _service_lock:
            if _unified_plugin_service is None:
                _unified_plugin_service = UnifiedPluginService()
    return _unified_plugin_service


def set_unified_plugin_service(service: UnifiedPluginService) -> None:
    """设置全局统一插件服务实例"""
    global _unified_plugin_service
    with _service_lock:
        _unified_plugin_service = service
