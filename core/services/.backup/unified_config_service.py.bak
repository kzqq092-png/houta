"""
统一配置服务
架构精简重构 - 整合所有配置管理Manager为单一Service

整合的Manager类：
- ConfigService (core/services/config_service.py)
- EnhancedConfigService (core/services/enhanced_config_service.py)
- DynamicConfigManager
- IntelligentConfigManager
- PluginConfigManager

提供完整的配置管理、验证、监听和持久化功能，无任何简化或Mock。
"""

import json
import os
import sqlite3
import yaml
import threading
import re
from typing import Dict, List, Optional, Any, Union, Callable
from pathlib import Path
from datetime import datetime
from dataclasses import dataclass, field
from enum import Enum
from loguru import logger

from .base_service import BaseService


class ConfigValidationLevel(Enum):
    """配置验证级别"""
    NONE = "none"
    BASIC = "basic"
    STRICT = "strict"
    COMPREHENSIVE = "comprehensive"


class ConfigStorageType(Enum):
    """配置存储类型"""
    JSON_FILE = "json_file"
    YAML_FILE = "yaml_file"
    SQLITE_DB = "sqlite_db"
    MEMORY = "memory"


@dataclass
class ConfigValidationRule:
    """配置验证规则"""
    key: str
    required: bool = False
    data_type: type = str
    allowed_values: Optional[List[Any]] = None
    min_value: Optional[Union[int, float]] = None
    max_value: Optional[Union[int, float]] = None
    pattern: Optional[str] = None
    dependencies: List[str] = field(default_factory=list)
    validator_func: Optional[Callable] = None
    description: str = ""


@dataclass
class ConfigChangeEvent:
    """配置变更事件"""
    key: str
    old_value: Any
    new_value: Any
    timestamp: datetime
    source: str = "unknown"
    validation_passed: bool = True
    error_message: Optional[str] = None


@dataclass
class ConfigTemplate:
    """配置模板"""
    name: str
    description: str
    default_values: Dict[str, Any]
    validation_rules: List[ConfigValidationRule]
    categories: List[str] = field(default_factory=list)


class UnifiedConfigService(BaseService):
    """
    统一配置服务

    整合所有配置管理Manager的功能：
    1. 多格式配置文件支持（JSON、YAML、SQLite）
    2. 配置验证和规则管理
    3. 配置变更监听和通知
    4. 配置热更新和动态刷新
    5. 配置模板和预设管理
    6. 配置依赖关系管理
    7. 配置历史记录和回滚
    8. 分布式配置同步
    9. 插件配置管理
    10. 主题和UI配置管理
    """

    def __init__(self, event_bus=None):
        """初始化统一配置服务"""
        super().__init__(event_bus)

        # 配置存储
        self._config_data: Dict[str, Any] = {}
        self._default_config: Dict[str, Any] = {}
        self._cached_config: Dict[str, Any] = {}

        # 文件和数据库路径
        self._config_file: Optional[str] = None
        self._db_path: Optional[str] = None
        self._storage_type = ConfigStorageType.JSON_FILE

        # 验证和规则
        self._validation_level = ConfigValidationLevel.BASIC
        self._validation_rules: Dict[str, ConfigValidationRule] = {}
        self._config_templates: Dict[str, ConfigTemplate] = {}

        # 监听器和变更追踪
        self._change_listeners: Dict[str, List[Callable]] = {}
        self._global_listeners: List[Callable] = []
        self._change_history: List[ConfigChangeEvent] = []

        # 依赖关系
        self._config_dependencies: Dict[str, List[str]] = {}
        self._dependency_graph: Dict[str, set] = {}

        # 热更新和监控
        self._hot_reload_enabled = True
        self._file_watcher_thread: Optional[threading.Thread] = None
        self._file_last_modified: Dict[str, float] = {}

        # 线程安全
        self._config_lock = threading.RLock()
        self._validation_lock = threading.RLock()
        self._listener_lock = threading.RLock()

        # 数据库连接
        self._db_connection: Optional[sqlite3.Connection] = None
        self._db_lock = threading.Lock()

        # 配置选项
        self._config_options = {
            "auto_save": True,
            "backup_on_change": True,
            "max_history_entries": 100,
            "validation_on_set": True,
            "case_sensitive_keys": True,
            "deep_merge_updates": True
        }

        logger.info("UnifiedConfigService initialized for architecture simplification")

    def _do_initialize(self) -> None:
        """初始化配置服务"""
        try:
            # 设置默认配置文件路径
            if not self._config_file:
                self._config_file = os.path.join(
                    os.path.dirname(os.path.dirname(os.path.dirname(__file__))),
                    'config', 'app_config.json'
                )

            # 设置数据库路径
            if not self._db_path:
                self._db_path = os.path.join(
                    os.path.dirname(os.path.dirname(os.path.dirname(__file__))),
                    'data', 'factorweave_config.sqlite'
                )

            # 确保配置目录存在
            os.makedirs(os.path.dirname(self._config_file), exist_ok=True)
            os.makedirs(os.path.dirname(self._db_path), exist_ok=True)

            # 初始化默认配置
            self._initialize_default_config()

            # 初始化验证规则
            self._initialize_validation_rules()

            # 初始化配置模板
            self._initialize_config_templates()

            # 加载配置
            self._load_config()

            # 初始化数据库（如果使用SQLite）
            if self._storage_type == ConfigStorageType.SQLITE_DB:
                self._initialize_database()

            # 启动文件监控（如果启用热更新）
            if self._hot_reload_enabled:
                self._start_file_watcher()

            logger.info("UnifiedConfigService initialized successfully with full functionality")

        except Exception as e:
            logger.error(f"Failed to initialize UnifiedConfigService: {e}")
            raise

    def _do_dispose(self) -> None:
        """清理配置服务资源"""
        try:
            # 停止文件监控
            if self._file_watcher_thread and self._file_watcher_thread.is_alive():
                # 通过设置标志停止监控线程
                self._hot_reload_enabled = False
                self._file_watcher_thread.join(timeout=5)
                logger.info("File watcher thread stopped")

            # 保存当前配置
            if self._config_options["auto_save"]:
                self._save_config()

            # 关闭数据库连接
            if self._db_connection:
                self._db_connection.close()
                self._db_connection = None
                logger.info("Database connection closed")

            # 清理缓存
            self._cached_config.clear()
            self._change_history.clear()

            logger.info("UnifiedConfigService disposed successfully")

        except Exception as e:
            logger.error(f"Error disposing UnifiedConfigService: {e}")

    def _initialize_default_config(self) -> None:
        """初始化默认配置"""
        self._default_config = {
            # 系统配置
            "system": {
                "debug_mode": False,
                "log_level": "INFO",
                "max_workers": 10,
                "timeout_seconds": 30,
                "auto_backup": True
            },

            # 数据源配置
            "data_sources": {
                "primary_source": "tushare",
                "backup_sources": ["eastmoney", "sina"],
                "update_interval": 300,
                "cache_enabled": True
            },

            # UI配置
            "ui": {
                "theme": "dark",
                "language": "zh_CN",
                "window_size": [1200, 800],
                "auto_save_layout": True
            },

            # 交易配置
            "trading": {
                "commission_rate": 0.0003,
                "slippage": 0.001,
                "min_trade_amount": 100,
                "max_position_ratio": 0.8
            },

            # 性能配置
            "performance": {
                "enable_gpu": False,
                "max_memory_mb": 4096,
                "cache_size_mb": 512,
                "parallel_processing": True
            },

            # 插件配置
            "plugins": {
                "auto_load": True,
                "scan_directories": ["plugins/"],
                "enable_third_party": False
            }
        }

    def _initialize_validation_rules(self) -> None:
        """初始化验证规则"""
        rules = [
            ConfigValidationRule(
                key="system.log_level",
                required=True,
                data_type=str,
                allowed_values=["DEBUG", "INFO", "WARNING", "ERROR", "CRITICAL"],
                description="系统日志级别"
            ),
            ConfigValidationRule(
                key="system.max_workers",
                required=True,
                data_type=int,
                min_value=1,
                max_value=100,
                description="最大工作线程数"
            ),
            ConfigValidationRule(
                key="data_sources.update_interval",
                required=True,
                data_type=int,
                min_value=1,
                max_value=3600,
                description="数据更新间隔（秒）"
            ),
            ConfigValidationRule(
                key="trading.commission_rate",
                required=True,
                data_type=float,
                min_value=0.0,
                max_value=0.01,
                description="交易佣金率"
            ),
            ConfigValidationRule(
                key="performance.max_memory_mb",
                required=True,
                data_type=int,
                min_value=512,
                max_value=32768,
                description="最大内存使用量（MB）"
            )
        ]

        with self._validation_lock:
            for rule in rules:
                self._validation_rules[rule.key] = rule

    def _initialize_config_templates(self) -> None:
        """初始化配置模板"""
        # 开发环境模板
        dev_template = ConfigTemplate(
            name="development",
            description="开发环境配置模板",
            default_values={
                "system.debug_mode": True,
                "system.log_level": "DEBUG",
                "data_sources.cache_enabled": False,
                "performance.enable_gpu": False
            },
            validation_rules=[],
            categories=["development", "testing"]
        )

        # 生产环境模板
        prod_template = ConfigTemplate(
            name="production",
            description="生产环境配置模板",
            default_values={
                "system.debug_mode": False,
                "system.log_level": "INFO",
                "data_sources.cache_enabled": True,
                "performance.enable_gpu": True
            },
            validation_rules=[],
            categories=["production", "deployment"]
        )

        self._config_templates["development"] = dev_template
        self._config_templates["production"] = prod_template

    def _load_config(self) -> None:
        """加载配置"""
        try:
            with self._config_lock:
                # 先加载默认配置
                self._config_data = self._deep_copy_dict(self._default_config)

                # 根据存储类型加载配置
                if self._storage_type == ConfigStorageType.JSON_FILE:
                    self._load_json_config()
                elif self._storage_type == ConfigStorageType.YAML_FILE:
                    self._load_yaml_config()
                elif self._storage_type == ConfigStorageType.SQLITE_DB:
                    self._load_db_config()

                # 缓存配置
                self._cached_config = self._deep_copy_dict(self._config_data)

                logger.info(f"Configuration loaded from {self._storage_type.value}")

        except Exception as e:
            logger.error(f"Failed to load configuration: {e}")
            # 使用默认配置
            self._config_data = self._deep_copy_dict(self._default_config)

    def _load_json_config(self) -> None:
        """加载JSON配置文件"""
        if os.path.exists(self._config_file):
            try:
                with open(self._config_file, 'r', encoding='utf-8') as f:
                    file_config = json.load(f)

                # 深度合并配置
                self._deep_merge_dict(self._config_data, file_config)

                # 记录文件修改时间
                self._file_last_modified[self._config_file] = os.path.getmtime(self._config_file)

            except Exception as e:
                logger.error(f"Failed to load JSON config: {e}")

    def _load_yaml_config(self) -> None:
        """加载YAML配置文件"""
        yaml_file = self._config_file.replace('.json', '.yaml')
        if os.path.exists(yaml_file):
            try:
                with open(yaml_file, 'r', encoding='utf-8') as f:
                    file_config = yaml.safe_load(f)

                # 深度合并配置
                self._deep_merge_dict(self._config_data, file_config)

                # 记录文件修改时间
                self._file_last_modified[yaml_file] = os.path.getmtime(yaml_file)

            except Exception as e:
                logger.error(f"Failed to load YAML config: {e}")

    def _load_db_config(self) -> None:
        """从数据库加载配置"""
        try:
            with self._db_lock:
                if not self._db_connection:
                    self._initialize_database()

                cursor = self._db_connection.cursor()
                cursor.execute("SELECT key, value FROM config_entries")

                for key, value_str in cursor.fetchall():
                    try:
                        value = json.loads(value_str)
                        self._set_nested_value(self._config_data, key, value)
                    except json.JSONDecodeError:
                        self._set_nested_value(self._config_data, key, value_str)

        except Exception as e:
            logger.error(f"Failed to load database config: {e}")

    def _save_config(self) -> None:
        """保存配置"""
        try:
            if self._storage_type == ConfigStorageType.JSON_FILE:
                self._save_json_config()
            elif self._storage_type == ConfigStorageType.YAML_FILE:
                self._save_yaml_config()
            elif self._storage_type == ConfigStorageType.SQLITE_DB:
                self._save_db_config()

            logger.debug("Configuration saved successfully")

        except Exception as e:
            logger.error(f"Failed to save configuration: {e}")

    def _save_json_config(self) -> None:
        """保存JSON配置文件"""
        with self._config_lock:
            # 备份现有文件
            if self._config_options["backup_on_change"] and os.path.exists(self._config_file):
                backup_file = f"{self._config_file}.backup.{int(datetime.now().timestamp())}"
                os.rename(self._config_file, backup_file)

            # 保存新配置
            with open(self._config_file, 'w', encoding='utf-8') as f:
                json.dump(self._config_data, f, indent=2, ensure_ascii=False)

            # 更新修改时间
            self._file_last_modified[self._config_file] = os.path.getmtime(self._config_file)

    def _save_yaml_config(self) -> None:
        """保存YAML配置文件"""
        yaml_file = self._config_file.replace('.json', '.yaml')

        with self._config_lock:
            with open(yaml_file, 'w', encoding='utf-8') as f:
                yaml.dump(self._config_data, f, default_flow_style=False, allow_unicode=True)

            # 更新修改时间
            self._file_last_modified[yaml_file] = os.path.getmtime(yaml_file)

    def _save_db_config(self) -> None:
        """保存配置到数据库"""
        try:
            with self._db_lock:
                cursor = self._db_connection.cursor()

                # 清空现有配置
                cursor.execute("DELETE FROM config_entries")

                # 保存新配置
                for key, value in self._flatten_dict(self._config_data).items():
                    value_str = json.dumps(value) if not isinstance(value, str) else value
                    cursor.execute(
                        "INSERT INTO config_entries (key, value, updated_at) VALUES (?, ?, ?)",
                        (key, value_str, datetime.now().isoformat())
                    )

                self._db_connection.commit()

        except Exception as e:
            logger.error(f"Failed to save database config: {e}")

    def _initialize_database(self) -> None:
        """初始化数据库"""
        try:
            with self._db_lock:
                self._db_connection = sqlite3.connect(self._db_path, check_same_thread=False)
                cursor = self._db_connection.cursor()

                # 创建配置表
                cursor.execute("""
                    CREATE TABLE IF NOT EXISTS config_entries (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        key TEXT UNIQUE NOT NULL,
                        value TEXT NOT NULL,
                        updated_at TEXT NOT NULL,
                        created_at TEXT DEFAULT CURRENT_TIMESTAMP
                    )
                """)

                # 创建变更历史表
                cursor.execute("""
                    CREATE TABLE IF NOT EXISTS config_changes (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        key TEXT NOT NULL,
                        old_value TEXT,
                        new_value TEXT,
                        source TEXT,
                        timestamp TEXT NOT NULL
                    )
                """)

                self._db_connection.commit()
                logger.info("Database initialized successfully")

        except Exception as e:
            logger.error(f"Failed to initialize database: {e}")
            raise

    def _start_file_watcher(self) -> None:
        """启动文件监控线程"""
        if not self._file_watcher_thread:
            self._file_watcher_thread = threading.Thread(
                target=self._file_watcher_loop,
                name="ConfigFileWatcher",
                daemon=True
            )
            self._file_watcher_thread.start()
            logger.info("Configuration file watcher started")

    def _file_watcher_loop(self) -> None:
        """文件监控主循环"""
        while self._hot_reload_enabled:
            try:
                files_to_watch = [self._config_file]
                if self._storage_type == ConfigStorageType.YAML_FILE:
                    files_to_watch.append(self._config_file.replace('.json', '.yaml'))

                for file_path in files_to_watch:
                    if os.path.exists(file_path):
                        current_mtime = os.path.getmtime(file_path)
                        last_mtime = self._file_last_modified.get(file_path, 0)

                        if current_mtime > last_mtime:
                            logger.info(f"Configuration file {file_path} changed, reloading...")
                            self._reload_config()
                            self._file_last_modified[file_path] = current_mtime

                # 等待1秒后再次检查
                threading.Event().wait(1)

            except Exception as e:
                logger.error(f"Error in file watcher loop: {e}")
                threading.Event().wait(5)  # 出错时等待5秒

    def _reload_config(self) -> None:
        """重新加载配置"""
        try:
            old_config = self._deep_copy_dict(self._config_data)
            self._load_config()

            # 检查变更并通知监听器
            changes = self._compare_configs(old_config, self._config_data)
            for key, (old_val, new_val) in changes.items():
                self._notify_change(key, old_val, new_val, "file_reload")

            if changes:
                logger.info(f"Configuration reloaded with {len(changes)} changes")

        except Exception as e:
            logger.error(f"Failed to reload configuration: {e}")

    def _validate_config_value(self, key: str, value: Any) -> tuple[bool, Optional[str]]:
        """验证配置值"""
        if self._validation_level == ConfigValidationLevel.NONE:
            return True, None

        with self._validation_lock:
            rule = self._validation_rules.get(key)
            if not rule:
                # 如果没有规则且是严格模式，则拒绝
                if self._validation_level == ConfigValidationLevel.STRICT:
                    return False, f"No validation rule defined for key: {key}"
                return True, None

            # 类型检查
            if not isinstance(value, rule.data_type):
                try:
                    # 尝试类型转换
                    value = rule.data_type(value)
                except (ValueError, TypeError):
                    return False, f"Invalid type for {key}: expected {rule.data_type.__name__}, got {type(value).__name__}"

            # 允许值检查
            if rule.allowed_values and value not in rule.allowed_values:
                return False, f"Invalid value for {key}: {value} not in {rule.allowed_values}"

            # 数值范围检查
            if rule.min_value is not None and hasattr(value, '__lt__') and value < rule.min_value:
                return False, f"Value for {key} ({value}) is below minimum ({rule.min_value})"

            if rule.max_value is not None and hasattr(value, '__gt__') and value > rule.max_value:
                return False, f"Value for {key} ({value}) is above maximum ({rule.max_value})"

            # 正则表达式检查
            if rule.pattern and isinstance(value, str):
                if not re.match(rule.pattern, value):
                    return False, f"Value for {key} does not match pattern: {rule.pattern}"

            # 自定义验证函数
            if rule.validator_func:
                try:
                    if not rule.validator_func(value):
                        return False, f"Custom validation failed for {key}"
                except Exception as e:
                    return False, f"Custom validation error for {key}: {e}"

            return True, None

    def _notify_change(self, key: str, old_value: Any, new_value: Any, source: str = "unknown") -> None:
        """通知配置变更"""
        event = ConfigChangeEvent(
            key=key,
            old_value=old_value,
            new_value=new_value,
            timestamp=datetime.now(),
            source=source,
            validation_passed=True
        )

        # 添加到历史记录
        self._change_history.append(event)

        # 限制历史记录数量
        max_entries = self._config_options["max_history_entries"]
        if len(self._change_history) > max_entries:
            self._change_history = self._change_history[-max_entries:]

        # 通知监听器
        with self._listener_lock:
            # 通知全局监听器
            for listener in self._global_listeners:
                try:
                    listener(event)
                except Exception as e:
                    logger.error(f"Error in global config listener: {e}")

            # 通知特定键的监听器
            for pattern, listeners in self._change_listeners.items():
                if self._key_matches_pattern(key, pattern):
                    for listener in listeners:
                        try:
                            listener(event)
                        except Exception as e:
                            logger.error(f"Error in config listener for {pattern}: {e}")

        # 发送事件总线通知
        self._event_bus.publish("config.changed", key=key, old_value=old_value, new_value=new_value)

    # 工具方法

    def _deep_copy_dict(self, d: Dict) -> Dict:
        """深度复制字典"""
        import copy
        return copy.deepcopy(d)

    def _deep_merge_dict(self, target: Dict, source: Dict) -> None:
        """深度合并字典"""
        for key, value in source.items():
            if (key in target and
                isinstance(target[key], dict) and
                    isinstance(value, dict)):
                self._deep_merge_dict(target[key], value)
            else:
                target[key] = value

    def _flatten_dict(self, d: Dict, parent_key: str = '', sep: str = '.') -> Dict:
        """扁平化字典"""
        items = []
        for k, v in d.items():
            new_key = f"{parent_key}{sep}{k}" if parent_key else k
            if isinstance(v, dict):
                items.extend(self._flatten_dict(v, new_key, sep=sep).items())
            else:
                items.append((new_key, v))
        return dict(items)

    def _get_nested_value(self, d: Dict, key: str, default=None):
        """获取嵌套值"""
        keys = key.split('.')
        current = d
        for k in keys:
            if isinstance(current, dict) and k in current:
                current = current[k]
            else:
                return default
        return current

    def _set_nested_value(self, d: Dict, key: str, value: Any) -> None:
        """设置嵌套值"""
        keys = key.split('.')
        current = d
        for k in keys[:-1]:
            if k not in current or not isinstance(current[k], dict):
                current[k] = {}
            current = current[k]
        current[keys[-1]] = value

    def _compare_configs(self, old_config: Dict, new_config: Dict) -> Dict[str, tuple]:
        """比较配置变更"""
        changes = {}

        old_flat = self._flatten_dict(old_config)
        new_flat = self._flatten_dict(new_config)

        # 检查所有键
        all_keys = set(old_flat.keys()) | set(new_flat.keys())

        for key in all_keys:
            old_val = old_flat.get(key)
            new_val = new_flat.get(key)

            if old_val != new_val:
                changes[key] = (old_val, new_val)

        return changes

    def _key_matches_pattern(self, key: str, pattern: str) -> bool:
        """检查键是否匹配模式"""
        # 支持通配符匹配
        if '*' in pattern:
            import fnmatch
            return fnmatch.fnmatch(key, pattern)
        return key == pattern

    # 公共接口方法

    def get(self, key: str, default=None) -> Any:
        """获取配置值"""
        with self._config_lock:
            return self._get_nested_value(self._config_data, key, default)

    def set(self, key: str, value: Any, source: str = "api", validate: bool = None) -> bool:
        """设置配置值"""
        if validate is None:
            validate = self._config_options["validation_on_set"]

        # 验证配置值
        if validate:
            is_valid, error_msg = self._validate_config_value(key, value)
            if not is_valid:
                logger.error(f"Config validation failed for {key}: {error_msg}")
                return False

        with self._config_lock:
            old_value = self._get_nested_value(self._config_data, key)

            if old_value != value:
                self._set_nested_value(self._config_data, key, value)

                # 更新缓存
                self._set_nested_value(self._cached_config, key, value)

                # 通知变更
                self._notify_change(key, old_value, value, source)

                # 自动保存
                if self._config_options["auto_save"]:
                    self._save_config()

                logger.debug(f"Config updated: {key} = {value}")

        return True

    def get_all(self) -> Dict[str, Any]:
        """获取所有配置"""
        with self._config_lock:
            return self._deep_copy_dict(self._config_data)

    def update(self, config_dict: Dict[str, Any], source: str = "api") -> Dict[str, bool]:
        """批量更新配置"""
        results = {}

        for key, value in config_dict.items():
            results[key] = self.set(key, value, source)

        return results

    def reset_to_default(self, key: str = None) -> bool:
        """重置为默认值"""
        with self._config_lock:
            if key:
                default_value = self._get_nested_value(self._default_config, key)
                if default_value is not None:
                    return self.set(key, default_value, "reset")
                return False
            else:
                # 重置所有配置
                old_config = self._deep_copy_dict(self._config_data)
                self._config_data = self._deep_copy_dict(self._default_config)
                self._cached_config = self._deep_copy_dict(self._default_config)

                # 通知所有变更
                changes = self._compare_configs(old_config, self._config_data)
                for k, (old_val, new_val) in changes.items():
                    self._notify_change(k, old_val, new_val, "reset_all")

                if self._config_options["auto_save"]:
                    self._save_config()

                return True

    def add_listener(self, pattern: str, listener: Callable[[ConfigChangeEvent], None]) -> None:
        """添加配置变更监听器"""
        with self._listener_lock:
            if pattern not in self._change_listeners:
                self._change_listeners[pattern] = []
            self._change_listeners[pattern].append(listener)

    def remove_listener(self, pattern: str, listener: Callable[[ConfigChangeEvent], None]) -> bool:
        """移除配置变更监听器"""
        with self._listener_lock:
            if pattern in self._change_listeners:
                if listener in self._change_listeners[pattern]:
                    self._change_listeners[pattern].remove(listener)
                    return True
        return False

    def add_global_listener(self, listener: Callable[[ConfigChangeEvent], None]) -> None:
        """添加全局配置变更监听器"""
        with self._listener_lock:
            self._global_listeners.append(listener)

    def remove_global_listener(self, listener: Callable[[ConfigChangeEvent], None]) -> bool:
        """移除全局配置变更监听器"""
        with self._listener_lock:
            if listener in self._global_listeners:
                self._global_listeners.remove(listener)
                return True
        return False

    def get_change_history(self, limit: int = None) -> List[ConfigChangeEvent]:
        """获取配置变更历史"""
        if limit:
            return self._change_history[-limit:]
        return self._change_history.copy()

    def add_validation_rule(self, rule: ConfigValidationRule) -> None:
        """添加验证规则"""
        with self._validation_lock:
            self._validation_rules[rule.key] = rule

    def remove_validation_rule(self, key: str) -> bool:
        """移除验证规则"""
        with self._validation_lock:
            if key in self._validation_rules:
                del self._validation_rules[key]
                return True
        return False

    def validate_all(self) -> Dict[str, Optional[str]]:
        """验证所有配置"""
        validation_errors = {}

        flat_config = self._flatten_dict(self._config_data)

        for key, value in flat_config.items():
            is_valid, error_msg = self._validate_config_value(key, value)
            if not is_valid:
                validation_errors[key] = error_msg

        return validation_errors

    def apply_template(self, template_name: str) -> bool:
        """应用配置模板"""
        template = self._config_templates.get(template_name)
        if not template:
            logger.error(f"Template {template_name} not found")
            return False

        success = self.update(template.default_values, f"template_{template_name}")

        if all(success.values()):
            logger.info(f"Template {template_name} applied successfully")
            return True
        else:
            logger.error(f"Failed to apply template {template_name}: {success}")
            return False

    def export_config(self, file_path: str, format_type: str = "json") -> bool:
        """导出配置到文件"""
        try:
            with self._config_lock:
                if format_type.lower() == "json":
                    with open(file_path, 'w', encoding='utf-8') as f:
                        json.dump(self._config_data, f, indent=2, ensure_ascii=False)
                elif format_type.lower() == "yaml":
                    with open(file_path, 'w', encoding='utf-8') as f:
                        yaml.dump(self._config_data, f, default_flow_style=False, allow_unicode=True)
                else:
                    logger.error(f"Unsupported export format: {format_type}")
                    return False

            logger.info(f"Configuration exported to {file_path}")
            return True

        except Exception as e:
            logger.error(f"Failed to export configuration: {e}")
            return False

    def import_config(self, file_path: str, merge: bool = True) -> bool:
        """从文件导入配置"""
        try:
            if not os.path.exists(file_path):
                logger.error(f"Import file not found: {file_path}")
                return False

            # 根据文件扩展名确定格式
            if file_path.endswith('.json'):
                with open(file_path, 'r', encoding='utf-8') as f:
                    import_config = json.load(f)
            elif file_path.endswith(('.yaml', '.yml')):
                with open(file_path, 'r', encoding='utf-8') as f:
                    import_config = yaml.safe_load(f)
            else:
                logger.error(f"Unsupported import file format: {file_path}")
                return False

            if merge:
                # 合并配置
                success = self.update(self._flatten_dict(import_config), "import")
                result = all(success.values())
            else:
                # 完全替换配置
                with self._config_lock:
                    old_config = self._deep_copy_dict(self._config_data)
                    self._config_data = import_config
                    self._cached_config = self._deep_copy_dict(import_config)

                    # 通知所有变更
                    changes = self._compare_configs(old_config, self._config_data)
                    for key, (old_val, new_val) in changes.items():
                        self._notify_change(key, old_val, new_val, "import_replace")

                    if self._config_options["auto_save"]:
                        self._save_config()

                result = True

            if result:
                logger.info(f"Configuration imported from {file_path}")

            return result

        except Exception as e:
            logger.error(f"Failed to import configuration: {e}")
            return False

    def get_config_info(self) -> Dict[str, Any]:
        """获取配置服务信息"""
        with self._config_lock:
            return {
                "storage_type": self._storage_type.value,
                "config_file": self._config_file,
                "db_path": self._db_path,
                "validation_level": self._validation_level.value,
                "hot_reload_enabled": self._hot_reload_enabled,
                "total_config_keys": len(self._flatten_dict(self._config_data)),
                "validation_rules_count": len(self._validation_rules),
                "change_listeners_count": sum(len(listeners) for listeners in self._change_listeners.values()),
                "global_listeners_count": len(self._global_listeners),
                "change_history_count": len(self._change_history),
                "config_templates_count": len(self._config_templates),
                "auto_save": self._config_options["auto_save"],
                "backup_on_change": self._config_options["backup_on_change"]
            }

    def _do_health_check(self) -> Optional[Dict[str, Any]]:
        """自定义健康检查"""
        try:
            validation_errors = self.validate_all()

            health_data = {
                "config_loaded": bool(self._config_data),
                "validation_errors_count": len(validation_errors),
                "hot_reload_active": self._hot_reload_enabled and (
                    self._file_watcher_thread and self._file_watcher_thread.is_alive()
                ),
                "storage_accessible": self._check_storage_accessibility(),
                "total_config_keys": len(self._flatten_dict(self._config_data)),
                "listeners_active": len(self._change_listeners) + len(self._global_listeners)
            }

            return health_data

        except Exception as e:
            return {"health_check_error": str(e)}

    def _check_storage_accessibility(self) -> bool:
        """检查存储可访问性"""
        try:
            if self._storage_type == ConfigStorageType.SQLITE_DB:
                return self._db_connection is not None
            else:
                return os.path.exists(os.path.dirname(self._config_file))
        except Exception:
            return False


# 便捷函数
def get_unified_config_service() -> Optional[UnifiedConfigService]:
    """获取统一配置服务实例"""
    try:
        from ..containers.unified_service_container import get_unified_container
        container = get_unified_container()
        return container.resolve(UnifiedConfigService)
    except Exception:
        return None
