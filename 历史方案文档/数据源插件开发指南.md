# FactorWeave-Quant  数据源插件开发指南

## 概述

FactorWeave-Quant  系统支持通过插件化架构来扩展数据源，允许用户集成各种金融数据提供商的 API。本文档提供了创建、配置和使用数据源插件的完整指南。

## 系统架构

### 核心组件

1. **`IDataSourcePlugin`** - 数据源插件接口
2. **`DataSourcePluginAdapter`** - 插件适配器
3. **`DataSourceRouter`** - 智能路由器
4. **`UnifiedDataManager`** - 统一数据管理器
5. **`MultiLayerCache`** - 多层缓存系统

### 支持的资产类型

```python
from core.plugin_types import AssetType

# 支持的资产类型
SUPPORTED_ASSETS = [
    AssetType.STOCK_A,      # A股
    AssetType.FUTURES,      # 期货
    AssetType.CRYPTO,       # 数字货币
    AssetType.FOREX,        # 外汇
    AssetType.BOND,         # 债券
    AssetType.COMMODITY,    # 商品
    AssetType.INDEX,        # 指数
    AssetType.FUND,         # 基金
    AssetType.OPTION,       # 期权
    AssetType.WARRANT       # 权证
]
```

### 支持的数据类型

```python
from core.plugin_types import DataType

# 支持的数据类型
SUPPORTED_DATA_TYPES = [
    DataType.REAL_TIME_QUOTE,    # 实时行情
    DataType.HISTORICAL_KLINE,   # 历史K线
    DataType.MARKET_DEPTH,       # 市场深度
    DataType.TRADE_TICK,         # 逐笔交易
    DataType.FUNDAMENTAL,        # 基本面数据
    DataType.NEWS,               # 新闻资讯
    DataType.ANNOUNCEMENT        # 公告信息
]
```

## 插件开发步骤

### 1. 创建插件类

```python
from core.data_source_extensions import IDataSourcePlugin, PluginInfo, HealthCheckResult
from core.plugin_types import AssetType, DataType
from datetime import datetime
from typing import Dict, List, Optional, Any
import pandas as pd

class YourDataPlugin(IDataSourcePlugin):
    """您的数据源插件"""
    
    def __init__(self):
        self.initialized = False
        self.config = {}
        self.session = None
        self.request_count = 0
        self.last_error = None

    def get_plugin_info(self) -> PluginInfo:
        """获取插件信息"""
        return PluginInfo(
            id="your_data_plugin",
            name="您的数据源插件",
            version="1.0.0",
            description="提供您的数据源的数据获取功能",
            author="您的名字",
            supported_asset_types=[AssetType.STOCK_A],  # 支持的资产类型
            supported_data_types=[
                DataType.HISTORICAL_KLINE,
                DataType.REAL_TIME_QUOTE
            ]
        )

    def initialize(self, config: Dict[str, Any]) -> bool:
        """初始化插件"""
        try:
            self.config = config or {}
            
            # 从配置中获取API参数
            self.api_key = self.config.get("api_key", "")
            self.base_url = self.config.get("base_url", "")
            
            # 创建HTTP会话
            import requests
            self.session = requests.Session()
            self.session.headers.update({
                "User-Agent": "FactorWeave-Quant -YourPlugin/1.0.0",
                "Accept": "application/json"
            })
            
            if self.api_key:
                self.session.headers.update({
                    "Authorization": f"Bearer {self.api_key}"
                })
            
            self.initialized = True
            return True
            
        except Exception as e:
            self.last_error = str(e)
            return False

    def shutdown(self):
        """关闭插件"""
        if self.session:
            self.session.close()
        self.initialized = False

    def fetch_data(self, symbol: str, data_type: str, start_date=None, end_date=None, **kwargs) -> pd.DataFrame:
        """获取数据"""
        if not self.initialized:
            raise Exception("插件未初始化")
        
        self.request_count += 1
        
        try:
            if data_type == DataType.HISTORICAL_KLINE.value:
                return self._fetch_kline_data(symbol, start_date, end_date, **kwargs)
            elif data_type == DataType.REAL_TIME_QUOTE.value:
                return self._fetch_realtime_quote(symbol, **kwargs)
            else:
                raise ValueError(f"不支持的数据类型: {data_type}")
                
        except Exception as e:
            self.last_error = str(e)
            raise

    def health_check(self) -> HealthCheckResult:
        """健康检查"""
        # 实现健康检查逻辑
        pass

    def get_supported_asset_types(self):
        """获取支持的资产类型"""
        return [AssetType.STOCK_A]

    def get_supported_data_types(self):
        """获取支持的数据类型"""
        return [DataType.HISTORICAL_KLINE, DataType.REAL_TIME_QUOTE]
```

### 2. 实现数据获取方法

```python
def _fetch_kline_data(self, symbol: str, start_date=None, end_date=None, **kwargs) -> pd.DataFrame:
    """获取K线数据"""
    try:
        # 使用真实API获取数据
        if self.api_available:
            return self._fetch_real_kline_data(symbol, start_date, end_date, **kwargs)
        else:
            # Fallback到备用数据源
            return self._fetch_fallback_kline_data(symbol, start_date, end_date, **kwargs)
            
    except Exception as e:
        # 错误处理和日志记录
        logger.error(f"获取K线数据失败: {str(e)}")
        raise

def _fetch_real_kline_data(self, symbol: str, start_date, end_date, **kwargs) -> pd.DataFrame:
    """使用真实API获取K线数据"""
    try:
        # 构建API请求
        url = f"{self.base_url}/api/klines"
        params = {
            "symbol": symbol,
            "start_date": start_date.strftime("%Y-%m-%d"),
            "end_date": end_date.strftime("%Y-%m-%d"),
            "interval": kwargs.get("freq", "D")
        }
        
        response = self.session.get(url, params=params, timeout=10)
        response.raise_for_status()
        
        data = response.json()
        
        # 转换为标准DataFrame格式
        df_data = []
        for item in data:
            df_data.append({
                "datetime": pd.to_datetime(item["timestamp"]),
                "open": float(item["open"]),
                "high": float(item["high"]),
                "low": float(item["low"]),
                "close": float(item["close"]),
                "volume": float(item["volume"]),
                "amount": float(item["amount"])
            })
        
        df = pd.DataFrame(df_data)
        df.set_index("datetime", inplace=True)
        df.sort_index(inplace=True)
        
        return df
        
    except Exception as e:
        logger.error(f"真实API获取数据失败: {str(e)}")
        raise

def _fetch_fallback_kline_data(self, symbol: str, start_date, end_date, **kwargs) -> pd.DataFrame:
    """备用数据获取方法"""
    logger.info(f"使用备用方法获取数据: {symbol}")
    
    # 可以调用其他免费API或生成模拟数据
    return self._generate_mock_data(symbol, start_date, end_date, **kwargs)
```

### 3. 实现插件工厂函数

```python
# 插件工厂函数
def create_plugin() -> IDataSourcePlugin:
    """创建插件实例"""
    return YourDataPlugin()

# 插件元数据
PLUGIN_METADATA = {
    "name": "您的数据源插件",
    "version": "1.0.0",
    "description": "提供您的数据源的数据获取功能",
    "author": "您的名字",
    "plugin_type": "data_source",
    "asset_types": ["stock_a"],
    "data_types": ["historical_kline", "real_time_quote"],
    "config_schema": {
        "api_key": {
            "type": "string",
            "default": "",
            "description": "API密钥"
        },
        "base_url": {
            "type": "string",
            "default": "https://api.yourprovider.com",
            "description": "API基础地址"
        },
        "timeout": {
            "type": "integer",
            "default": 30,
            "description": "连接超时时间（秒）"
        }
    }
}
```

## 真实数据源集成示例

### 期货数据源（akshare集成）

```python
# 安装依赖
# pip install akshare

try:
    import akshare as ak
    AKSHARE_AVAILABLE = True
except ImportError:
    AKSHARE_AVAILABLE = False

def _fetch_futures_data(self, symbol: str, start_date, end_date, freq):
    """使用akshare获取期货数据"""
    if not AKSHARE_AVAILABLE:
        return self._fetch_fallback_data(symbol, start_date, end_date, freq)
    
    try:
        # 转换symbol为akshare格式
        ak_symbol = self._convert_to_akshare_symbol(symbol)
        
        # 获取期货数据
        data = ak.futures_main_sina(
            symbol=ak_symbol,
            start_date=start_date.strftime("%Y%m%d"),
            end_date=end_date.strftime("%Y%m%d")
        )
        
        if data is None or data.empty:
            return self._fetch_fallback_data(symbol, start_date, end_date, freq)
        
        # 标准化数据格式
        data = self._standardize_akshare_data(data)
        return data
        
    except Exception as e:
        logger.error(f"akshare获取期货数据失败: {str(e)}")
        return self._fetch_fallback_data(symbol, start_date, end_date, freq)
```

### 数字货币数据源（Binance集成）

```python
def _fetch_crypto_data(self, symbol: str, start_date, end_date, freq):
    """使用Binance API获取数字货币数据"""
    try:
        # Binance K线数据API
        url = "https://api.binance.com/api/v3/klines"
        params = {
            "symbol": symbol,
            "interval": self._convert_freq_to_binance(freq),
            "startTime": int(start_date.timestamp() * 1000),
            "endTime": int(end_date.timestamp() * 1000),
            "limit": 1000
        }
        
        response = self.session.get(url, params=params, timeout=10)
        response.raise_for_status()
        
        data = response.json()
        
        # 转换为DataFrame
        df_data = []
        for item in data:
            df_data.append({
                "datetime": pd.to_datetime(item[0], unit='ms'),
                "open": float(item[1]),
                "high": float(item[2]),
                "low": float(item[3]),
                "close": float(item[4]),
                "volume": float(item[5]),
                "amount": float(item[7])
            })
        
        df = pd.DataFrame(df_data)
        df.set_index("datetime", inplace=True)
        
        return df
        
    except Exception as e:
        logger.error(f"Binance API获取数据失败: {str(e)}")
        # 尝试CoinGecko作为备用
        return self._fetch_coingecko_fallback(symbol, start_date, end_date)
```

## 插件配置

### 配置文件示例

```json
{
    "your_data_plugin": {
        "enabled": true,
        "priority": 1,
        "config": {
            "api_key": "your_api_key_here",
            "base_url": "https://api.yourprovider.com",
            "timeout": 30,
            "retry_count": 3,
            "retry_delay": 1.0
        },
        "asset_types": ["stock_a", "futures"],
        "rate_limit": {
            "requests_per_minute": 100,
            "requests_per_hour": 1000
        }
    }
}
```

### 通过UI配置

1. 打开插件管理器：菜单 → 工具 → 插件管理
2. 切换到"数据源插件"标签页
3. 点击"加载"按钮加载插件
4. 选择插件后点击"配置"进行参数设置
5. 保存配置并启用插件

## 插件注册与使用

### 手动注册插件

```python
from core.data_manager import DataManager
from core.plugin_manager import PluginManager
from plugins.examples.your_data_plugin import create_plugin

# 获取管理器实例
data_manager = DataManager()
plugin_manager = PluginManager()

# 创建并注册插件
plugin = create_plugin()
plugin.initialize({"api_key": "your_key"})

data_manager.register_plugin_data_source("your_plugin", plugin)
plugin_manager.load_data_source_plugin("your_plugin", plugin)
```

### 设置数据源优先级

```python
from core.plugin_types import AssetType

# 设置期货数据源优先级
data_manager.set_data_source_priority(AssetType.FUTURES, [
    "your_futures_plugin",  # 第一优先级
    "akshare_plugin",       # 第二优先级  
    "default_source"        # 默认兜底
])
```

### 获取数据

```python
from core.plugin_types import DataType
from datetime import datetime, timedelta

# 获取历史K线数据
start_date = datetime.now() - timedelta(days=30)
end_date = datetime.now()

data = data_manager.get_data_with_fallback(
    symbol="RB2501",
    data_type=DataType.HISTORICAL_KLINE,
    start_date=start_date,
    end_date=end_date,
    freq="D"
)
```

## 错误处理和日志

### 日志记录

```python
from core.logger import get_logger

logger = get_logger(__name__)

def fetch_data(self, symbol: str, data_type: str, **kwargs):
    logger.info(f"开始获取数据: symbol={symbol}, data_type={data_type}")
    
    try:
        # 数据获取逻辑
        result = self._fetch_real_data(symbol, data_type, **kwargs)
        logger.info(f"数据获取成功: {len(result)} 条记录")
        return result
        
    except Exception as e:
        logger.error(f"数据获取失败: {str(e)}", exc_info=True)
        # 尝试fallback
        logger.info("尝试使用备用数据源")
        return self._fetch_fallback_data(symbol, data_type, **kwargs)
```

### 健康检查

```python
def health_check(self) -> HealthCheckResult:
    """健康检查"""
    try:
        start_time = time.time()
        
        if not self.initialized:
            return HealthCheckResult(
                is_healthy=False,
                response_time_ms=0,
                timestamp=datetime.now(),
                error_message="插件未初始化"
            )
        
        # 执行简单的数据获取测试
        test_symbol = "TEST001"
        try:
            self._fetch_realtime_quote(test_symbol)
            is_healthy = True
            error_message = None
        except Exception as e:
            is_healthy = False
            error_message = str(e)
        
        response_time = (time.time() - start_time) * 1000
        
        return HealthCheckResult(
            is_healthy=is_healthy,
            response_time_ms=response_time,
            timestamp=datetime.now(),
            error_message=error_message
        )
        
    except Exception as e:
        return HealthCheckResult(
            is_healthy=False,
            response_time_ms=0,
            timestamp=datetime.now(),
            error_message=f"健康检查失败: {str(e)}"
        )
```

## 性能优化

### 1. 连接池管理

```python
import requests
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry

def _create_session(self):
    """创建优化的HTTP会话"""
    session = requests.Session()
    
    # 配置重试策略
    retry_strategy = Retry(
        total=3,
        backoff_factor=1,
        status_forcelist=[429, 500, 502, 503, 504],
    )
    
    adapter = HTTPAdapter(
        max_retries=retry_strategy,
        pool_connections=10,
        pool_maxsize=20
    )
    
    session.mount("http://", adapter)
    session.mount("https://", adapter)
    
    return session
```

### 2. 数据缓存

```python
from functools import lru_cache
from datetime import datetime, timedelta

@lru_cache(maxsize=100)
def _get_cached_data(self, symbol: str, data_type: str, date_str: str):
    """缓存数据获取结果"""
    # 实现数据缓存逻辑
    pass

def _should_use_cache(self, symbol: str, data_type: str) -> bool:
    """判断是否应该使用缓存"""
    # 实时数据不缓存
    if data_type == DataType.REAL_TIME_QUOTE.value:
        return False
    
    # 历史数据可以缓存
    return True
```

### 3. 异步数据获取

```python
import asyncio
import aiohttp

async def _fetch_data_async(self, session, url: str, params: dict):
    """异步获取数据"""
    async with session.get(url, params=params) as response:
        response.raise_for_status()
        return await response.json()

async def fetch_multiple_symbols(self, symbols: list):
    """异步获取多个股票数据"""
    async with aiohttp.ClientSession() as session:
        tasks = []
        for symbol in symbols:
            url = f"{self.base_url}/api/quote"
            params = {"symbol": symbol}
            task = self._fetch_data_async(session, url, params)
            tasks.append(task)
        
        results = await asyncio.gather(*tasks, return_exceptions=True)
        return results
```

## 测试

### 单元测试示例

```python
import unittest
from datetime import datetime, timedelta
from your_plugin import YourDataPlugin

class TestYourDataPlugin(unittest.TestCase):
    
    def setUp(self):
        self.plugin = YourDataPlugin()
        self.plugin.initialize({"api_key": "test_key"})
    
    def test_plugin_info(self):
        """测试插件信息"""
        info = self.plugin.get_plugin_info()
        self.assertEqual(info.name, "您的数据源插件")
        self.assertEqual(info.version, "1.0.0")
    
    def test_initialization(self):
        """测试插件初始化"""
        result = self.plugin.initialize({"api_key": "test"})
        self.assertTrue(result)
        self.assertTrue(self.plugin.initialized)
    
    def test_health_check(self):
        """测试健康检查"""
        result = self.plugin.health_check()
        self.assertIsNotNone(result)
    
    def test_data_fetching(self):
        """测试数据获取"""
        start_date = datetime.now() - timedelta(days=7)
        end_date = datetime.now()
        
        data = self.plugin.fetch_data(
            symbol="TEST001",
            data_type="historical_kline",
            start_date=start_date,
            end_date=end_date
        )
        
        self.assertIsNotNone(data)
        self.assertFalse(data.empty)

if __name__ == "__main__":
    unittest.main()
```

### 集成测试

```python
def test_plugin_integration():
    """测试插件集成"""
    from core.data_manager import DataManager
    
    # 初始化数据管理器
    data_manager = DataManager()
    
    # 注册插件
    plugin = YourDataPlugin()
    plugin.initialize({"api_key": "test_key"})
    data_manager.register_plugin_data_source("test_plugin", plugin)
    
    # 测试数据获取
    data = data_manager.get_data_with_fallback(
        symbol="TEST001",
        data_type="real_time_quote"
    )
    
    assert data is not None
    assert not data.empty
    print("✅ 插件集成测试通过")
```

## 故障排除

### 常见问题

1. **插件初始化失败**
   - 检查API密钥是否正确
   - 验证网络连接
   - 查看日志输出

2. **数据获取超时**
   - 增加超时时间设置
   - 检查API限制
   - 使用备用数据源

3. **数据格式错误**
   - 验证API响应格式
   - 检查数据转换逻辑
   - 添加数据验证

### 调试技巧

```python
# 开启详细日志
import logging
logging.basicConfig(level=logging.DEBUG)

# 添加调试断点
import pdb
pdb.set_trace()

# 使用性能分析
import cProfile
cProfile.run('your_function()')
```

## 部署和发布

### 打包插件

```bash
# 创建插件包结构
your_plugin/
├── __init__.py
├── plugin.py
├── config.json
├── requirements.txt
└── README.md
```

### 安装依赖

```bash
pip install -r requirements.txt
```

### 插件分发

1. 将插件文件复制到 `plugins/` 目录
2. 重启FactorWeave-Quant 应用
3. 在插件管理器中加载插件

## 最佳实践

1. **始终实现fallback机制** - 确保在主数据源失败时有备用方案
2. **合理使用缓存** - 避免频繁请求相同数据
3. **错误处理** - 提供清晰的错误信息和日志
4. **性能监控** - 记录响应时间和成功率
5. **API限制遵守** - 遵循数据提供商的使用限制
6. **配置验证** - 在初始化时验证所有必需参数
7. **文档完善** - 提供清晰的使用说明和示例

## 联系与支持

如果您在开发插件过程中遇到问题，可以：

1. 查看现有插件示例：`plugins/examples/`
2. 检查系统日志：`logs/`
3. 参考单元测试：`tests/`
4. 提交Issue：GitHub Issues

---

*本文档将随着系统更新而持续维护，请定期查看最新版本。* 