# 数据源动态获取问题修复报告

## 🔍 问题分析

用户反馈的核心问题：
1. **数据源插件有对应的数据源**：系统中确实注册了数据源插件
2. **数据导入管理界面数据源配置显示为空**：数据源配置标签页没有显示已注册的数据源
3. **任务管理中数据源选择是写死的**：数据源下拉框使用硬编码列表，不是动态获取

## 🔍 根本原因

### 1. 数据源下拉框硬编码 ❌
```python
# 问题代码 (gui/widgets/data_import_widget.py:322)
self.data_source_combo.addItems(["HIkyuu", "Wind万得", "东方财富", "新浪财经", "同花顺"])
```

**问题**: 数据源列表是硬编码的，没有动态获取已注册的数据源插件。

### 2. 数据源配置表为空 ❌
```python
# 问题代码 (gui/widgets/data_import_widget.py:466-469)
self.sources_table = QTableWidget()
self.sources_table.setColumnCount(4)
self.sources_table.setHorizontalHeaderLabels(["名称", "类型", "状态", "操作"])
# 没有填充数据的逻辑
```

**问题**: 数据源配置表创建后没有填充已注册的数据源信息。

### 3. 缺少获取已注册数据源的接口 ❌
统一数据管理器虽然有注册数据源的功能，但缺少获取已注册数据源列表的接口。

## 🔧 修复方案

### 1. 统一数据管理器增强 ✅

#### 添加数据源信息存储
```python
# core/services/unified_data_manager.py
self._registered_data_sources = {}  # 存储已注册的数据源信息
```

#### 修改数据源注册方法
```python
def register_data_source_plugin(self, plugin_id: str, adapter, priority: int = 0, weight: float = 1.0) -> bool:
    # ... 原有注册逻辑 ...
    
    # 记录已注册的数据源信息
    plugin_info = {
        'plugin_id': plugin_id,
        'adapter': adapter,
        'priority': priority,
        'weight': weight,
        'display_name': getattr(adapter, 'display_name', plugin_id),
        'supported_assets': getattr(adapter, 'supported_assets', []),
        'status': 'active'
    }
    self._registered_data_sources[plugin_id] = plugin_info
    logger.info(f"✅ 数据源 {plugin_id} 信息已记录")
```

#### 添加获取数据源的接口
```python
def get_registered_data_sources(self) -> Dict[str, Dict[str, Any]]:
    """获取所有已注册的数据源"""
    return self._registered_data_sources.copy()

def get_available_data_source_names(self) -> List[str]:
    """获取可用数据源名称列表"""
    # 基础数据源
    base_sources = ['HIkyuu', '东方财富', '新浪财经', '同花顺']
    
    # 添加已注册的插件数据源
    plugin_sources = []
    for plugin_id, info in self._registered_data_sources.items():
        display_name = info.get('display_name', plugin_id)
        if display_name not in base_sources:
            plugin_sources.append(display_name)
    
    # 合并并去重
    all_sources = base_sources + plugin_sources
    return list(dict.fromkeys(all_sources))

def get_data_source_info(self, plugin_id: str) -> Optional[Dict[str, Any]]:
    """获取指定数据源的详细信息"""
    return self._registered_data_sources.get(plugin_id)
```

### 2. 数据导入组件动态获取数据源 ✅

#### 修改数据源下拉框初始化
```python
# 修复前
self.data_source_combo.addItems(["HIkyuu", "Wind万得", "东方财富", "新浪财经", "同花顺"])

# 修复后
self._populate_data_sources()  # 动态获取数据源
```

#### 添加动态获取数据源方法
```python
def _populate_data_sources(self):
    """动态获取并填充数据源列表"""
    try:
        # 尝试从服务容器获取统一数据管理器
        from core.containers import get_service_container
        from core.services.unified_data_manager import UnifiedDataManager
        
        service_container = get_service_container()
        if service_container.is_registered(UnifiedDataManager):
            data_manager = service_container.resolve(UnifiedDataManager)
            
            # 获取可用数据源名称
            available_sources = data_manager.get_available_data_source_names()
            if available_sources:
                self.data_source_combo.addItems(available_sources)
                logger.info(f"✅ 动态加载数据源: {available_sources}")
                return
        
        # 降级到默认数据源列表
        default_sources = ["HIkyuu", "东方财富", "新浪财经", "同花顺", "Wind万得"]
        self.data_source_combo.addItems(default_sources)
        logger.info(f"📋 使用默认数据源列表: {default_sources}")
        
    except Exception as e:
        logger.error(f"❌ 填充数据源列表失败: {e}")
        # 最后的降级方案
        self.data_source_combo.addItems(["HIkyuu", "东方财富"])
```

### 3. 数据源配置表动态填充 ✅

#### 添加数据源配置表填充
```python
def _populate_data_source_table(self):
    """填充数据源配置表"""
    try:
        # 获取统一数据管理器
        service_container = get_service_container()
        data_manager = service_container.resolve(UnifiedDataManager)
        registered_sources = data_manager.get_registered_data_sources()
        
        # 设置表格行数
        self.sources_table.setRowCount(len(registered_sources))
        
        # 填充数据
        for row, (plugin_id, info) in enumerate(registered_sources.items()):
            # 名称
            name_item = QTableWidgetItem(info.get('display_name', plugin_id))
            self.sources_table.setItem(row, 0, name_item)
            
            # 类型
            plugin_type = "数据源插件"
            if hasattr(info.get('adapter'), 'plugin_type'):
                plugin_type = info['adapter'].plugin_type
            type_item = QTableWidgetItem(plugin_type)
            self.sources_table.setItem(row, 1, type_item)
            
            # 状态（带颜色标识）
            status = info.get('status', 'unknown')
            status_item = QTableWidgetItem(status)
            if status == 'active':
                status_item.setBackground(QColor(144, 238, 144))  # 浅绿色
            else:
                status_item.setBackground(QColor(255, 182, 193))  # 浅红色
            self.sources_table.setItem(row, 2, status_item)
            
            # 操作按钮（配置、测试）
            action_widget = QWidget()
            action_layout = QHBoxLayout(action_widget)
            
            config_btn = QPushButton("配置")
            test_btn = QPushButton("测试")
            
            action_layout.addWidget(config_btn)
            action_layout.addWidget(test_btn)
            
            self.sources_table.setCellWidget(row, 3, action_widget)
        
        logger.info(f"✅ 数据源配置表已填充，共 {len(registered_sources)} 个数据源")
        
    except Exception as e:
        logger.error(f"❌ 填充数据源配置表失败: {e}")
```

### 4. 添加刷新功能 ✅

#### 数据源刷新方法
```python
def _refresh_data_sources(self):
    """刷新数据源列表"""
    try:
        # 刷新数据源配置表
        self._populate_data_source_table()
        
        # 刷新任务管理中的数据源下拉框
        current_text = self.data_source_combo.currentText()
        self.data_source_combo.clear()
        self._populate_data_sources()
        
        # 尝试恢复之前的选择
        index = self.data_source_combo.findText(current_text)
        if index >= 0:
            self.data_source_combo.setCurrentIndex(index)
        
        logger.info("✅ 数据源列表已刷新")
        QMessageBox.information(self, "刷新完成", "数据源列表已更新")
        
    except Exception as e:
        logger.error(f"❌ 刷新数据源失败: {e}")
        QMessageBox.critical(self, "刷新失败", f"刷新数据源列表失败:\n{str(e)}")
```

## ✅ 修复效果

### 修复前的问题
- ❌ 数据源下拉框显示硬编码列表
- ❌ 数据源配置表为空
- ❌ 无法看到已注册的数据源插件
- ❌ 无法动态更新数据源列表

### 修复后的效果
- ✅ 数据源下拉框动态获取已注册数据源
- ✅ 数据源配置表显示所有已注册数据源
- ✅ 支持数据源状态可视化（颜色标识）
- ✅ 提供配置和测试功能按钮
- ✅ 支持手动刷新数据源列表
- ✅ 降级机制确保在获取失败时使用默认列表

## 📊 技术架构改进

### 数据流向
```
数据源插件注册 
→ 统一数据管理器记录 
→ 数据导入组件动态获取 
→ UI界面实时显示
```

### 关键接口
1. `register_data_source_plugin()` - 注册数据源并记录信息
2. `get_registered_data_sources()` - 获取所有已注册数据源
3. `get_available_data_source_names()` - 获取数据源名称列表
4. `_populate_data_sources()` - 动态填充数据源下拉框
5. `_populate_data_source_table()` - 动态填充数据源配置表

### 容错机制
- **多级降级**: 插件获取失败 → 默认列表 → 最小列表
- **异常处理**: 完善的try-catch和日志记录
- **状态恢复**: 刷新时保持用户选择

## 🎯 用户体验提升

1. **实时性**: 数据源变化立即反映在界面上
2. **可视化**: 数据源状态用颜色区分
3. **交互性**: 提供配置、测试、刷新功能
4. **稳定性**: 多重降级机制确保界面正常显示
5. **一致性**: 任务管理和数据源配置保持同步

## 🔧 修复的文件

1. **core/services/unified_data_manager.py**
   - 添加数据源信息存储
   - 修改注册方法记录信息
   - 添加获取数据源的接口

2. **gui/widgets/data_import_widget.py**
   - 修改数据源下拉框为动态获取
   - 添加数据源配置表填充逻辑
   - 添加刷新和测试功能

## 🎉 总结

这次修复彻底解决了数据源插件与UI界面脱节的问题：

1. **架构层面**: 建立了从插件注册到UI显示的完整数据流
2. **功能层面**: 实现了数据源的动态获取和实时更新
3. **体验层面**: 提供了直观的数据源管理界面
4. **稳定性**: 建立了多重降级和容错机制

用户现在可以看到所有已注册的数据源插件，并且数据源列表会根据插件的注册情况动态更新，真正实现了插件化数据源的完整集成。 