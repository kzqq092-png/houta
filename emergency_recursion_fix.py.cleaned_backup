#!/usr/bin/env python3
"""
ç´§æ€¥é€’å½’ä¿®å¤è„šæœ¬

ä¿®å¤ç”±äºè‡ªåŠ¨æ›¿æ¢å¯¼è‡´çš„é€’å½’è°ƒç”¨é—®é¢˜ï¼š
1. æ£€æµ‹å¹¶ä¿®å¤æ‰€æœ‰å‡½æ•°å†…éƒ¨çš„è‡ªé€’å½’è°ƒç”¨
2. ç¡®ä¿å•ä¾‹æ¨¡å¼çš„æ­£ç¡®å®ç°
3. æ¢å¤æ­£ç¡®çš„å®ä¾‹åŒ–é€»è¾‘
"""

import os
import re
import shutil
from pathlib import Path


def fix_recursion_in_file(file_path: str) -> bool:
    """ä¿®å¤æ–‡ä»¶ä¸­çš„é€’å½’è°ƒç”¨é—®é¢˜"""
    if not os.path.exists(file_path):
        return False

    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()

        original_content = content

        # ä¿®å¤get_unified_data_managerå‡½æ•°å†…éƒ¨çš„é€’å½’è°ƒç”¨
        pattern = r'(def get_unified_data_manager\(\).*?)(\n.*?_unified_data_manager_instance = )get_unified_data_manager\(\)'
        replacement = r'\1\2UnifiedDataManager()'
        content = re.sub(pattern, replacement, content, flags=re.DOTALL)

        # ä¿®å¤å…¶ä»–å¯èƒ½çš„é€’å½’æ¨¡å¼
        # ä¾‹å¦‚ï¼šåœ¨å‡½æ•°foo()å†…éƒ¨è°ƒç”¨foo()
        recursion_patterns = [
            # get_plugin_managerå‡½æ•°å†…éƒ¨è°ƒç”¨è‡ªå·±
            (r'(def get_plugin_manager\(\).*?)(\n.*?=\s*)get_plugin_manager\(\)', r'\1\2PluginManager()'),
            # get_serviceå‡½æ•°å†…éƒ¨è°ƒç”¨è‡ªå·±
            (r'(def get_service\([^)]+\).*?)(\n.*?=\s*)get_service\(', r'\1\2service_container.resolve('),
        ]

        for pattern, replacement in recursion_patterns:
            content = re.sub(pattern, replacement, content, flags=re.DOTALL)

        # å¦‚æœæœ‰å˜åŒ–ï¼Œå†™å›æ–‡ä»¶
        if content != original_content:
            # å¤‡ä»½åŸæ–‡ä»¶
            shutil.copy2(file_path, f"{file_path}.recursion_backup")

            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(content)

            print(f"âœ… ä¿®å¤é€’å½’é—®é¢˜: {file_path}")
            return True

    except Exception as e:
        print(f"âŒ ä¿®å¤å¤±è´¥ {file_path}: {e}")
        return False

    return False


def scan_and_fix_all_recursions():
    """æ‰«æå¹¶ä¿®å¤æ‰€æœ‰å¯èƒ½çš„é€’å½’é—®é¢˜"""
    print("ğŸ” æ‰«æé€’å½’è°ƒç”¨é—®é¢˜...")

    files_to_check = [
        'core/services/unified_data_manager.py',
        'utils/singleton_helper.py',
        'core/services/service_bootstrap.py',
    ]

    # æ·»åŠ æœ€è¿‘ä¿®æ”¹çš„æ–‡ä»¶
    for root, dirs, files in os.walk('.'):
        for file in files:
            if file.endswith('.py') and 'comprehensive_backup' in file:
                original_file = file.replace('.comprehensive_backup', '')
                original_path = os.path.join(root, original_file)
                if os.path.exists(original_path):
                    files_to_check.append(original_path)

    # å»é‡
    files_to_check = list(set(files_to_check))

    fixed_count = 0
    for file_path in files_to_check:
        if fix_recursion_in_file(file_path):
            fixed_count += 1

    return fixed_count


def validate_singleton_implementation():
    """éªŒè¯å•ä¾‹å®ç°çš„æ­£ç¡®æ€§"""
    print("ğŸ” éªŒè¯å•ä¾‹å®ç°...")

    # æ£€æŸ¥get_unified_data_managerå‡½æ•°
    file_path = 'core/services/unified_data_manager.py'
    if os.path.exists(file_path):
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()

        # æŸ¥æ‰¾get_unified_data_managerå‡½æ•°
        pattern = r'def get_unified_data_manager\(\):(.*?)(?=\n\ndef|\nclass|\Z)'
        match = re.search(pattern, content, re.DOTALL)

        if match:
            function_body = match.group(1)

            # æ£€æŸ¥æ˜¯å¦å­˜åœ¨é€’å½’è°ƒç”¨
            if 'get_unified_data_manager()' in function_body:
                print("âŒ å‘ç°é€’å½’è°ƒç”¨åœ¨get_unified_data_managerå‡½æ•°ä¸­")
                return False

            # æ£€æŸ¥æ˜¯å¦æ­£ç¡®åˆ›å»ºå®ä¾‹
            if 'UnifiedDataManager()' in function_body:
                print("âœ… get_unified_data_managerå‡½æ•°å®ç°æ­£ç¡®")
                return True
            else:
                print("âš ï¸ get_unified_data_managerå‡½æ•°å¯èƒ½æœ‰é—®é¢˜")
                print(f"å‡½æ•°ä½“:\n{function_body}")
                return False
        else:
            print("âŒ æœªæ‰¾åˆ°get_unified_data_managerå‡½æ•°")
            return False

    return False


def main():
    """ä¸»å‡½æ•°"""
    print("ğŸš¨ å¼€å§‹ç´§æ€¥é€’å½’ä¿®å¤...")
    print("=" * 60)

    try:
        # 1. æ‰«æå¹¶ä¿®å¤é€’å½’é—®é¢˜
        fixed_count = scan_and_fix_all_recursions()

        # 2. éªŒè¯å•ä¾‹å®ç°
        singleton_ok = validate_singleton_implementation()

        print("\n" + "=" * 60)
        print("ğŸ‰ ç´§æ€¥é€’å½’ä¿®å¤å®Œæˆï¼")
        print(f"\nğŸ“Š ä¿®å¤ç»Ÿè®¡:")
        print(f"  âœ… ä¿®å¤æ–‡ä»¶æ•°: {fixed_count}")
        print(f"  âœ… å•ä¾‹éªŒè¯: {'é€šè¿‡' if singleton_ok else 'å¤±è´¥'}")

        if singleton_ok:
            print(f"\nâœ… å…³é”®ä¿®å¤:")
            print("âœ… æ¶ˆé™¤äº†get_unified_data_managerçš„é€’å½’è°ƒç”¨")
            print("âœ… æ¢å¤äº†æ­£ç¡®çš„UnifiedDataManager()å®ä¾‹åŒ–")
            print("âœ… å•ä¾‹æ¨¡å¼å®ç°æ­£ç¡®")
        else:
            print(f"\nâŒ éœ€è¦è¿›ä¸€æ­¥æ£€æŸ¥:")
            print("âŒ å•ä¾‹å®ç°å¯èƒ½è¿˜æœ‰é—®é¢˜")
            print("âŒ å»ºè®®æ‰‹åŠ¨æ£€æŸ¥get_unified_data_managerå‡½æ•°")

        print(f"\nâš ï¸  é‡è¦æç¤º:")
        print("1. æ‰€æœ‰ä¿®å¤æ–‡ä»¶å·²å¤‡ä»½ä¸º .recursion_backup")
        print("2. è¯·ç«‹å³æµ‹è¯•ç³»ç»Ÿå¯åŠ¨")
        print("3. å¦‚æœ‰é—®é¢˜å¯å¿«é€Ÿæ¢å¤å¤‡ä»½")

    except Exception as e:
        print(f"âŒ ä¿®å¤è¿‡ç¨‹ä¸­å‡ºç°é”™è¯¯: {e}")
        import traceback
        traceback.print_exc()
        return False

    return True


if __name__ == "__main__":
    main()
