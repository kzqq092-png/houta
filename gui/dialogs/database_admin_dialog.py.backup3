from PyQt5.QtWidgets import QDialog, QVBoxLayout, QHBoxLayout, QListWidget, QTableView, QPushButton, QMessageBox, QLineEdit, QLabel, QFileDialog, QStyledItemDelegate, QSpinBox, QDoubleSpinBox, QDateEdit, QCheckBox, QComboBox, QInputDialog, QSplitter, QHeaderView, QWidget, QAbstractItemView, QGroupBox, QTextEdit
from PyQt5.QtSql import QSqlDatabase, QSqlTableModel
from PyQt5.QtCore import Qt, QDate, QThread, pyqtSignal, QAbstractTableModel, QVariant
from PyQt5.QtGui import QFont, QColor, QBrush
import os
import csv
import json
import requests
import time
import logging
import glob
from datetime import datetime


class DatabaseScanThread(QThread):
    """æ•°æ®åº“æ‰«æçº¿ç¨‹"""
    scan_completed = pyqtSignal(dict)
    scan_error = pyqtSignal(str)

    def run(self):
        """æ‰§è¡Œæ•°æ®åº“æ‰«æ"""
        try:
            databases = {
                'sqlite': [],
                'duckdb': []
            }

            # åªæ‰«ædbç›®å½•
            db_dir = os.path.join(os.getcwd(), 'db')
            if not os.path.exists(db_dir):
                self.scan_completed.emit(databases)
                return

            # æ‰«ædbç›®å½•ä¸­çš„æ•°æ®åº“æ–‡ä»¶
            scan_patterns = [
                os.path.join(db_dir, "*.db"),
                os.path.join(db_dir, "*.sqlite"),
                os.path.join(db_dir, "*.sqlite3"),
                os.path.join(db_dir, "*.duckdb"),
            ]

            for pattern in scan_patterns:
                for file_path in glob.glob(pattern):
                    if os.path.isfile(file_path):
                        file_size = os.path.getsize(file_path)
                        # è·³è¿‡ç©ºæ–‡ä»¶æˆ–è¿‡å°çš„æ–‡ä»¶
                        if file_size < 1024:  # å°äº1KB
                            continue

                        # æ ¹æ®æ‰©å±•ååˆ†ç±»
                        ext = os.path.splitext(file_path)[1].lower()
                        if ext in ['.db', '.sqlite', '.sqlite3']:
                            # æ£€æŸ¥æ˜¯å¦çœŸçš„æ˜¯SQLiteæ–‡ä»¶
                            if self._is_sqlite_file(file_path):
                                databases['sqlite'].append({
                                    'path': file_path,
                                    'name': os.path.basename(file_path),
                                    'size': self._format_file_size(file_size)
                                })
                        elif ext == '.duckdb':
                            # æ ‡å‡†DuckDBæ–‡ä»¶
                            if self._is_duckdb_file(file_path):
                                databases['duckdb'].append({
                                    'path': file_path,
                                    'name': os.path.basename(file_path),
                                    'size': self._format_file_size(file_size)
                                })

            self.scan_completed.emit(databases)

        except Exception as e:
            self.scan_error.emit(str(e))

    def _is_sqlite_file(self, file_path):
        """æ£€æŸ¥æ–‡ä»¶æ˜¯å¦ä¸ºæœ‰æ•ˆçš„SQLiteæ•°æ®åº“"""
        try:
            import sqlite3
            conn = sqlite3.connect(file_path)
            cursor = conn.cursor()
            cursor.execute("SELECT name FROM sqlite_master WHERE type='table';")
            conn.close()
            return True
        except Exception:
            return False

    def _is_duckdb_file(self, file_path):
        """æ£€æŸ¥æ–‡ä»¶æ˜¯å¦ä¸ºæœ‰æ•ˆçš„DuckDBæ•°æ®åº“"""
        try:
            import duckdb
            conn = duckdb.connect(file_path)
            conn.execute("SHOW TABLES;")
            conn.close()
            return True
        except Exception:
            return False

    def _format_file_size(self, size_bytes):
        """æ ¼å¼åŒ–æ–‡ä»¶å¤§å°"""
        if size_bytes < 1024:
            return f"{size_bytes} B"
        elif size_bytes < 1024 * 1024:
            return f"{size_bytes / 1024:.1f} KB"
        elif size_bytes < 1024 * 1024 * 1024:
            return f"{size_bytes / (1024 * 1024):.1f} MB"
        else:
            return f"{size_bytes / (1024 * 1024 * 1024):.1f} GB"


class TypeDelegate(QStyledItemDelegate):
    def __init__(self, field_types, parent=None, field_permissions=None, table_name=None):
        super().__init__(parent)
        self.field_types = field_types
        self.field_permissions = field_permissions or {}
        self.table_name = table_name

    def createEditor(self, parent, option, index):
        field = index.model().headerData(index.column(), Qt.Horizontal)
        # å­—æ®µçº§åªè¯»é™åˆ¶
        if self.field_permissions.get(self.table_name, {}).get(field) == 'readonly':
            return None
        ftype = self.field_types.get(field, '').lower()
        if 'int' in ftype:
            editor = QSpinBox(parent)
            editor.setMinimum(-2**31)
            editor.setMaximum(2**31-1)
            return editor
        elif 'real' in ftype or 'float' in ftype or 'double' in ftype:
            editor = QDoubleSpinBox(parent)
            editor.setDecimals(6)
            editor.setMinimum(-1e12)
            editor.setMaximum(1e12)
            return editor
        elif 'date' in ftype:
            editor = QDateEdit(parent)
            editor.setCalendarPopup(True)
            editor.setDisplayFormat('yyyy-MM-dd')
            return editor
        elif 'bool' in ftype or 'tinyint(1)' in ftype:
            editor = QCheckBox(parent)
            return editor
        else:
            return super().createEditor(parent, option, index)

    def setEditorData(self, editor, index):
        value = index.model().data(index, Qt.EditRole)
        field = index.model().headerData(index.column(), Qt.Horizontal)
        ftype = self.field_types.get(field, '').lower()
        if isinstance(editor, QSpinBox):
            editor.setValue(int(value) if value not in (None, '') else 0)
        elif isinstance(editor, QDoubleSpinBox):
            editor.setValue(float(value) if value not in (None, '') else 0.0)
        elif isinstance(editor, QDateEdit):
            if value:
                editor.setDate(QDate.fromString(str(value)[:10], 'yyyy-MM-dd'))
            else:
                editor.setDate(QDate.currentDate())
        elif isinstance(editor, QCheckBox):
            editor.setChecked(
                bool(int(value)) if value not in (None, '') else False)
        else:
            super().setEditorData(editor, index)

    def setModelData(self, editor, model, index):
        field = model.headerData(index.column(), Qt.Horizontal)
        # å­—æ®µçº§åªè¯»é™åˆ¶
        if self.field_permissions.get(self.table_name, {}).get(field) == 'readonly':
            return
        ftype = self.field_types.get(field, '').lower()
        if isinstance(editor, QSpinBox):
            model.setData(index, editor.value())
        elif isinstance(editor, QDoubleSpinBox):
            model.setData(index, editor.value())
        elif isinstance(editor, QDateEdit):
            model.setData(index, editor.date().toString('yyyy-MM-dd'))
        elif isinstance(editor, QCheckBox):
            model.setData(index, 1 if editor.isChecked() else 0)
        else:
            super().setModelData(editor, model, index)


class TableDescriptionManager:
    """è¡¨æè¿°ç®¡ç†å™¨"""

    def __init__(self, system_db_path="db/factorweave_system.sqlite"):
        self.system_db_path = system_db_path

    def get_description(self, database_path, table_name):
        """è·å–è¡¨æè¿°"""
        try:
            import sqlite3
            conn = sqlite3.connect(self.system_db_path)
            cursor = conn.cursor()

            cursor.execute("""
            SELECT description, tags FROM table_descriptions 
            WHERE database_path = ? AND table_name = ?
            """, (database_path, table_name))

            result = cursor.fetchone()
            conn.close()

            if result:
                return {
                    'description': result[0] or '',
                    'tags': result[1] or ''
                }
            else:
                return {'description': '', 'tags': ''}

        except Exception as e:
            print(f"è·å–è¡¨æè¿°å¤±è´¥: {e}")
            return {'description': '', 'tags': ''}

    def save_description(self, database_path, database_type, table_name, description, tags=''):
        """ä¿å­˜è¡¨æè¿°"""
        try:
            import sqlite3
            conn = sqlite3.connect(self.system_db_path)
            cursor = conn.cursor()

            cursor.execute("""
            INSERT OR REPLACE INTO table_descriptions 
            (database_path, database_type, table_name, description, tags, updated_at)
            VALUES (?, ?, ?, ?, ?, CURRENT_TIMESTAMP)
            """, (database_path, database_type, table_name, description, tags))

            conn.commit()
            conn.close()
            return True

        except Exception as e:
            print(f"ä¿å­˜è¡¨æè¿°å¤±è´¥: {e}")
            return False

    def get_all_descriptions(self, database_path):
        """è·å–æŒ‡å®šæ•°æ®åº“çš„æ‰€æœ‰è¡¨æè¿°"""
        try:
            import sqlite3
            conn = sqlite3.connect(self.system_db_path)
            cursor = conn.cursor()

            cursor.execute("""
            SELECT table_name, description, tags FROM table_descriptions 
            WHERE database_path = ?
            """, (database_path,))

            results = cursor.fetchall()
            conn.close()

            return {row[0]: {'description': row[1], 'tags': row[2]} for row in results}

        except Exception as e:
            print(f"è·å–æ‰€æœ‰è¡¨æè¿°å¤±è´¥: {e}")
            return {}


class DatabaseAdminDialog(QDialog):
    def __init__(self, db_path, parent=None, mode='admin'):
        super().__init__(parent)
        self.field_permissions = {}  # æå‰åˆå§‹åŒ–ï¼Œé˜²æ­¢AttributeError
        self.setWindowTitle("æ•°æ®åº“ç®¡ç†åå°")
        self.resize(1000, 650)
        self.db_path = db_path
        self.mode = mode  # 'readonly', 'write', 'admin'
        self.current_table = None
        self.page_size = 50
        self.current_page = 0
        self.log = []

        # æ…¢SQLè®°å½•åŠŸèƒ½
        self.slow_query_threshold = 500  # æ…¢æŸ¥è¯¢é˜ˆå€¼(æ¯«ç§’)
        self.slow_queries = []  # æ…¢æŸ¥è¯¢è®°å½•

        # æ•°æ®åº“æ–‡ä»¶ç®¡ç†
        self.available_databases = {
            'sqlite': [],
            'duckdb': []
        }
        self.current_db_type = 'sqlite'  # é»˜è®¤ç±»å‹
        self.selected_db_path = db_path  # å½“å‰é€‰æ‹©çš„æ•°æ®åº“è·¯å¾„

        self.init_ui()

    def init_ui(self):
        main_layout = QVBoxLayout(self)

        # æ•°æ®åº“è¿æ¥åŒºåŸŸ - é›†æˆåˆ°é¡¶éƒ¨
        self._create_database_connection_panel(main_layout)

        # ä¸»è¦å†…å®¹åŒºåŸŸ
        content_splitter = QSplitter(Qt.Horizontal)

        # å·¦ä¾§é¢æ¿ - è¡¨åˆ—è¡¨å’Œæè¿°
        left_panel = QWidget()
        left_layout = QVBoxLayout(left_panel)
        left_layout.setContentsMargins(0, 0, 0, 0)

        # è¡¨åˆ—è¡¨
        self.table_list = QListWidget()
        self.table_list.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        self.table_list.setWordWrap(True)
        self.table_list.itemClicked.connect(self.load_table)
        self.table_list.setMaximumWidth(250)
        self.table_list.setMinimumWidth(200)

        # è¡¨æè¿°é¢æ¿
        description_panel = self._create_table_description_panel()

        # æ·»åŠ åˆ°å·¦ä¾§å¸ƒå±€
        left_layout.addWidget(QLabel("æ•°æ®åº“è¡¨åˆ—è¡¨"))
        left_layout.addWidget(self.table_list, 1)  # è¡¨åˆ—è¡¨å ä¸»è¦ç©ºé—´
        left_layout.addWidget(description_panel, 0)  # æè¿°é¢æ¿å›ºå®šé«˜åº¦

        # å³ä¾§ - æ•°æ®æ˜¾ç¤ºåŒºåŸŸ
        right_panel = QWidget()
        right_layout = QVBoxLayout(right_panel)
        right_layout.setContentsMargins(0, 0, 0, 0)

        # å·¥å…·æ 
        toolbar_layout = QHBoxLayout()

        self.add_btn = QPushButton("â• æ·»åŠ ")
        self.del_btn = QPushButton("â– åˆ é™¤")
        self.edit_btn = QPushButton("âœï¸ ç¼–è¾‘")
        self.save_btn = QPushButton("ğŸ’¾ ä¿å­˜")
        self.refresh_btn = QPushButton("ğŸ”„ åˆ·æ–°")

        toolbar_layout.addWidget(self.add_btn)
        toolbar_layout.addWidget(self.del_btn)
        toolbar_layout.addWidget(self.edit_btn)
        toolbar_layout.addWidget(self.save_btn)
        toolbar_layout.addWidget(self.refresh_btn)
        toolbar_layout.addStretch()

        # åˆ†é¡µæ§ä»¶
        self.prev_btn = QPushButton("â¬…ï¸ ä¸Šä¸€é¡µ")
        self.next_btn = QPushButton("â¡ï¸ ä¸‹ä¸€é¡µ")
        self.page_label = QLabel("ç¬¬ 1 é¡µï¼Œå…± 1 é¡µï¼Œæ€»è®¡ 0 è¡Œ")

        toolbar_layout.addWidget(self.prev_btn)
        toolbar_layout.addWidget(self.page_label)
        toolbar_layout.addWidget(self.next_btn)

        # è¡¨æ ¼è§†å›¾
        self.table_view = QTableView()
        self.table_view.setAlternatingRowColors(True)
        self.table_view.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.table_view.horizontalHeader().setStretchLastSection(True)

        # ä¸»é¢˜æç¤º
        self.theme_hint = QLabel()
        self.theme_hint.setWordWrap(True)
        self.theme_hint.setStyleSheet("""
            QLabel {
                background-color: #e8f5e8;
                border: 1px solid #4CAF50;
                border-radius: 4px;
                padding: 8px;
                margin: 4px;
            }
        """)
        self.theme_hint.setVisible(False)

        # æ·»åŠ åˆ°å³ä¾§å¸ƒå±€
        right_layout.addLayout(toolbar_layout)
        right_layout.addWidget(self.table_view, 1)
        right_layout.addWidget(self.theme_hint, 0)

        # æ·»åŠ åˆ°åˆ†å‰²å™¨
        content_splitter.addWidget(left_panel)
        content_splitter.addWidget(right_panel)
        content_splitter.setStretchFactor(0, 0)  # å·¦ä¾§å›ºå®š
        content_splitter.setStretchFactor(1, 1)  # å³ä¾§å¯ä¼¸ç¼©

        main_layout.addWidget(content_splitter, 1)

        # åˆå§‹åŒ–æ•°æ®åº“è¿æ¥
        self.connection_name = f"dbadmin_{int(time.time() * 1000)}"
        self.db = QSqlDatabase.addDatabase("QSQLITE", self.connection_name)
        self.db.setDatabaseName(self.db_path)
        self.db.open()
        tables = self.db.tables()
        self.table_list.addItems(tables)

        # è‡ªåŠ¨é«˜äº®themesè¡¨
        if "themes" in tables:
            items = self.table_list.findItems("themes", Qt.MatchExactly)
            if items:
                self.table_list.setCurrentItem(items[0])
                self.load_table(items[0])
                self.theme_hint.setText(
                    "â­ ä¸»é¢˜è¡¨(themes)ï¼šç”¨äºç®¡ç†UIä¸»é¢˜ï¼Œæ”¯æŒQSS/JSONç±»å‹ï¼Œå»ºè®®é€šè¿‡ä¸»é¢˜ç®¡ç†ç•Œé¢æ“ä½œã€‚å¯ç›´æ¥ç¼–è¾‘ã€å¯¼å…¥å¯¼å‡ºä¸»é¢˜å†…å®¹ã€‚\nå­—æ®µè¯´æ˜ï¼šname=ä¸»é¢˜åï¼Œtype=ç±»å‹(qss/json)ï¼Œcontent=å†…å®¹ï¼Œorigin=æ¥æºï¼Œcreated_at/updated_at=æ—¶é—´ã€‚\nå¦‚éœ€æ‰¹é‡å¯¼å…¥QSSä¸»é¢˜ï¼Œå¯å°†QSSæ–‡ä»¶æ”¾å…¥QSSThemeç›®å½•ï¼Œé‡å¯åè‡ªåŠ¨å¯¼å…¥ã€‚")
                self.theme_hint.setVisible(True)
        else:
            self.theme_hint.setVisible(False)

        # äº‹ä»¶ç»‘å®š
        self.add_btn.clicked.connect(self.add_row)
        self.del_btn.clicked.connect(self.del_row)
        self.edit_btn.clicked.connect(self.toggle_edit_mode)
        self.save_btn.clicked.connect(self.save_changes)
        self.refresh_btn.clicked.connect(self.refresh_table)
        self.prev_btn.clicked.connect(self.prev_page)
        self.next_btn.clicked.connect(self.next_page)

    def _create_table_description_panel(self):
        """åˆ›å»ºè¡¨æè¿°é¢æ¿"""
        from PyQt5.QtWidgets import (QGroupBox, QVBoxLayout, QHBoxLayout,
                                     QTextEdit, QLabel, QLineEdit, QPushButton)

        # åˆ›å»ºæè¿°é¢æ¿åˆ†ç»„æ¡†
        desc_group = QGroupBox("è¡¨æè¿°ä¿¡æ¯")
        desc_group.setFixedHeight(200)
        desc_layout = QVBoxLayout(desc_group)

        # è¡¨åæ ‡ç­¾
        self.current_table_label = QLabel("å½“å‰è¡¨: æœªé€‰æ‹©")
        self.current_table_label.setStyleSheet("font-weight: bold; color: #2c3e50;")
        desc_layout.addWidget(self.current_table_label)

        # æ ‡ç­¾è¾“å…¥
        tags_layout = QHBoxLayout()
        tags_layout.addWidget(QLabel("æ ‡ç­¾:"))
        self.table_tags_edit = QLineEdit()
        self.table_tags_edit.setPlaceholderText("è¾“å…¥æ ‡ç­¾ï¼Œç”¨é€—å·åˆ†éš”...")
        tags_layout.addWidget(self.table_tags_edit)
        desc_layout.addLayout(tags_layout)

        # æè¿°è¾“å…¥
        desc_layout.addWidget(QLabel("æè¿°:"))
        self.table_description_edit = QTextEdit()
        self.table_description_edit.setPlaceholderText("è¾“å…¥è¡¨çš„è¯¦ç»†æè¿°...")
        self.table_description_edit.setMaximumHeight(80)
        desc_layout.addWidget(self.table_description_edit)

        # æŒ‰é’®å¸ƒå±€
        button_layout = QHBoxLayout()

        self.save_desc_btn = QPushButton("ğŸ’¾ ä¿å­˜æè¿°")
        self.save_desc_btn.clicked.connect(self._save_table_description)
        self.save_desc_btn.setStyleSheet("""
            QPushButton {
                background-color: #27ae60;
                color: white;
                border: none;
                padding: 5px 15px;
                border-radius: 3px;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #229954;
            }
        """)

        self.clear_desc_btn = QPushButton("ğŸ—‘ï¸ æ¸…ç©º")
        self.clear_desc_btn.clicked.connect(self._clear_table_description)
        self.clear_desc_btn.setStyleSheet("""
            QPushButton {
                background-color: #e74c3c;
                color: white;
                border: none;
                padding: 5px 15px;
                border-radius: 3px;
            }
            QPushButton:hover {
                background-color: #c0392b;
            }
        """)

        button_layout.addWidget(self.save_desc_btn)
        button_layout.addWidget(self.clear_desc_btn)
        button_layout.addStretch()

        desc_layout.addLayout(button_layout)

        return desc_group

    def _load_table_description(self, table_name):
        """åŠ è½½è¡¨æè¿°"""
        if not hasattr(self, 'description_manager'):
            self.description_manager = TableDescriptionManager()

        # æ›´æ–°å½“å‰è¡¨æ ‡ç­¾
        self.current_table_label.setText(f"å½“å‰è¡¨: {table_name}")

        # è·å–æè¿°ä¿¡æ¯
        desc_info = self.description_manager.get_description(self.db_path, table_name)

        # æ›´æ–°ç•Œé¢
        self.table_description_edit.setPlainText(desc_info['description'])
        self.table_tags_edit.setText(desc_info['tags'])

    def _save_table_description(self):
        """ä¿å­˜è¡¨æè¿°"""
        if not self.current_table:
            QMessageBox.warning(self, "è­¦å‘Š", "è¯·å…ˆé€‰æ‹©ä¸€ä¸ªè¡¨")
            return

        if not hasattr(self, 'description_manager'):
            self.description_manager = TableDescriptionManager()

        description = self.table_description_edit.toPlainText().strip()
        tags = self.table_tags_edit.text().strip()

        # ç¡®å®šæ•°æ®åº“ç±»å‹
        db_type = self.current_db_type if hasattr(self, 'current_db_type') else 'sqlite'

        if self.description_manager.save_description(
                self.db_path, db_type, self.current_table, description, tags):
            QMessageBox.information(self, "æˆåŠŸ", f"è¡¨ '{self.current_table}' çš„æè¿°å·²ä¿å­˜")
        else:
            QMessageBox.critical(self, "é”™è¯¯", "ä¿å­˜è¡¨æè¿°å¤±è´¥")

    def _clear_table_description(self):
        """æ¸…ç©ºè¡¨æè¿°"""
        self.table_description_edit.clear()
        self.table_tags_edit.clear()

    def load_table(self, item):
        """åŠ è½½è¡¨æ•°æ® - æ”¯æŒ SQLite å’Œ DuckDBï¼Œå¹¶åŠ è½½è¡¨æè¿°"""
        if not item:
            return

        table_name = item.text()
        self.current_table = table_name

        # åŠ è½½è¡¨æè¿°
        self._load_table_description(table_name)

        try:
            if self.current_db_type == 'duckdb':
                # DuckDB å¤„ç†
                if hasattr(self, '_duckdb_conn'):
                    # è·å–è¡¨ç»“æ„
                    schema_result = self._duckdb_conn.execute(f"DESCRIBE {table_name}").fetchall()

                    # è·å–æ•°æ®ï¼ˆåˆ†é¡µï¼‰
                    offset = self.current_page * self.page_size
                    data_result = self._duckdb_conn.execute(
                        f"SELECT * FROM {table_name} LIMIT {self.page_size} OFFSET {offset}"
                    ).fetchall()

                    # è·å–æ€»è¡Œæ•°
                    count_result = self._duckdb_conn.execute(f"SELECT COUNT(*) FROM {table_name}").fetchone()
                    total_rows = count_result[0] if count_result else 0

                    # åˆ›å»ºè‡ªå®šä¹‰æ¨¡å‹æ˜¾ç¤ºæ•°æ®
                    self._create_duckdb_table_model(schema_result, data_result, total_rows)

            else:
                # SQLite å¤„ç†ï¼ˆåŸæœ‰é€»è¾‘ï¼‰
                if hasattr(self, 'model'):
                    self.model.deleteLater()

                self.model = QSqlTableModel(self, self.db)
                self.model.setTable(table_name)
                self.model.setEditStrategy(QSqlTableModel.OnManualSubmit)
                self.model.select()

                self.table_view.setModel(self.model)

                # æ›´æ–°åˆ†é¡µä¿¡æ¯
                total_rows = self.model.rowCount()

            # æ›´æ–°é¡µé¢ä¿¡æ¯
            total_pages = (total_rows + self.page_size - 1) // self.page_size
            self.page_label.setText(f"ç¬¬ {self.current_page + 1} é¡µï¼Œå…± {total_pages} é¡µï¼Œæ€»è®¡ {total_rows} è¡Œ")

            # æ›´æ–°æŒ‰é’®çŠ¶æ€
            self.prev_btn.setEnabled(self.current_page > 0)
            self.next_btn.setEnabled(self.current_page < total_pages - 1)

        except Exception as e:
            QMessageBox.critical(self, "é”™è¯¯", f"åŠ è½½è¡¨ {table_name} å¤±è´¥: {str(e)}")

    def refresh_table(self):
        table_name = self.current_table
        if not table_name:
            return
        self.model = QSqlTableModel(self, self.db)
        self.model.setTable(table_name)
        self.model.setEditStrategy(QSqlTableModel.OnManualSubmit)
        self.model.select()
        # å­—æ®µç±»å‹ä¸ä¸»é”®ä¿¡æ¯
        self.field_types = {}
        self.pk_fields = set()
        query = self.db.exec(f"PRAGMA table_info({table_name})")
        while query.next():
            name = query.value(1)
            ftype = query.value(2)
            pk = query.value(5)
            self.field_types[name] = ftype
            if pk:
                self.pk_fields.add(name)
        # å­—æ®µçº§æƒé™é€‚é…
        perms = self.field_permissions.get(table_name, {})
        for col in range(self.model.columnCount()):
            name = self.model.headerData(col, Qt.Horizontal)
            if perms.get(name) == 'hidden':
                self.table_view.setColumnHidden(col, True)
            else:
                self.table_view.setColumnHidden(col, False)
        self.table_view.setModel(self.model)
        self.table_view.setItemDelegate(TypeDelegate(
            self.field_types, self.table_view, self.field_permissions, table_name))
        for col in range(self.model.columnCount()):
            name = self.model.headerData(col, Qt.Horizontal)
            if name in self.pk_fields:
                self.table_view.setColumnWidth(col, 120)
        self.apply_search()
        self.update_page_label()
        # ç©ºæ•°æ®æç¤º
        if self.model.rowCount() == 0:
            label = QLabel("æš‚æ— æ•°æ®", self.table_view)
            label.setAlignment(Qt.AlignCenter)
            label.setStyleSheet("color: #90A4AE; font-size: 16px;")
            self.table_view.setIndexWidget(self.model.index(0, 0), label)

    def add_row(self):
        if hasattr(self, 'model'):
            self.model.insertRow(self.model.rowCount())
            self.log.append(f"æ–°å¢è¡Œäºè¡¨ {self.current_table}")

    def del_row(self):
        if hasattr(self, 'model'):
            idxs = self.table_view.selectionModel().selectedRows()
            if not idxs:
                return
            if QMessageBox.question(self, "ç¡®è®¤åˆ é™¤", f"ç¡®å®šè¦åˆ é™¤é€‰ä¸­{len(idxs)}è¡Œå—ï¼Ÿ") == QMessageBox.Yes:
                for idx in sorted(idxs, key=lambda x: -x.row()):
                    self.model.removeRow(idx.row())
                self.log.append(f"æ‰¹é‡åˆ é™¤{len(idxs)}è¡Œäºè¡¨ {self.current_table}")

    def save_changes(self):
        if hasattr(self, 'model'):
            if not self.model.submitAll():
                QMessageBox.warning(
                    self, "ä¿å­˜å¤±è´¥", self.model.lastError().text())
            else:
                QMessageBox.information(self, "ä¿å­˜æˆåŠŸ", "æ‰€æœ‰æ›´æ”¹å·²ä¿å­˜ï¼")
                self.log.append(f"ä¿å­˜æ›´æ”¹äºè¡¨ {self.current_table}")

    def import_csv(self):
        path, _ = QFileDialog.getOpenFileName(
            self, "å¯¼å…¥CSV", "", "CSV Files (*.csv)")
        if not path:
            return
        with open(path, encoding='utf-8') as f:
            reader = csv.reader(f)
            headers = next(reader)
            for row in reader:
                self.model.insertRow(self.model.rowCount())
                for col, val in enumerate(row):
                    self.model.setData(self.model.index(
                        self.model.rowCount()-1, col), val)
        QMessageBox.information(self, "å¯¼å…¥å®Œæˆ", "CSVæ•°æ®å·²å¯¼å…¥ï¼Œè®°å¾—ä¿å­˜ï¼")
        self.log.append(f"å¯¼å…¥CSVåˆ°è¡¨ {self.current_table}")

    def export_csv(self):
        path, _ = QFileDialog.getSaveFileName(
            self, "å¯¼å‡ºCSV", f"{self.current_table}.csv", "CSV Files (*.csv)")
        if not path:
            return
        with open(path, 'w', encoding='utf-8', newline='') as f:
            writer = csv.writer(f)
            headers = [self.model.headerData(
                i, Qt.Horizontal) for i in range(self.model.columnCount())]
            writer.writerow(headers)
            for row in range(self.model.rowCount()):
                writer.writerow([self.model.data(self.model.index(row, col))
                                for col in range(self.model.columnCount())])
        QMessageBox.information(self, "å¯¼å‡ºå®Œæˆ", "CSVæ•°æ®å·²å¯¼å‡ºï¼")
        self.log.append(f"å¯¼å‡ºCSVäºè¡¨ {self.current_table}")

    def apply_search(self):
        if not hasattr(self, 'model') or not self.current_table:
            return
        text = self.search_edit.text().strip()
        if not text:
            self.model.setFilter("")
        else:
            filters = []
            for col in range(self.model.columnCount()):
                name = self.model.headerData(col, Qt.Horizontal)
                filters.append(f"{name} LIKE '%{text}%'")
            self.model.setFilter(" OR ".join(filters))
        self.model.select()
        self.update_page_label()

    def prev_page(self):
        if self.current_page > 0:
            self.current_page -= 1
            self.refresh_table()

    def next_page(self):
        self.current_page += 1
        self.refresh_table()

    def update_page_label(self):
        total = self.model.rowCount()
        self.page_label.setText(
            f"ç¬¬{self.current_page+1}é¡µ / å…±{(total-1)//self.page_size+1}é¡µ  å…±{total}è¡Œ")

    def show_log(self):
        if self.log_window is None:
            self.log_window = QDialog(self)
            self.log_window.setWindowTitle("æ“ä½œæ—¥å¿—")
            vbox = QVBoxLayout(self.log_window)
            self.log_text = QLineEdit()
            self.log_text.setReadOnly(True)
            vbox.addWidget(self.log_text)
            export_btn = QPushButton("å¯¼å‡ºæ—¥å¿—")
            export_btn.clicked.connect(self.export_log)
            vbox.addWidget(export_btn)
            rollback_btn = QPushButton("æ’¤é”€æœ€è¿‘æ“ä½œ")
            rollback_btn.clicked.connect(self.rollback_last)
            vbox.addWidget(rollback_btn)
        self.log_text.setText("\n".join(self.log))
        self.log_window.exec_()

    def export_log(self):
        path, _ = QFileDialog.getSaveFileName(
            self, "å¯¼å‡ºæ—¥å¿—", "dbadmin_log.txt", "Text Files (*.txt)")
        if path:
            with open(path, 'w', encoding='utf-8') as f:
                f.write("\n".join(self.log))
            QMessageBox.information(self, "å¯¼å‡ºå®Œæˆ", "æ—¥å¿—å·²å¯¼å‡ºï¼")

    def rollback_last(self):
        # ç®€å•å®ç°ï¼šæ’¤é”€æœ€è¿‘ä¸€æ¬¡æ–°å¢/åˆ é™¤/å¯¼å…¥æ“ä½œï¼ˆä»…å†…å­˜ï¼Œæœªä¿å­˜å‰æœ‰æ•ˆï¼‰
        if not self.log:
            QMessageBox.information(self, "æ— æ“ä½œå¯æ’¤é”€", "æ²¡æœ‰å¯æ’¤é”€çš„æ“ä½œï¼")
            return
        last = self.log[-1]
        if "æ–°å¢è¡Œ" in last:
            if hasattr(self, 'model'):
                self.model.removeRow(self.model.rowCount()-1)
                self.log.append("æ’¤é”€ï¼š"+last)
        elif "æ‰¹é‡åˆ é™¤" in last:
            QMessageBox.information(self, "æš‚ä¸æ”¯æŒæ‰¹é‡å›æ»š", "æ‰¹é‡åˆ é™¤æš‚ä¸æ”¯æŒè‡ªåŠ¨å›æ»šï¼Œè¯·æ‰‹åŠ¨æ¢å¤ã€‚")
        elif "å¯¼å…¥CSV" in last:
            QMessageBox.information(self, "æš‚ä¸æ”¯æŒå¯¼å…¥å›æ»š", "å¯¼å…¥æ“ä½œæš‚ä¸æ”¯æŒè‡ªåŠ¨å›æ»šï¼Œè¯·æ‰‹åŠ¨åˆ é™¤ã€‚")
        else:
            QMessageBox.information(self, "æ— æ³•æ’¤é”€", "è¯¥æ“ä½œæ— æ³•è‡ªåŠ¨æ’¤é”€ã€‚")

    def show_permission_manager(self):
        dlg = QDialog(self)
        dlg.setWindowTitle("å­—æ®µæƒé™ç®¡ç†")
        vbox = QVBoxLayout(dlg)
        table_combo = QListWidget()
        table_combo.addItems(self.db.tables())
        vbox.addWidget(QLabel("é€‰æ‹©è¡¨ï¼š"))
        vbox.addWidget(table_combo)
        field_list = QListWidget()
        vbox.addWidget(QLabel("å­—æ®µæƒé™ï¼š"))
        vbox.addWidget(field_list)
        perm_combo = QComboBox()
        perm_combo.addItems(["å¯å†™", "åªè¯»", "éšè—"])
        vbox.addWidget(QLabel("è®¾ç½®æƒé™ï¼š"))
        vbox.addWidget(perm_combo)
        save_btn = QPushButton("ä¿å­˜æƒé™")
        vbox.addWidget(save_btn)

        def load_fields():
            field_list.clear()
            table = table_combo.currentItem().text() if table_combo.currentItem() else None
            if not table:
                return
            model = QSqlTableModel(self, self.db)
            model.setTable(table)
            model.select()
            for col in range(model.columnCount()):
                name = model.headerData(col, Qt.Horizontal)
                field_list.addItem(name)
        table_combo.currentItemChanged.connect(lambda *_: load_fields())

        def set_perm():
            table = table_combo.currentItem().text() if table_combo.currentItem() else None
            perm = perm_combo.currentText()
            for item in field_list.selectedItems():
                field = item.text()
                if table not in self.field_permissions:
                    self.field_permissions[table] = {}
                if perm == "å¯å†™":
                    self.field_permissions[table][field] = "write"
                elif perm == "åªè¯»":
                    self.field_permissions[table][field] = "readonly"
                elif perm == "éšè—":
                    self.field_permissions[table][field] = "hidden"
            QMessageBox.information(dlg, "æƒé™è®¾ç½®", "æƒé™å·²è®¾ç½®ï¼Œè®°å¾—ä¿å­˜ï¼")
        perm_combo.currentTextChanged.connect(lambda _: set_perm())
        save_btn.clicked.connect(lambda: (
            self.save_field_permissions(), QMessageBox.information(dlg, "ä¿å­˜æˆåŠŸ", "æƒé™å·²ä¿å­˜ï¼")))
        load_fields()
        dlg.exec_()

    def show_batch_modify(self):
        if not hasattr(self, 'model') or not self.current_table:
            return
        dlg = QDialog(self)
        dlg.setWindowTitle("æ‰¹é‡å­—æ®µä¿®æ”¹/æŸ¥æ‰¾æ›¿æ¢")
        vbox = QVBoxLayout(dlg)
        # å­—æ®µé€‰æ‹©
        field_label = QLabel("å­—æ®µ:")
        vbox.addWidget(field_label)
        field_combo = QListWidget()
        for col in range(self.model.columnCount()):
            name = self.model.headerData(col, Qt.Horizontal)
            if self.field_permissions.get(self.current_table, {}).get(name) != 'hidden':
                field_combo.addItem(name)
        vbox.addWidget(field_combo)
        # å¡«å……å€¼
        fill_label = QLabel("å¡«å……å€¼:")
        vbox.addWidget(fill_label)
        fill_edit = QLineEdit()
        vbox.addWidget(fill_edit)
        # æŸ¥æ‰¾æ›¿æ¢
        find_label = QLabel("æŸ¥æ‰¾:")
        vbox.addWidget(find_label)
        find_edit = QLineEdit()
        replace_label = QLabel("æ›¿æ¢ä¸º:")
        vbox.addWidget(replace_label)
        replace_edit = QLineEdit()
        vbox.addWidget(find_edit)
        vbox.addWidget(replace_edit)
        # æ¡ä»¶ç­›é€‰
        cond_label = QLabel("æ¡ä»¶(å¦‚ a=1,b=2,æ”¯æŒæ­£åˆ™):")
        vbox.addWidget(cond_label)
        cond_edit = QLineEdit()
        vbox.addWidget(cond_edit)
        # åº”ç”¨æŒ‰é’®
        apply_btn = QPushButton("åº”ç”¨")
        vbox.addWidget(apply_btn)

        def do_batch():
            import re
            selected_fields = [item.text()
                               for item in field_combo.selectedItems()]
            if not selected_fields:
                QMessageBox.warning(dlg, "è¯·é€‰æ‹©å­—æ®µ", "è¯·è‡³å°‘é€‰æ‹©ä¸€ä¸ªå­—æ®µ")
                return
            fill_val = fill_edit.text()
            find_val = find_edit.text()
            replace_val = replace_edit.text()
            cond = cond_edit.text().strip()
            # å¤šæ¡ä»¶è§£æ
            conds = []
            if cond:
                for part in cond.split(','):
                    if '=' in part:
                        k, v = part.split('=', 1)
                        conds.append((k.strip(), v.strip()))
            idxs = self.table_view.selectionModel().selectedRows()
            if not idxs:
                idxs = [self.model.index(row, 0)
                        for row in range(self.model.rowCount())]
            for idx in idxs:
                row = idx.row()
                # å¤šæ¡ä»¶åˆ¤æ–­
                match = True
                for k, v in conds:
                    col_idx = None
                    for col in range(self.model.columnCount()):
                        if self.model.headerData(col, Qt.Horizontal) == k:
                            col_idx = col
                            break
                    if col_idx is not None:
                        cell_val = str(self.model.data(
                            self.model.index(row, col_idx)))
                        # æ”¯æŒæ­£åˆ™
                        try:
                            if not re.fullmatch(v, cell_val):
                                match = False
                                break
                        except Exception:
                            if cell_val != v:
                                match = False
                                break
                if not match:
                    continue
                for col in range(self.model.columnCount()):
                    name = self.model.headerData(col, Qt.Horizontal)
                    # å­—æ®µçº§åªè¯»é™åˆ¶
                    if self.field_permissions.get(self.current_table, {}).get(name) == 'readonly':
                        continue
                    if name in selected_fields:
                        if fill_val:
                            self.model.setData(
                                self.model.index(row, col), fill_val)
                        if find_val:
                            val0 = str(self.model.data(
                                self.model.index(row, col)))
                            if find_val in val0:
                                self.model.setData(self.model.index(
                                    row, col), val0.replace(find_val, replace_val))
            self.log.append(
                f"æ‰¹é‡ä¿®æ”¹å­—æ®µ {selected_fields} äºè¡¨ {self.current_table}")
            QMessageBox.information(dlg, "æ‰¹é‡ä¿®æ”¹å®Œæˆ", "æ‰¹é‡æ“ä½œå·²å®Œæˆï¼Œè®°å¾—ä¿å­˜ï¼")
            dlg.accept()
        apply_btn.clicked.connect(do_batch)
        dlg.exec_()

    def upload_permissions_to_cloud(self):
        config_path = os.path.join(os.path.dirname(
            __file__), 'db_field_permissions.json')
        url = 'https://your-cloud-api/upload'  # æ›¿æ¢ä¸ºä½ çš„äº‘ç«¯API
        try:
            with open(config_path, 'rb') as f:
                files = {'file': ('db_field_permissions.json', f)}
                r = requests.post(url, files=files)
            if r.status_code == 200:
                QMessageBox.information(self, "ä¸Šä¼ æˆåŠŸ", "æƒé™é…ç½®å·²ä¸Šä¼ åˆ°äº‘ç«¯ï¼")
            else:
                QMessageBox.warning(self, "ä¸Šä¼ å¤±è´¥", f"äº‘ç«¯è¿”å›: {r.text}")
        except Exception as e:
            QMessageBox.warning(self, "ä¸Šä¼ å¤±è´¥", str(e))

    def download_permissions_from_cloud(self):
        config_path = os.path.join(os.path.dirname(
            __file__), 'db_field_permissions.json')
        url = 'https://your-cloud-api/download'  # æ›¿æ¢ä¸ºä½ çš„äº‘ç«¯API
        try:
            r = requests.get(url)
            if r.status_code == 200:
                with open(config_path, 'wb') as f:
                    f.write(r.content)
                self.load_field_permissions()
                QMessageBox.information(self, "ä¸‹è½½æˆåŠŸ", "æƒé™é…ç½®å·²ä»äº‘ç«¯æ‹‰å–å¹¶ç”Ÿæ•ˆï¼")
            else:
                QMessageBox.warning(self, "ä¸‹è½½å¤±è´¥", f"äº‘ç«¯è¿”å›: {r.text}")
        except Exception as e:
            QMessageBox.warning(self, "ä¸‹è½½å¤±è´¥", str(e))

    def show_permission_log(self):
        log_path = os.path.join(os.path.dirname(
            __file__), 'db_field_permissions_log.json')
        dlg = QDialog(self)
        dlg.setWindowTitle("æƒé™å˜æ›´æ—¥å¿—")
        vbox = QVBoxLayout(dlg)
        log_list = QListWidget()
        vbox.addWidget(log_list)
        rollback_btn = QPushButton("å›æ»šåˆ°é€‰ä¸­ç‰ˆæœ¬")
        vbox.addWidget(rollback_btn)
        logs = []
        if os.path.exists(log_path):
            try:
                with open(log_path, 'r', encoding='utf-8') as f:
                    logs = json.load(f)
                for i, entry in enumerate(logs):
                    time = entry.get('time', '')
                    for d in entry.get('diff', []):
                        log_list.addItem(
                            f"[{i}] [{time}] {d['table']}.{d['field']}: {d['old']} -> {d['new']}")
            except Exception as e:
                log_list.addItem(f"æ—¥å¿—è¯»å–å¤±è´¥: {str(e)}")
        else:
            log_list.addItem("æš‚æ— æ—¥å¿—è®°å½•")

        def do_rollback():
            idx = log_list.currentRow()
            if idx < 0 or idx >= len(logs):
                QMessageBox.warning(dlg, "æœªé€‰æ‹©", "è¯·å…ˆé€‰æ‹©è¦å›æ»šçš„ç‰ˆæœ¬")
                return
            # å›æ»šåˆ°é€‰ä¸­æ—¥å¿—ä¹‹å‰çš„æƒé™é…ç½®
            config_path = os.path.join(os.path.dirname(
                __file__), 'db_field_permissions.json')
            # é‡æ–°æ„å»ºæƒé™é…ç½®
            perms = {}
            for i in range(idx+1):
                for d in logs[i].get('diff', []):
                    table, field, new = d['table'], d['field'], d['new']
                    if table not in perms:
                        perms[table] = {}
                    perms[table][field] = new
            self.field_permissions = perms
            with open(config_path, 'w', encoding='utf-8') as f:
                json.dump(self.field_permissions, f,
                          ensure_ascii=False, indent=2)
            self.load_field_permissions()
            QMessageBox.information(dlg, "å›æ»šæˆåŠŸ", f"å·²å›æ»šåˆ°ç¬¬{idx+1}ä¸ªç‰ˆæœ¬ï¼Œæƒé™å·²ç”Ÿæ•ˆï¼")
        rollback_btn.clicked.connect(do_rollback)
        dlg.exec_()

    def show_schema_manager(self):
        table = self.current_table
        if not table:
            QMessageBox.warning(self, "æœªé€‰æ‹©è¡¨", "è¯·å…ˆé€‰æ‹©è¦ç®¡ç†ç»“æ„çš„è¡¨")
            return
        dlg = QDialog(self)
        dlg.setWindowTitle(f"è¡¨ç»“æ„ç®¡ç† - {table}")
        vbox = QVBoxLayout(dlg)
        # å­—æ®µæ³¨é‡ŠåŠ è½½
        comment_path = os.path.join(os.path.dirname(
            __file__), 'db_field_comments.json')
        comments = {}
        if os.path.exists(comment_path):
            try:
                with open(comment_path, 'r', encoding='utf-8') as f:
                    comments = json.load(f)
            except Exception:
                comments = {}
        if table not in comments:
            comments[table] = {}
        # å­—æ®µåˆ—è¡¨
        field_list = QListWidget()
        model = QSqlTableModel(self, self.db)
        model.setTable(table)
        model.select()
        for col in range(model.columnCount()):
            name = model.headerData(col, Qt.Horizontal)
            comment = comments[table].get(name, "")
            field_list.addItem(f"{name}  # {comment}" if comment else name)
        vbox.addWidget(QLabel("å­—æ®µåˆ—è¡¨ï¼š"))
        vbox.addWidget(field_list)
        # å­—æ®µæ“ä½œ
        add_btn = QPushButton("æ–°å¢å­—æ®µ")
        del_btn = QPushButton("åˆ é™¤å­—æ®µ")
        type_btn = QPushButton("ä¿®æ”¹ç±»å‹")
        comment_btn = QPushButton("ç¼–è¾‘æ³¨é‡Š")
        vbox.addWidget(add_btn)
        vbox.addWidget(del_btn)
        vbox.addWidget(type_btn)
        vbox.addWidget(comment_btn)

        drop_table_btn = QPushButton("åˆ é™¤æ•´è¡¨")
        vbox.addWidget(drop_table_btn)

        def add_field():
            name, ok = QInputDialog.getText(dlg, "æ–°å¢å­—æ®µ", "å­—æ®µåï¼š")
            if not ok or not name:
                return
            ftype, ok = QInputDialog.getText(
                dlg, "å­—æ®µç±»å‹", "ç±»å‹(å¦‚ TEXT, INTEGER, REAL)ï¼š")
            if not ok or not ftype:
                return
            sql = f"ALTER TABLE {table} ADD COLUMN {name} {ftype}"
            try:
                self.db.exec(sql)
                QMessageBox.information(dlg, "æˆåŠŸ", f"å·²æ·»åŠ å­—æ®µ {name}")
                self.refresh_table()
                field_list.addItem(name)
            except Exception as e:
                QMessageBox.warning(dlg, "å¤±è´¥", str(e))

        def del_field():
            item = field_list.currentItem()
            if not item:
                return
            name = item.text().split('  #')[0]
            QMessageBox.information(
                dlg, "æç¤º", f"SQLiteä¸æ”¯æŒç›´æ¥åˆ é™¤å­—æ®µï¼Œè¯·ç”¨å¯¼å‡º-é‡å»ºè¡¨-å¯¼å…¥æ•°æ®æ–¹å¼å®ç°ã€‚")

        def change_type():
            item = field_list.currentItem()
            if not item:
                return
            name = item.text().split('  #')[0]
            ftype, ok = QInputDialog.getText(
                dlg, "ä¿®æ”¹ç±»å‹", f"å­—æ®µ {name} æ–°ç±»å‹ï¼š")
            if not ok or not ftype:
                return
            QMessageBox.information(dlg, "æç¤º", "SQLiteä¸æ”¯æŒç›´æ¥ä¿®æ”¹å­—æ®µç±»å‹ï¼Œè¯·ç”¨å¯¼å‡º-é‡å»ºè¡¨-å¯¼å…¥æ•°æ®æ–¹å¼å®ç°ã€‚")

        def drop_table():
            reply = QMessageBox.question(
                dlg, "ç¡®è®¤åˆ é™¤",
                f"ç¡®å®šè¦åˆ é™¤æ•´å¼ è¡¨ {table} å—ï¼Ÿè¯¥æ“ä½œä¸å¯æ¢å¤ï¼",
                QMessageBox.Yes | QMessageBox.No,
                QMessageBox.No
            )
            if reply != QMessageBox.Yes:
                return
            try:
                # å…³é—­å¯èƒ½çš„å¤–é”®çº¦æŸå½±å“
                self.db.exec("PRAGMA foreign_keys = OFF;")
                self.db.exec(f"DROP TABLE IF EXISTS {table};")
                self.db.exec("PRAGMA foreign_keys = ON;")
                QMessageBox.information(dlg, "æˆåŠŸ", f"å·²åˆ é™¤è¡¨ {table}")
                self.refresh_table()
                dlg.accept()
            except Exception as e:
                QMessageBox.critical(dlg, "åˆ é™¤å¤±è´¥", str(e))

        def edit_comment():
            item = field_list.currentItem()
            if not item:
                return
            name = item.text().split('  #')[0]
            old_comment = comments[table].get(name, "")
            new_comment, ok = QInputDialog.getText(
                dlg, "ç¼–è¾‘æ³¨é‡Š", f"å­—æ®µ {name} æ³¨é‡Šï¼š", text=old_comment)
            if not ok:
                return
            comments[table][name] = new_comment
            with open(comment_path, 'w', encoding='utf-8') as f:
                json.dump(comments, f, ensure_ascii=False, indent=2)
            # åˆ·æ–°æ˜¾ç¤º
            field_list.clear()
            for col in range(model.columnCount()):
                fname = model.headerData(col, Qt.Horizontal)
                cmt = comments[table].get(fname, "")
                field_list.addItem(f"{fname}  # {cmt}" if cmt else fname)
        add_btn.clicked.connect(add_field)
        del_btn.clicked.connect(del_field)
        type_btn.clicked.connect(change_type)
        comment_btn.clicked.connect(edit_comment)
        drop_table_btn.clicked.connect(drop_table)

        dlg.exec_()

    def show_table_stats(self):
        table = self.current_table
        if not table:
            QMessageBox.warning(self, "æœªé€‰æ‹©è¡¨", "è¯·å…ˆé€‰æ‹©è¦ç»Ÿè®¡çš„è¡¨")
            return
        dlg = QDialog(self)
        dlg.setWindowTitle(f"æ•°æ®ç»Ÿè®¡ - {table}")
        vbox = QVBoxLayout(dlg)
        model = QSqlTableModel(self, self.db)
        model.setTable(table)
        model.select()
        row_count = model.rowCount()
        vbox.addWidget(QLabel(f"è¡Œæ•°ï¼š{row_count}"))
        for col in range(model.columnCount()):
            name = model.headerData(col, Qt.Horizontal)
            values = set()
            for row in range(row_count):
                values.add(str(model.data(model.index(row, col))))
            vbox.addWidget(QLabel(f"å­—æ®µ {name} - å”¯ä¸€å€¼: {len(values)}"))
        dlg.exec_()

    def switch_language(self, lang):
        # ç®€å•å®ç°ï¼šæŒ‰é’®ã€æ ‡ç­¾ã€æç¤ºç­‰ä¸­è‹±æ–‡åˆ‡æ¢
        zh = lang == "ä¸­æ–‡"
        self.add_btn.setText("æ–°å¢" if zh else "Add")
        self.del_btn.setText("åˆ é™¤" if zh else "Delete")
        self.save_btn.setText("ä¿å­˜ä¿®æ”¹" if zh else "Save")
        self.import_btn.setText("å¯¼å…¥CSV" if zh else "Import CSV")
        self.export_btn.setText("å¯¼å‡ºCSV" if zh else "Export CSV")
        self.batch_btn.setText("æ‰¹é‡ä¿®æ”¹" if zh else "Batch Edit")
        self.log_btn.setText("æƒé™å˜æ›´æ—¥å¿—" if zh else "Perm Log")
        self.perm_btn.setText("å­—æ®µæƒé™ç®¡ç†" if zh else "Field Perm")
        self.upload_btn.setText("ä¼ æƒé™åˆ°äº‘" if zh else "Upload Perm")
        self.download_btn.setText("äº‘ç«¯æ‹‰å–æƒ" if zh else "Download Perm")
        self.schema_btn.setText("è¡¨ç»“æ„ç®¡ç†" if zh else "Schema")
        self.stats_btn.setText("æ•°æ®ç»Ÿè®¡" if zh else "Stats")
        self.page_label.setText(self.page_label.text().replace("é¡µ", "Page").replace("å…±", "Total").replace(
            "è¡Œ", "Rows") if not zh else self.page_label.text().replace("Page", "é¡µ").replace("Total", "å…±").replace("Rows", "è¡Œ"))

    def _create_database_connection_panel(self, main_layout):
        """åˆ›å»ºæ•°æ®åº“è¿æ¥é¢æ¿ - ä¸“ä¸šç´§å‡‘çš„å¸ƒå±€"""
        from PyQt5.QtWidgets import QGroupBox, QGridLayout, QFrame

        # åˆ›å»ºç´§å‡‘çš„åˆ†ç»„æ¡†
        db_group = QGroupBox("æ•°æ®åº“è¿æ¥ç®¡ç†")
        db_group.setFixedHeight(110)
        db_group.setStyleSheet("""
            QGroupBox {
                font-weight: bold;
                border: 2px solid #cccccc;
                border-radius: 5px;
                margin-top: 1ex;
                padding-top: 10px;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                left: 10px;
                padding: 0 5px 0 5px;
            }
        """)

        # ä½¿ç”¨ç´§å‡‘çš„ç½‘æ ¼å¸ƒå±€
        db_layout = QGridLayout(db_group)
        db_layout.setSpacing(2)  # å‡å°‘é—´è·
        db_layout.setContentsMargins(15, 0, 15, 0)  # ç´§å‡‘çš„è¾¹è·

        # ç¬¬ä¸€è¡Œï¼šç±»å‹é€‰æ‹©å’Œè¿æ¥çŠ¶æ€ï¼ˆç´§å‡‘å¸ƒå±€ï¼‰
        type_label = QLabel("ç±»å‹:")
        type_label.setFixedWidth(40)
        db_layout.addWidget(type_label, 0, 0)

        self.db_type_combo = QComboBox()
        self.db_type_combo.addItems(["SQLite", "DuckDB"])
        self.db_type_combo.setFixedWidth(100)
        self.db_type_combo.currentTextChanged.connect(self._on_database_type_changed)
        db_layout.addWidget(self.db_type_combo, 0, 1)

        # è¿æ¥çŠ¶æ€æŒ‡ç¤ºå™¨
        status_label = QLabel("çŠ¶æ€:")
        status_label.setFixedWidth(30)
        db_layout.addWidget(status_label, 0, 2)

        self.current_db_label = QLabel(os.path.basename(self.selected_db_path) if self.selected_db_path else "æœªè¿æ¥")
        self.current_db_label.setStyleSheet("""
            QLabel {
                color: #2196F3;
                font-weight: bold;
                padding: 2px 6px;
                border: 1px solid #2196F3;
                border-radius: 3px;
                background-color: #E3F2FD;
            }
        """)
        self.current_db_label.setFixedWidth(180)
        db_layout.addWidget(self.current_db_label, 0, 3)

        # ç¬¬äºŒè¡Œï¼šæ–‡ä»¶é€‰æ‹©ï¼ˆå ç”¨æ›´å¤šç©ºé—´ï¼‰
        file_label = QLabel("æ–‡ä»¶:")
        file_label.setFixedWidth(30)
        db_layout.addWidget(file_label, 0, 4)

        self.db_file_combo = QComboBox()
        self.db_file_combo.setFixedWidth(500)
        self.db_file_combo.setEditable(False)
        self.db_file_combo.setStyleSheet("""
            QComboBox {
                padding: 4px;
                border: 1px solid #ddd;
                border-radius: 4px;
            }
        """)
        db_layout.addWidget(self.db_file_combo, 0, 5)
        # è¿æ¥æŒ‰é’®ï¼ˆçªå‡ºæ˜¾ç¤ºï¼‰
        self.connect_btn = QPushButton("è¿æ¥")
        self.connect_btn.setFixedWidth(150)
        self.connect_btn.clicked.connect(self._connect_to_selected_database)
        self.connect_btn.setStyleSheet("""
            QPushButton {
                background-color: #4CAF50;
                color: white;
                font-weight: bold;
                padding: 6px 12px;
                border: none;
                border-radius: 4px;
                min-width: 60px;
            }
            QPushButton:hover {
                background-color: #45a049;
            }
            QPushButton:pressed {
                background-color: #3d8b40;
            }
        """)
        db_layout.addWidget(self.connect_btn, 0, 6)

        # ç¬¬ä¸‰è¡Œï¼šæ“ä½œæŒ‰é’®ï¼ˆç´§å‡‘æ’åˆ—ï¼‰
        btn_frame = QFrame()
        btn_layout = QHBoxLayout(btn_frame)
        btn_layout.setContentsMargins(0, 0, 0, 0)
        btn_layout.setSpacing(6)

        # æ‰«ææŒ‰é’®
        self.scan_btn = QPushButton("æ‰«æ")
        self.scan_btn.clicked.connect(self._scan_databases_async)
        self.scan_btn.setStyleSheet("""
            QPushButton {
                padding: 4px 8px;
                border: 1px solid #ddd;
                border-radius: 3px;
                background-color: #f8f9fa;
                min-width: 50px;
            }
            QPushButton:hover {
                background-color: #e9ecef;
            }
        """)
        btn_layout.addWidget(self.scan_btn)

        # æµè§ˆæŒ‰é’®
        self.browse_btn = QPushButton("æµè§ˆ")
        self.browse_btn.clicked.connect(self.browse_database_file)
        self.browse_btn.setStyleSheet(self.scan_btn.styleSheet())
        btn_layout.addWidget(self.browse_btn)

        # ç­›é€‰è¾“å…¥æ¡†
        self.filter_edit = QLineEdit()
        self.filter_edit.setPlaceholderText("ç­›é€‰æ–‡ä»¶...")
        self.filter_edit.textChanged.connect(self._filter_database_files)
        self.filter_edit.setStyleSheet("""
            QLineEdit {
                padding: 4px;
                border: 1px solid #ddd;
                border-radius: 3px;
                min-width: 120px;
            }
        """)
        btn_layout.addWidget(self.filter_edit)

        # åˆ·æ–°æŒ‰é’®
        self.refresh_btn = QPushButton("åˆ·æ–°")
        self.refresh_btn.clicked.connect(self._scan_databases_async)
        self.refresh_btn.setStyleSheet(self.scan_btn.styleSheet())
        btn_layout.addWidget(self.refresh_btn)

        btn_layout.addStretch()  # æ¨åˆ°å·¦è¾¹

        db_layout.addWidget(btn_frame, 2, 0, 1, 4)  # è·¨è¶Šæ‰€æœ‰åˆ—

        # è®¾ç½®åˆ—çš„æ‹‰ä¼¸æ¯”ä¾‹
        db_layout.setColumnStretch(1, 1)  # æ–‡ä»¶é€‰æ‹©æ¡†å¯æ‹‰ä¼¸
        db_layout.setColumnStretch(2, 1)  # çŠ¶æ€æ ‡ç­¾å¯æ‹‰ä¼¸

        main_layout.addWidget(db_group)

    def _connect_to_selected_database(self):
        """è¿æ¥åˆ°é€‰æ‹©çš„æ•°æ®åº“"""
        selected_path = None

        # è·å–é€‰æ‹©çš„è·¯å¾„
        if self.db_file_combo.currentData():
            selected_path = self.db_file_combo.currentData()
        elif self.db_file_combo.currentText():
            # å¦‚æœæ˜¯æ‰‹åŠ¨è¾“å…¥çš„è·¯å¾„
            input_path = self.db_file_combo.currentText()
            if os.path.exists(input_path):
                selected_path = input_path

        if not selected_path:
            QMessageBox.warning(self, "è­¦å‘Š", "è¯·é€‰æ‹©ä¸€ä¸ªæœ‰æ•ˆçš„æ•°æ®åº“æ–‡ä»¶")
            return

        try:
            # éªŒè¯æ•°æ®åº“æ–‡ä»¶
            if self.current_db_type == 'sqlite':
                if not self._is_sqlite_file(selected_path):
                    QMessageBox.warning(self, "é”™è¯¯", "é€‰æ‹©çš„æ–‡ä»¶ä¸æ˜¯æœ‰æ•ˆçš„SQLiteæ•°æ®åº“")
                    return
            else:
                if not self._is_duckdb_file(selected_path):
                    QMessageBox.warning(self, "é”™è¯¯", "é€‰æ‹©çš„æ–‡ä»¶ä¸æ˜¯æœ‰æ•ˆçš„DuckDBæ•°æ®åº“")
                    return

            # æ›´æ–°å½“å‰è¿æ¥
            self.selected_db_path = selected_path
            self.db_path = selected_path
            self.current_db_label.setText(os.path.basename(selected_path))

            # é‡æ–°è¿æ¥æ•°æ®åº“å¹¶åŠ è½½è¡¨åˆ—è¡¨
            self._reload_database_tables()

            QMessageBox.information(self, "æˆåŠŸ", f"å·²è¿æ¥åˆ°æ•°æ®åº“: {os.path.basename(selected_path)}")

        except Exception as e:
            QMessageBox.critical(self, "è¿æ¥å¤±è´¥", f"è¿æ¥æ•°æ®åº“å¤±è´¥: {str(e)}")

    def _reload_database_tables(self):
        """é‡æ–°è¿æ¥æ•°æ®åº“å¹¶åŠ è½½è¡¨åˆ—è¡¨ - æ”¯æŒ SQLite å’Œ DuckDB"""
        try:
            # æ¸…ç©ºå½“å‰è¡¨åˆ—è¡¨
            self.table_list.clear()

            if self.current_db_type == 'duckdb':
                # DuckDB å¤„ç†
                import duckdb
                conn = duckdb.connect(self.db_path)

                # è·å–è¡¨åˆ—è¡¨
                tables_result = conn.execute("SHOW TABLES").fetchall()
                tables = [table[0] for table in tables_result]

                # å­˜å‚¨ DuckDB è¿æ¥ä¾›åç»­ä½¿ç”¨
                self._duckdb_conn = conn

            else:
                # SQLite å¤„ç†ï¼ˆåŸæœ‰é€»è¾‘ï¼‰
                # å…³é—­å½“å‰æ•°æ®åº“è¿æ¥
                if hasattr(self, 'db') and self.db.isOpen():
                    self.db.close()

                # é‡æ–°è¿æ¥æ•°æ®åº“
                self.db.setDatabaseName(self.db_path)
                if not self.db.open():
                    raise Exception(f"æ— æ³•æ‰“å¼€æ•°æ®åº“: {self.db.lastError().text()}")

                # è·å–è¡¨åˆ—è¡¨
                tables = self.db.tables()

            # æ·»åŠ è¡¨åˆ°åˆ—è¡¨
            self.table_list.addItems(tables)

            # å¦‚æœæœ‰è¡¨ï¼Œé€‰æ‹©ç¬¬ä¸€ä¸ª
            if tables:
                self.table_list.setCurrentRow(0)
                first_item = self.table_list.item(0)
                if first_item:
                    self.load_table(first_item)

            # æ›´æ–°ä¸»é¢˜æç¤ºï¼ˆä»…å¯¹ SQLiteï¼‰
            if self.current_db_type == 'sqlite' and "themes" in tables:
                items = self.table_list.findItems("themes", Qt.MatchExactly)
                if items:
                    self.table_list.setCurrentItem(items[0])
                    self.load_table(items[0])
                    self.theme_hint.setText(
                        "â­ ä¸»é¢˜è¡¨(themes)ï¼šç”¨äºç®¡ç†UIä¸»é¢˜ï¼Œæ”¯æŒQSS/JSONç±»å‹ï¼Œå»ºè®®é€šè¿‡ä¸»é¢˜ç®¡ç†ç•Œé¢æ“ä½œã€‚å¯ç›´æ¥ç¼–è¾‘ã€å¯¼å…¥å¯¼å‡ºä¸»é¢˜å†…å®¹ã€‚\nå­—æ®µè¯´æ˜ï¼šname=ä¸»é¢˜åï¼Œtype=ç±»å‹(qss/json)ï¼Œcontent=å†…å®¹ï¼Œorigin=æ¥æºï¼Œcreated_at/updated_at=æ—¶é—´ã€‚\nå¦‚éœ€æ‰¹é‡å¯¼å…¥QSSä¸»é¢˜ï¼Œå¯å°†QSSæ–‡ä»¶æ”¾å…¥QSSThemeç›®å½•ï¼Œé‡å¯åè‡ªåŠ¨å¯¼å…¥ã€‚")
                    self.theme_hint.setVisible(True)
            else:
                self.theme_hint.setVisible(False)

        except Exception as e:
            QMessageBox.critical(self, "é”™è¯¯", f"é‡æ–°åŠ è½½æ•°æ®åº“è¡¨å¤±è´¥: {str(e)}")

    def load_table(self, item):
        """åŠ è½½è¡¨æ•°æ® - æ”¯æŒ SQLite å’Œ DuckDB"""
        if not item:
            return

        table_name = item.text()
        self.current_table = table_name

        try:
            if self.current_db_type == 'duckdb':
                # DuckDB å¤„ç†
                if hasattr(self, '_duckdb_conn'):
                    # è·å–è¡¨ç»“æ„
                    schema_result = self._duckdb_conn.execute(f"DESCRIBE {table_name}").fetchall()

                    # è·å–æ•°æ®ï¼ˆåˆ†é¡µï¼‰
                    offset = self.current_page * self.page_size
                    data_result = self._duckdb_conn.execute(
                        f"SELECT * FROM {table_name} LIMIT {self.page_size} OFFSET {offset}"
                    ).fetchall()

                    # è·å–æ€»è¡Œæ•°
                    count_result = self._duckdb_conn.execute(f"SELECT COUNT(*) FROM {table_name}").fetchone()
                    total_rows = count_result[0] if count_result else 0

                    # åˆ›å»ºè‡ªå®šä¹‰æ¨¡å‹æ˜¾ç¤ºæ•°æ®
                    self._create_duckdb_table_model(schema_result, data_result, total_rows)

            else:
                # SQLite å¤„ç†ï¼ˆåŸæœ‰é€»è¾‘ï¼‰
                if hasattr(self, 'model'):
                    self.model.deleteLater()

                self.model = QSqlTableModel(self, self.db)
                self.model.setTable(table_name)
                self.model.setEditStrategy(QSqlTableModel.OnManualSubmit)
                self.model.select()

                self.table_view.setModel(self.model)

                # æ›´æ–°åˆ†é¡µä¿¡æ¯
                total_rows = self.model.rowCount()

            # æ›´æ–°é¡µé¢ä¿¡æ¯
            total_pages = (total_rows + self.page_size - 1) // self.page_size
            self.page_label.setText(f"ç¬¬ {self.current_page + 1} é¡µï¼Œå…± {total_pages} é¡µï¼Œæ€»è®¡ {total_rows} è¡Œ")

            # æ›´æ–°æŒ‰é’®çŠ¶æ€
            self.prev_btn.setEnabled(self.current_page > 0)
            self.next_btn.setEnabled(self.current_page < total_pages - 1)

        except Exception as e:
            QMessageBox.critical(self, "é”™è¯¯", f"åŠ è½½è¡¨ {table_name} å¤±è´¥: {str(e)}")

    def _create_duckdb_table_model(self, schema_result, data_result, total_rows):
        """ä¸º DuckDB åˆ›å»ºè‡ªå®šä¹‰è¡¨æ¨¡å‹"""

        class DuckDBTableModel(QAbstractTableModel):
            def __init__(self, schema, data, parent=None):
                super().__init__(parent)
                self.schema = schema  # [(column_name, data_type, null, key, default, extra), ...]
                self.data = data
                self.headers = [col[0] for col in schema]

            def rowCount(self, parent=None):
                return len(self.data)

            def columnCount(self, parent=None):
                return len(self.headers)

            def data(self, index, role=Qt.DisplayRole):
                if not index.isValid():
                    return QVariant()

                if role == Qt.DisplayRole:
                    return str(self.data[index.row()][index.column()])

                return QVariant()

            def headerData(self, section, orientation, role=Qt.DisplayRole):
                if role == Qt.DisplayRole and orientation == Qt.Horizontal:
                    return self.headers[section]
                return QVariant()

        # åˆ›å»ºå¹¶è®¾ç½®æ¨¡å‹
        if hasattr(self, 'model'):
            self.model.deleteLater()

        self.model = DuckDBTableModel(schema_result, data_result)
        self.table_view.setModel(self.model)

    def _filter_database_files(self):
        """ç­›é€‰æ•°æ®åº“æ–‡ä»¶"""
        filter_text = self.filter_edit.text().lower()

        # æ¸…ç©ºå½“å‰åˆ—è¡¨
        self.db_file_combo.clear()

        # æ ¹æ®ç­›é€‰æ¡ä»¶æ·»åŠ æ–‡ä»¶
        db_type = self.current_db_type
        if db_type in self.available_databases:
            for db_info in self.available_databases[db_type]:
                if not filter_text or filter_text in db_info['name'].lower():
                    display_text = f"{db_info['name']} ({db_info['size']}) - {os.path.dirname(db_info['path'])}"
                    self.db_file_combo.addItem(display_text, db_info['path'])

    def _scan_databases_async(self):
        """å¼‚æ­¥æ‰«ædbç›®å½•ä¸­çš„æ•°æ®åº“æ–‡ä»¶"""
        from PyQt5.QtCore import QThread, pyqtSignal

        # å¦‚æœå·²æœ‰æ‰«æçº¿ç¨‹åœ¨è¿è¡Œï¼Œå…ˆåœæ­¢
        if hasattr(self, '_scan_thread') and self._scan_thread.isRunning():
            return

        # ç¦ç”¨æ‰«ææŒ‰é’®
        self.scan_btn.setEnabled(False)
        self.refresh_btn.setEnabled(False)
        self.scan_btn.setText("æ‰«æä¸­...")

        # åˆ›å»ºæ‰«æçº¿ç¨‹
        self._scan_thread = DatabaseScanThread()
        self._scan_thread.scan_completed.connect(self._on_scan_completed)
        self._scan_thread.scan_error.connect(self._on_scan_error)
        self._scan_thread.start()

    def _on_scan_completed(self, databases):
        """æ‰«æå®Œæˆå›è°ƒ"""
        self.available_databases = databases
        self.update_database_file_list()

        # æ¢å¤æŒ‰é’®çŠ¶æ€
        self.scan_btn.setEnabled(True)
        self.refresh_btn.setEnabled(True)
        self.scan_btn.setText("æ‰«æ")

        # æ˜¾ç¤ºæ‰«æç»“æœ
        sqlite_count = len(databases['sqlite'])
        duckdb_count = len(databases['duckdb'])
        QMessageBox.information(self, "æ‰«æå®Œæˆ",
                                f"åœ¨dbç›®å½•ä¸­æ‰¾åˆ°:\n"
                                f"SQLiteæ–‡ä»¶: {sqlite_count} ä¸ª\n"
                                f"DuckDBæ–‡ä»¶: {duckdb_count} ä¸ª")

    def _on_scan_error(self, error_msg):
        """æ‰«æé”™è¯¯å›è°ƒ"""
        # æ¢å¤æŒ‰é’®çŠ¶æ€
        self.scan_btn.setEnabled(True)
        self.refresh_btn.setEnabled(True)
        self.scan_btn.setText("æ‰«æ")

        QMessageBox.warning(self, "æ‰«æå¤±è´¥", f"æ‰«ææ•°æ®åº“æ–‡ä»¶æ—¶å‡ºé”™:\n{error_msg}")

    def scan_system_databases(self):
        """ä¿æŒå‘åå…¼å®¹çš„åŒæ­¥æ‰«ææ–¹æ³•"""
        self._scan_databases_async()

    def _is_sqlite_file(self, file_path):
        """æ£€æŸ¥æ–‡ä»¶æ˜¯å¦ä¸ºæœ‰æ•ˆçš„SQLiteæ•°æ®åº“"""
        try:
            import sqlite3
            conn = sqlite3.connect(file_path)
            cursor = conn.cursor()
            cursor.execute("SELECT name FROM sqlite_master WHERE type='table';")
            conn.close()
            return True
        except Exception:
            return False

    def _is_duckdb_file(self, file_path):
        """æ£€æŸ¥æ–‡ä»¶æ˜¯å¦ä¸ºæœ‰æ•ˆçš„DuckDBæ•°æ®åº“"""
        try:
            import duckdb
            conn = duckdb.connect(file_path)
            conn.execute("SHOW TABLES;")
            conn.close()
            return True
        except Exception:
            return False

    def _format_file_size(self, size_bytes):
        """æ ¼å¼åŒ–æ–‡ä»¶å¤§å°"""
        if size_bytes < 1024:
            return f"{size_bytes} B"
        elif size_bytes < 1024 * 1024:
            return f"{size_bytes / 1024:.1f} KB"
        elif size_bytes < 1024 * 1024 * 1024:
            return f"{size_bytes / (1024 * 1024):.1f} MB"
        else:
            return f"{size_bytes / (1024 * 1024 * 1024):.1f} GB"

    def update_database_file_list(self):
        """æ›´æ–°æ•°æ®åº“æ–‡ä»¶åˆ—è¡¨"""
        if not hasattr(self, 'db_file_combo'):
            return

        self.db_file_combo.clear()

        # æ ¹æ®å½“å‰é€‰æ‹©çš„æ•°æ®åº“ç±»å‹æ˜¾ç¤ºæ–‡ä»¶
        db_type = self.current_db_type
        if db_type in self.available_databases:
            for db_info in self.available_databases[db_type]:
                display_text = f"{db_info['name']} ({db_info['size']}) - {os.path.dirname(db_info['path'])}"
                self.db_file_combo.addItem(display_text, db_info['path'])

        # åº”ç”¨å½“å‰çš„ç­›é€‰æ¡ä»¶
        if hasattr(self, 'filter_edit') and self.filter_edit.text():
            self._filter_database_files()

    def _on_database_type_changed(self, type_text):
        """æ•°æ®åº“ç±»å‹åˆ‡æ¢å¤„ç†"""
        self.current_db_type = 'sqlite' if type_text == 'SQLite' else 'duckdb'
        self.update_database_file_list()

    def browse_database_file(self):
        """æµè§ˆé€‰æ‹©æ•°æ®åº“æ–‡ä»¶"""
        from PyQt5.QtWidgets import QFileDialog

        if self.current_db_type == 'sqlite':
            file_filter = "SQLiteæ•°æ®åº“ (*.db *.sqlite *.sqlite3);;æ‰€æœ‰æ–‡ä»¶ (*.*)"
        else:
            file_filter = "DuckDBæ•°æ®åº“ (*.duckdb);;æ‰€æœ‰æ–‡ä»¶ (*.*)"

        file_path, _ = QFileDialog.getOpenFileName(
            self, "é€‰æ‹©æ•°æ®åº“æ–‡ä»¶", "", file_filter
        )

        if file_path:
            # æ·»åŠ åˆ°å¯¹åº”ç±»å‹çš„åˆ—è¡¨ä¸­
            file_size = os.path.getsize(file_path)
            db_info = {
                'path': file_path,
                'name': os.path.basename(file_path),
                'size': self._format_file_size(file_size)
            }

            # æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨
            existing_paths = [db['path'] for db in self.available_databases[self.current_db_type]]
            if file_path not in existing_paths:
                self.available_databases[self.current_db_type].append(db_info)
                self.update_database_file_list()

            # é€‰ä¸­æ–°æ·»åŠ çš„æ–‡ä»¶
            for i in range(self.db_file_combo.count()):
                if self.db_file_combo.itemData(i) == file_path:
                    self.db_file_combo.setCurrentIndex(i)
                    break

    def show_slow_queries(self):
        """æ˜¾ç¤ºæ…¢SQLè®°å½•"""
        from PyQt5.QtWidgets import QDialog, QVBoxLayout, QTextEdit, QPushButton, QHBoxLayout, QLabel

        dialog = QDialog(self)
        dialog.setWindowTitle("æ…¢SQLè®°å½•")
        dialog.resize(800, 600)

        layout = QVBoxLayout(dialog)

        # ç»Ÿè®¡ä¿¡æ¯
        stats_label = QLabel(f"æ…¢æŸ¥è¯¢é˜ˆå€¼: {self.slow_query_threshold}ms | è®°å½•æ•°é‡: {len(self.slow_queries)}")
        layout.addWidget(stats_label)

        # æ…¢æŸ¥è¯¢åˆ—è¡¨
        text_edit = QTextEdit()
        text_edit.setReadOnly(True)

        if not self.slow_queries:
            text_edit.setPlainText("æš‚æ— æ…¢æŸ¥è¯¢è®°å½•")
        else:
            content = []
            for i, query_info in enumerate(self.slow_queries, 1):
                content.append(f"=== æ…¢æŸ¥è¯¢ #{i} ===")
                content.append(f"æ—¶é—´: {query_info['timestamp']}")
                content.append(f"è€—æ—¶: {query_info['duration']}ms")
                content.append(f"SQL: {query_info['sql']}")
                if query_info.get('error'):
                    content.append(f"é”™è¯¯: {query_info['error']}")
                content.append("")

            text_edit.setPlainText("\n".join(content))

        layout.addWidget(text_edit)

        # æŒ‰é’®åŒºåŸŸ
        btn_layout = QHBoxLayout()

        clear_btn = QPushButton("æ¸…ç©ºè®°å½•")
        clear_btn.clicked.connect(lambda: self._clear_slow_queries(text_edit, stats_label))
        btn_layout.addWidget(clear_btn)

        export_btn = QPushButton("å¯¼å‡ºè®°å½•")
        export_btn.clicked.connect(lambda: self._export_slow_queries())
        btn_layout.addWidget(export_btn)

        btn_layout.addStretch()

        close_btn = QPushButton("å…³é—­")
        close_btn.clicked.connect(dialog.accept)
        btn_layout.addWidget(close_btn)

        layout.addLayout(btn_layout)

        dialog.exec_()

    def toggle_edit_mode(self):
        """åˆ‡æ¢ç¼–è¾‘æ¨¡å¼"""
        try:
            if hasattr(self, 'model') and self.model:
                # æ£€æŸ¥å½“å‰æ˜¯å¦å¤„äºç¼–è¾‘æ¨¡å¼
                current_strategy = self.model.editStrategy()

                if current_strategy == QSqlTableModel.OnManualSubmit:
                    # å½“å‰æ˜¯æ‰‹åŠ¨æäº¤æ¨¡å¼ï¼Œåˆ‡æ¢åˆ°è‡ªåŠ¨æäº¤
                    self.model.setEditStrategy(QSqlTableModel.OnFieldChange)
                    self.edit_btn.setText("ğŸ”’ é”å®šç¼–è¾‘")
                    QMessageBox.information(self, "ç¼–è¾‘æ¨¡å¼", "å·²å¯ç”¨è‡ªåŠ¨ç¼–è¾‘æ¨¡å¼")
                else:
                    # å½“å‰æ˜¯è‡ªåŠ¨æäº¤æ¨¡å¼ï¼Œåˆ‡æ¢åˆ°æ‰‹åŠ¨æäº¤
                    self.model.setEditStrategy(QSqlTableModel.OnManualSubmit)
                    self.edit_btn.setText("âœï¸ ç¼–è¾‘")
                    QMessageBox.information(self, "ç¼–è¾‘æ¨¡å¼", "å·²åˆ‡æ¢åˆ°æ‰‹åŠ¨æäº¤æ¨¡å¼")
            else:
                QMessageBox.warning(self, "è­¦å‘Š", "è¯·å…ˆé€‰æ‹©ä¸€ä¸ªè¡¨")
        except Exception as e:
            QMessageBox.critical(self, "é”™è¯¯", f"åˆ‡æ¢ç¼–è¾‘æ¨¡å¼å¤±è´¥: {str(e)}")

    def _clear_slow_queries(self, text_edit, stats_label):
        """æ¸…ç©ºæ…¢æŸ¥è¯¢è®°å½•"""
        self.slow_queries.clear()
        text_edit.setPlainText("æš‚æ— æ…¢æŸ¥è¯¢è®°å½•")
        stats_label.setText(f"æ…¢æŸ¥è¯¢é˜ˆå€¼: {self.slow_query_threshold}ms | è®°å½•æ•°é‡: 0")

    def _export_slow_queries(self):
        """å¯¼å‡ºæ…¢æŸ¥è¯¢è®°å½•"""
        from PyQt5.QtWidgets import QFileDialog
        import json

        if not self.slow_queries:
            QMessageBox.information(self, "æç¤º", "æš‚æ— æ…¢æŸ¥è¯¢è®°å½•å¯å¯¼å‡º")
            return

        file_path, _ = QFileDialog.getSaveFileName(
            self, "å¯¼å‡ºæ…¢æŸ¥è¯¢è®°å½•", f"slow_queries_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json",
            "JSONæ–‡ä»¶ (*.json);;æ–‡æœ¬æ–‡ä»¶ (*.txt)"
        )

        if file_path:
            try:
                with open(file_path, 'w', encoding='utf-8') as f:
                    if file_path.endswith('.json'):
                        json.dump(self.slow_queries, f, ensure_ascii=False, indent=2)
                    else:
                        for i, query_info in enumerate(self.slow_queries, 1):
                            f.write(f"=== æ…¢æŸ¥è¯¢ #{i} ===\n")
                            f.write(f"æ—¶é—´: {query_info['timestamp']}\n")
                            f.write(f"è€—æ—¶: {query_info['duration']}ms\n")
                            f.write(f"SQL: {query_info['sql']}\n")
                            if query_info.get('error'):
                                f.write(f"é”™è¯¯: {query_info['error']}\n")
                            f.write("\n")

                QMessageBox.information(self, "æˆåŠŸ", f"æ…¢æŸ¥è¯¢è®°å½•å·²å¯¼å‡ºåˆ°: {file_path}")
            except Exception as e:
                QMessageBox.warning(self, "é”™è¯¯", f"å¯¼å‡ºå¤±è´¥: {str(e)}")

    def record_slow_query(self, sql, duration, error=None):
        """è®°å½•æ…¢æŸ¥è¯¢"""
        if duration >= self.slow_query_threshold:
            query_info = {
                'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                'sql': sql,
                'duration': duration,
                'error': error
            }
            self.slow_queries.append(query_info)

            # é™åˆ¶è®°å½•æ•°é‡ï¼Œé¿å…å†…å­˜å ç”¨è¿‡å¤§
            if len(self.slow_queries) > 1000:
                self.slow_queries = self.slow_queries[-500:]  # ä¿ç•™æœ€è¿‘500æ¡

    def closeEvent(self, event):
        """å¯¹è¯æ¡†å…³é—­äº‹ä»¶å¤„ç†"""
        try:
            # é¦–å…ˆæ¸…ç†æ‰€æœ‰ä½¿ç”¨æ•°æ®åº“è¿æ¥çš„å¯¹è±¡
            if hasattr(self, 'model') and self.model:
                # æ¸…ç† QSqlTableModel
                self.model.clear()
                self.table_view.setModel(None)
                self.model.deleteLater()
                self.model = None

            # å…³é—­æ•°æ®åº“è¿æ¥
            if hasattr(self, 'db') and self.db and self.db.isOpen():
                self.db.close()

            # ç§»é™¤æ•°æ®åº“è¿æ¥ï¼ˆä½¿ç”¨å”¯ä¸€çš„è¿æ¥åç§°ï¼‰
            if hasattr(self, 'connection_name') and QSqlDatabase.contains(self.connection_name):
                QSqlDatabase.removeDatabase(self.connection_name)

            print(f"æ•°æ®åº“è¿æ¥ {getattr(self, 'connection_name', 'unknown')} å·²æ­£ç¡®æ¸…ç†")

        except Exception as e:
            print(f"å…³é—­æ•°æ®åº“è¿æ¥æ—¶å‡ºé”™: {e}")

        # è°ƒç”¨çˆ¶ç±»çš„å…³é—­äº‹ä»¶
        super().closeEvent(event)
