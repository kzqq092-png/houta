# è‡ªåŠ¨åŒ–æµ‹è¯•ç®¡ç†æŠ€æœ¯æŒ‡å—

## ğŸ“‹ æ¦‚è¿°

æœ¬æŒ‡å—æä¾›HIkyuué‡åŒ–äº¤æ˜“ç³»ç»Ÿçš„å®Œæ•´è‡ªåŠ¨åŒ–æµ‹è¯•è§£å†³æ–¹æ¡ˆï¼Œæ¶µç›–æµ‹è¯•ç¯å¢ƒé…ç½®ã€åˆ†é˜¶æ®µæµ‹è¯•æ‰§è¡Œã€é”™è¯¯å¤„ç†å’Œæ•°æ®ç®¡ç†ç­‰æ ¸å¿ƒåŠŸèƒ½ã€‚

## ğŸ—ï¸ æµ‹è¯•æ¶æ„è®¾è®¡

### æ ¸å¿ƒæµ‹è¯•æ¡†æ¶

```python
class PhaseTestRunner:
    def __init__(self):
        self.phases = [
            Phase1_DatabaseStructure(),
            Phase2_API_Functionality(),
            Phase3_DecimalPrecision(),
            Phase4_TET_Framework()
        ]
        self.results = {}
    
    async def run_all_phases(self) -> TestResult:
        """è¿è¡Œæ‰€æœ‰æµ‹è¯•é˜¶æ®µ"""
        logger.info("=" * 60)
        logger.info("å¼€å§‹æ‰§è¡Œå…¨é¢æµ‹è¯•")
        logger.info("=" * 60)
        
        for i, phase in enumerate(self.phases, 1):
            try:
                logger.info(f"Phase {i}: {phase.name}")
                result = await phase.execute()
                self.results[f"phase_{i}"] = result
                
                if result.success:
                    logger.info(f"[OK] {phase.name} é€šè¿‡")
                else:
                    logger.error(f"[FAIL] {phase.name} å¤±è´¥: {result.error}")
                
            except Exception as e:
                logger.error(f"[FAIL] Phase {i} æ‰§è¡Œå¼‚å¸¸: {e}")
                self.results[f"phase_{i}"] = TestResult(False, str(e))
        
        return self._aggregate_results()
```

## ğŸ”§ æµ‹è¯•ç¯å¢ƒé…ç½®

### ç¯å¢ƒåˆå§‹åŒ–

```python
class TestEnvironmentManager:
    """æµ‹è¯•ç¯å¢ƒç®¡ç†å™¨"""
    
    def __init__(self):
        self.config = self._load_test_config()
        self.database_url = self.config.get('test_database_url')
        self.mock_services = {}
    
    async def setup_test_environment(self):
        """è®¾ç½®æµ‹è¯•ç¯å¢ƒ"""
        try:
            # åˆå§‹åŒ–æµ‹è¯•æ•°æ®åº“
            await self._init_test_database()
            
            # å¯åŠ¨æ¨¡æ‹ŸæœåŠ¡
            await self._start_mock_services()
            
            # åŠ è½½æµ‹è¯•æ•°æ®
            await self._load_test_data()
            
            logger.info("æµ‹è¯•ç¯å¢ƒåˆå§‹åŒ–å®Œæˆ")
            
        except Exception as e:
            logger.error(f"æµ‹è¯•ç¯å¢ƒè®¾ç½®å¤±è´¥: {e}")
            raise TestEnvironmentError(f"ç¯å¢ƒè®¾ç½®å¤±è´¥: {e}")
    
    def _load_test_config(self) -> dict:
        """åŠ è½½æµ‹è¯•é…ç½®"""
        return {
            'test_database_url': 'postgresql://test_user:test_pass@localhost:5432/hikyuu_test',
            'mock_api_port': 8081,
            'test_timeout': 30,
            'parallel_execution': True,
            'test_data_retention_days': 7
        }
```

## ğŸ“Š åˆ†é˜¶æ®µæµ‹è¯•æ‰§è¡Œ

### Phase 1: æ•°æ®åº“ç»“æ„æµ‹è¯•

```python
class Phase1_DatabaseStructure:
    """ç¬¬ä¸€é˜¶æ®µï¼šæ•°æ®åº“ç»“æ„æµ‹è¯•"""
    
    def __init__(self):
        self.name = "æ•°æ®åº“ç»“æ„æµ‹è¯•"
        self.required_tables = [
            'users', 'strategies', 'positions', 'orders', 
            'market_data', 'performance_metrics'
        ]
    
    async def execute(self) -> TestResult:
        """æ‰§è¡Œæ•°æ®åº“ç»“æ„æµ‹è¯•"""
        try:
            # éªŒè¯æ•°æ®åº“è¿æ¥
            db_connection = await self._test_database_connection()
            if not db_connection:
                return TestResult(False, "æ•°æ®åº“è¿æ¥å¤±è´¥")
            
            # éªŒè¯è¡¨ç»“æ„
            for table in self.required_tables:
                if not await self._verify_table_exists(table):
                    return TestResult(False, f"ç¼ºå°‘å¿…è¦çš„è¡¨: {table}")
            
            # éªŒè¯å­—æ®µç»“æ„
            schema_validation = await self._validate_schema()
            if not schema_validation:
                return TestResult(False, "æ•°æ®åº“æ¨¡å¼éªŒè¯å¤±è´¥")
            
            logger.info("æ•°æ®åº“ç»“æ„æµ‹è¯•é€šè¿‡")
            return TestResult(True, "æ•°æ®åº“ç»“æ„éªŒè¯æˆåŠŸ")
            
        except Exception as e:
            return TestResult(False, f"æ•°æ®åº“ç»“æ„æµ‹è¯•å¼‚å¸¸: {e}")
    
    async def _test_database_connection(self) -> bool:
        """æµ‹è¯•æ•°æ®åº“è¿æ¥"""
        try:
            # ä½¿ç”¨è¿æ¥æ± æµ‹è¯•è¿æ¥
            async with DatabaseManager().get_connection() as conn:
                await conn.execute("SELECT 1")
                return True
        except Exception as e:
            logger.error(f"æ•°æ®åº“è¿æ¥æµ‹è¯•å¤±è´¥: {e}")
            return False
```

### Phase 2: APIåŠŸèƒ½æµ‹è¯•

```python
class Phase2_API_Functionality:
    """ç¬¬äºŒé˜¶æ®µï¼šAPIåŠŸèƒ½æµ‹è¯•"""
    
    def __init__(self):
        self.name = "APIåŠŸèƒ½æµ‹è¯•"
        self.api_endpoints = [
            '/api/v1/market-data',
            '/api/v1/strategies',
            '/api/v1/orders',
            '/api/v1/positions'
        ]
    
    async def execute(self) -> TestResult:
        """æ‰§è¡ŒAPIåŠŸèƒ½æµ‹è¯•"""
        try:
            # æµ‹è¯•APIå¯ç”¨æ€§
            for endpoint in self.api_endpoints:
                response = await self._test_endpoint(endpoint)
                if not response:
                    return TestResult(False, f"APIç«¯ç‚¹ä¸å¯ç”¨: {endpoint}")
            
            # æµ‹è¯•APIå“åº”æ ¼å¼
            format_validation = await self._validate_response_format()
            if not format_validation:
                return TestResult(False, "APIå“åº”æ ¼å¼éªŒè¯å¤±è´¥")
            
            # æµ‹è¯•APIæ€§èƒ½
            performance_test = await self._test_api_performance()
            if not performance_test:
                return TestResult(False, "APIæ€§èƒ½æµ‹è¯•å¤±è´¥")
            
            logger.info("APIåŠŸèƒ½æµ‹è¯•é€šè¿‡")
            return TestResult(True, "APIåŠŸèƒ½éªŒè¯æˆåŠŸ")
            
        except Exception as e:
            return TestResult(False, f"APIåŠŸèƒ½æµ‹è¯•å¼‚å¸¸: {e}")
    
    async def _test_endpoint(self, endpoint: str) -> bool:
        """æµ‹è¯•å•ä¸ªAPIç«¯ç‚¹"""
        try:
            async with aiohttp.ClientSession() as session:
                async with session.get(f"http://localhost:8000{endpoint}") as response:
                    return response.status == 200
        except Exception:
            return False
```

### Phase 3: å°æ•°ç²¾åº¦æµ‹è¯•

```python
class Phase3_DecimalPrecision:
    """ç¬¬ä¸‰é˜¶æ®µï¼šå°æ•°ç²¾åº¦æµ‹è¯•"""
    
    def __init__(self):
        self.name = "å°æ•°ç²¾åº¦æµ‹è¯•"
        self.precision_configs = {
            'price_precision': 4,
            'quantity_precision': 6,
            'commission_precision': 8
        }
    
    async def execute(self) -> TestResult:
        """æ‰§è¡Œå°æ•°ç²¾åº¦æµ‹è¯•"""
        try:
            # æµ‹è¯•ä»·æ ¼ç²¾åº¦
            price_test = await self._test_price_precision()
            if not price_test:
                return TestResult(False, "ä»·æ ¼ç²¾åº¦æµ‹è¯•å¤±è´¥")
            
            # æµ‹è¯•æ•°é‡ç²¾åº¦
            quantity_test = await self._test_quantity_precision()
            if not quantity_test:
                return TestResult(False, "æ•°é‡ç²¾åº¦æµ‹è¯•å¤±è´¥")
            
            # æµ‹è¯•ä½£é‡‘ç²¾åº¦
            commission_test = await self._test_commission_precision()
            if not commission_test:
                return TestResult(False, "ä½£é‡‘ç²¾åº¦æµ‹è¯•å¤±è´¥")
            
            # æµ‹è¯•è®¡ç®—ç²¾åº¦
            calculation_test = await self._test_calculation_precision()
            if not calculation_test:
                return TestResult(False, "è®¡ç®—ç²¾åº¦æµ‹è¯•å¤±è´¥")
            
            logger.info("å°æ•°ç²¾åº¦æµ‹è¯•é€šè¿‡")
            return TestResult(True, "å°æ•°ç²¾åº¦éªŒè¯æˆåŠŸ")
            
        except Exception as e:
            return TestResult(False, f"å°æ•°ç²¾åº¦æµ‹è¯•å¼‚å¸¸: {e}")
    
    async def _test_price_precision(self) -> bool:
        """æµ‹è¯•ä»·æ ¼ç²¾åº¦"""
        test_cases = [
            (123.456789, 4),  # åº”è¯¥ä¿ç•™4ä½å°æ•°
            (0.123456789, 4), # åº”è¯¥ä¿ç•™4ä½å°æ•°
            (999.999999, 4)   # åº”è¯¥ä¿ç•™4ä½å°æ•°
        ]
        
        for value, expected_precision in test_cases:
            rounded_value = round(value, expected_precision)
            if len(str(rounded_value).split('.')[-1]) != expected_precision:
                return False
        
        return True
```

### Phase 4: TETæ¡†æ¶æµ‹è¯•

```python
class Phase4_TET_Framework:
    """ç¬¬å››é˜¶æ®µï¼šTETæ¡†æ¶æµ‹è¯•"""
    
    def __init__(self):
        self.name = "TETæ¡†æ¶æµ‹è¯•"
        self.framework_components = [
            'StrategyExecutor',
            'OrderManager',
            'RiskManager',
            'PerformanceTracker'
        ]
    
    async def execute(self) -> TestResult:
        """æ‰§è¡ŒTETæ¡†æ¶æµ‹è¯•"""
        try:
            # æµ‹è¯•ç»„ä»¶åŠ è½½
            for component in self.framework_components:
                if not await self._test_component_loading(component):
                    return TestResult(False, f"TETç»„ä»¶åŠ è½½å¤±è´¥: {component}")
            
            # æµ‹è¯•ç»„ä»¶äº¤äº’
            interaction_test = await self._test_component_interaction()
            if not interaction_test:
                return TestResult(False, "TETç»„ä»¶äº¤äº’æµ‹è¯•å¤±è´¥")
            
            # æµ‹è¯•æ¡†æ¶æ€§èƒ½
            performance_test = await self._test_framework_performance()
            if not performance_test:
                return TestResult(False, "TETæ¡†æ¶æ€§èƒ½æµ‹è¯•å¤±è´¥")
            
            logger.info("TETæ¡†æ¶æµ‹è¯•é€šè¿‡")
            return TestResult(True, "TETæ¡†æ¶éªŒè¯æˆåŠŸ")
            
        except Exception as e:
            return TestResult(False, f"TETæ¡†æ¶æµ‹è¯•å¼‚å¸¸: {e}")
    
    async def _test_component_loading(self, component: str) -> bool:
        """æµ‹è¯•ç»„ä»¶åŠ è½½"""
        try:
            component_class = self._get_component_class(component)
            if component_class is None:
                return False
            
            # æµ‹è¯•ç»„ä»¶å®ä¾‹åŒ–
            instance = component_class()
            return instance is not None
            
        except Exception:
            return False
```

## ğŸš¨ é”™è¯¯å¤„ç†æœºåˆ¶

### å¼‚å¸¸å¤„ç†ç­–ç•¥

```python
class TestErrorHandler:
    """æµ‹è¯•é”™è¯¯å¤„ç†å™¨"""
    
    def __init__(self):
        self.error_counts = {}
        self.retry_policies = {
            'database_error': {'max_retries': 3, 'backoff': 2},
            'api_error': {'max_retries': 5, 'backoff': 1},
            'timeout_error': {'max_retries': 2, 'backoff': 3}
        }
    
    async def handle_test_error(self, error: Exception, context: str) -> bool:
        """å¤„ç†æµ‹è¯•é”™è¯¯"""
        error_type = type(error).__name__
        
        # è®°å½•é”™è¯¯
        self._record_error(error_type, context)
        
        # æ ¹æ®é”™è¯¯ç±»å‹å†³å®šæ˜¯å¦é‡è¯•
        if error_type in self.retry_policies:
            return await self._retry_with_policy(error, context, error_type)
        
        # ä¸å¯é‡è¯•çš„é”™è¯¯
        logger.error(f"ä¸å¯é‡è¯•çš„é”™è¯¯ [{context}]: {error}")
        return False
    
    async def _retry_with_policy(self, error: Exception, context: str, error_type: str) -> bool:
        """æ ¹æ®ç­–ç•¥é‡è¯•"""
        policy = self.retry_policies[error_type]
        max_retries = policy['max_retries']
        backoff = policy['backoff']
        
        for attempt in range(max_retries):
            try:
                await asyncio.sleep(backoff ** attempt)
                logger.info(f"é‡è¯• [{context}] ç¬¬ {attempt + 1} æ¬¡")
                
                # æ‰§è¡Œé‡è¯•é€»è¾‘
                return await self._execute_retry_logic(context)
                
            except Exception as retry_error:
                logger.warning(f"é‡è¯•å¤±è´¥ [{context}] ç¬¬ {attempt + 1} æ¬¡: {retry_error}")
        
        logger.error(f"é‡è¯•è€—å°½ [{context}]: {error}")
        return False
```

## ğŸ“Š æµ‹è¯•æ•°æ®ç®¡ç†

### æµ‹è¯•æ•°æ®ç”Ÿæˆå™¨

```python
class TestDataGenerator:
    """æµ‹è¯•æ•°æ®ç”Ÿæˆå™¨"""
    
    def __init__(self):
        self.data_providers = {
            'market_data': self._generate_market_data,
            'user_data': self._generate_user_data,
            'strategy_data': self._generate_strategy_data,
            'order_data': self._generate_order_data
        }
    
    async def generate_test_dataset(self, dataset_size: int = 1000) -> dict:
        """ç”Ÿæˆæµ‹è¯•æ•°æ®é›†"""
        test_data = {}
        
        for data_type, generator in self.data_providers.items():
            try:
                test_data[data_type] = await generator(dataset_size)
                logger.info(f"ç”Ÿæˆ {data_type} æµ‹è¯•æ•°æ®: {len(test_data[data_type])} æ¡")
                
            except Exception as e:
                logger.error(f"ç”Ÿæˆ {data_type} æµ‹è¯•æ•°æ®å¤±è´¥: {e}")
                test_data[data_type] = []
        
        return test_data
    
    async def _generate_market_data(self, size: int) -> list:
        """ç”Ÿæˆå¸‚åœºæ•°æ®"""
        import random
        from datetime import datetime, timedelta
        
        market_data = []
        base_date = datetime.now() - timedelta(days=30)
        
        for i in range(size):
            data_point = {
                'timestamp': base_date + timedelta(minutes=i * 5),
                'symbol': f'STOCK_{i % 10}',
                'open_price': round(random.uniform(100, 200), 4),
                'high_price': round(random.uniform(200, 300), 4),
                'low_price': round(random.uniform(50, 100), 4),
                'close_price': round(random.uniform(100, 200), 4),
                'volume': random.randint(1000, 100000)
            }
            market_data.append(data_point)
        
        return market_data
```

## âš¡ æ€§èƒ½åŸºå‡†æµ‹è¯•

### æ€§èƒ½ç›‘æ§å™¨

```python
class PerformanceBenchmark:
    """æ€§èƒ½åŸºå‡†æµ‹è¯•å™¨"""
    
    def __init__(self):
        self.benchmarks = {
            'database_query': {'threshold': 100},  # ms
            'api_response': {'threshold': 200},     # ms
            'strategy_execution': {'threshold': 50}, # ms
            'order_processing': {'threshold': 10}   # ms
        }
    
    async def run_benchmarks(self) -> dict:
        """è¿è¡Œæ‰€æœ‰æ€§èƒ½åŸºå‡†æµ‹è¯•"""
        results = {}
        
        for test_name, config in self.benchmarks.items():
            try:
                result = await self._run_single_benchmark(test_name)
                results[test_name] = result
                
                if result['duration'] > config['threshold']:
                    logger.warning(f"æ€§èƒ½åŸºå‡†æµ‹è¯•è­¦å‘Š [{test_name}]: {result['duration']}ms > {config['threshold']}ms")
                else:
                    logger.info(f"æ€§èƒ½åŸºå‡†æµ‹è¯•é€šè¿‡ [{test_name}]: {result['duration']}ms")
                
            except Exception as e:
                logger.error(f"æ€§èƒ½åŸºå‡†æµ‹è¯•å¤±è´¥ [{test_name}]: {e}")
                results[test_name] = {'success': False, 'error': str(e)}
        
        return results
    
    async def _run_single_benchmark(self, test_name: str) -> dict:
        """è¿è¡Œå•ä¸ªæ€§èƒ½åŸºå‡†æµ‹è¯•"""
        start_time = time.time()
        
        try:
            if test_name == 'database_query':
                await self._benchmark_database_query()
            elif test_name == 'api_response':
                await self._benchmark_api_response()
            elif test_name == 'strategy_execution':
                await self._benchmark_strategy_execution()
            elif test_name == 'order_processing':
                await self._benchmark_order_processing()
            
            duration = (time.time() - start_time) * 1000  # è½¬æ¢ä¸ºæ¯«ç§’
            
            return {
                'success': True,
                'duration': duration,
                'threshold': self.benchmarks[test_name]['threshold']
            }
            
        except Exception as e:
            return {
                'success': False,
                'error': str(e),
                'duration': (time.time() - start_time) * 1000
            }
```

## ğŸ”„ æµ‹è¯•æ‰§è¡Œæµç¨‹

### ä¸»æµ‹è¯•æµç¨‹

```python
class AutomatedTestSuite:
    """è‡ªåŠ¨åŒ–æµ‹è¯•å¥—ä»¶"""
    
    def __init__(self):
        self.test_runner = PhaseTestRunner()
        self.error_handler = TestErrorHandler()
        self.data_generator = TestDataGenerator()
        self.performance_benchmark = PerformanceBenchmark()
    
    async def run_full_test_suite(self) -> TestSuiteResult:
        """è¿è¡Œå®Œæ•´æµ‹è¯•å¥—ä»¶"""
        suite_result = TestSuiteResult()
        
        try:
            logger.info("å¼€å§‹æ‰§è¡Œè‡ªåŠ¨åŒ–æµ‹è¯•å¥—ä»¶")
            
            # 1. ç¯å¢ƒè®¾ç½®
            await self._setup_test_environment()
            
            # 2. ç”Ÿæˆæµ‹è¯•æ•°æ®
            test_data = await self.data_generator.generate_test_dataset()
            
            # 3. æ‰§è¡Œåˆ†é˜¶æ®µæµ‹è¯•
            phase_results = await self.test_runner.run_all_phases()
            suite_result.phase_results = phase_results
            
            # 4. æ‰§è¡Œæ€§èƒ½åŸºå‡†æµ‹è¯•
            benchmark_results = await self.performance_benchmark.run_benchmarks()
            suite_result.benchmark_results = benchmark_results
            
            # 5. ç”Ÿæˆæµ‹è¯•æŠ¥å‘Š
            test_report = await self._generate_test_report(suite_result)
            
            logger.info("è‡ªåŠ¨åŒ–æµ‹è¯•å¥—ä»¶æ‰§è¡Œå®Œæˆ")
            return suite_result
            
        except Exception as e:
            logger.error(f"æµ‹è¯•å¥—ä»¶æ‰§è¡Œå¤±è´¥: {e}")
            suite_result.success = False
            suite_result.error = str(e)
            return suite_result
    
    async def _setup_test_environment(self):
        """è®¾ç½®æµ‹è¯•ç¯å¢ƒ"""
        env_manager = TestEnvironmentManager()
        await env_manager.setup_test_environment()
    
    async def _generate_test_report(self, suite_result: TestSuiteResult) -> dict:
        """ç”Ÿæˆæµ‹è¯•æŠ¥å‘Š"""
        return {
            'timestamp': datetime.now().isoformat(),
            'success': suite_result.success,
            'total_phases': len(suite_result.phase_results),
            'passed_phases': sum(1 for r in suite_result.phase_results.values() if r.success),
            'failed_phases': sum(1 for r in suite_result.phase_results.values() if not r.success),
            'performance_benchmarks': suite_result.benchmark_results,
            'execution_time': suite_result.execution_time
        }
```

## ğŸ“ˆ æµ‹è¯•ç»“æœåˆ†æ

### æµ‹è¯•ç»“æœç±»

```python
@dataclass
class TestResult:
    """æµ‹è¯•ç»“æœ"""
    success: bool
    error: str = ""
    execution_time: float = 0.0
    details: dict = field(default_factory=dict)

@dataclass
class TestSuiteResult:
    """æµ‹è¯•å¥—ä»¶ç»“æœ"""
    success: bool = True
    error: str = ""
    execution_time: float = 0.0
    phase_results: dict = field(default_factory=dict)
    benchmark_results: dict = field(default_factory=dict)

class TestResultAnalyzer:
    """æµ‹è¯•ç»“æœåˆ†æå™¨"""
    
    def __init__(self):
        self.historical_results = []
    
    def analyze_results(self, current_result: TestSuiteResult) -> dict:
        """åˆ†ææµ‹è¯•ç»“æœ"""
        analysis = {
            'success_rate': self._calculate_success_rate(current_result),
            'performance_trends': self._analyze_performance_trends(current_result),
            'common_errors': self._identify_common_errors(current_result),
            'recommendations': self._generate_recommendations(current_result)
        }
        
        # æ›´æ–°å†å²è®°å½•
        self.historical_results.append(current_result)
        if len(self.historical_results) > 100:  # ä¿ç•™æœ€è¿‘100æ¬¡ç»“æœ
            self.historical_results.pop(0)
        
        return analysis
    
    def _calculate_success_rate(self, result: TestSuiteResult) -> float:
        """è®¡ç®—æˆåŠŸç‡"""
        if not result.phase_results:
            return 0.0
        
        total_phases = len(result.phase_results)
        passed_phases = sum(1 for r in result.phase_results.values() if r.success)
        
        return (passed_phases / total_phases) * 100
    
    def _generate_recommendations(self, result: TestSuiteResult) -> list:
        """ç”Ÿæˆä¼˜åŒ–å»ºè®®"""
        recommendations = []
        
        # åŸºäºæˆåŠŸç‡ç”Ÿæˆå»ºè®®
        success_rate = self._calculate_success_rate(result)
        if success_rate < 80:
            recommendations.append("å»ºè®®å¢åŠ é”™è¯¯å¤„ç†å’Œé‡è¯•æœºåˆ¶")
        
        # åŸºäºæ€§èƒ½åŸºå‡†ç”Ÿæˆå»ºè®®
        for benchmark, data in result.benchmark_results.items():
            if data.get('duration', 0) > data.get('threshold', 0):
                recommendations.append(f"è€ƒè™‘ä¼˜åŒ– {benchmark} æ€§èƒ½ï¼Œå½“å‰è€—æ—¶ {data['duration']}ms")
        
        return recommendations
```

## ğŸ› ï¸ é…ç½®å’Œæœ€ä½³å®è·µ

### æµ‹è¯•é…ç½®ç¤ºä¾‹

```yaml
# test_config.yaml
test_environment:
  database_url: "postgresql://test_user:test_pass@localhost:5432/hikyuu_test"
  mock_api_port: 8081
  timeout: 30
  parallel_execution: true

test_phases:
  phase1:
    name: "æ•°æ®åº“ç»“æ„æµ‹è¯•"
    enabled: true
    timeout: 60
  
  phase2:
    name: "APIåŠŸèƒ½æµ‹è¯•"
    enabled: true
    timeout: 120
  
  phase3:
    name: "å°æ•°ç²¾åº¦æµ‹è¯•"
    enabled: true
    timeout: 30
  
  phase4:
    name: "TETæ¡†æ¶æµ‹è¯•"
    enabled: true
    timeout: 90

performance_benchmarks:
  database_query:
    threshold: 100  # ms
    enabled: true
  
  api_response:
    threshold: 200  # ms
    enabled: true
  
  strategy_execution:
    threshold: 50   # ms
    enabled: true
  
  order_processing:
    threshold: 10   # ms
    enabled: true

error_handling:
  max_retries: 3
  backoff_factor: 2
  retry_on: ["database_error", "api_error", "timeout_error"]
```

### æœ€ä½³å®è·µ

1. **æµ‹è¯•éš”ç¦»**ï¼šæ¯ä¸ªæµ‹è¯•é˜¶æ®µåº”åœ¨ç‹¬ç«‹çš„ç¯å¢ƒä¸­è¿è¡Œ
2. **æ•°æ®æ¸…ç†**ï¼šæµ‹è¯•å®Œæˆåè‡ªåŠ¨æ¸…ç†æµ‹è¯•æ•°æ®
3. **é”™è¯¯é‡è¯•**ï¼šå®ç°æ™ºèƒ½é‡è¯•æœºåˆ¶ï¼Œé¿å…å¶å‘æ€§å¤±è´¥
4. **æ€§èƒ½ç›‘æ§**ï¼šæŒç»­ç›‘æ§å…³é”®æ“ä½œçš„æ€§èƒ½æŒ‡æ ‡
5. **ç»“æœåˆ†æ**ï¼šå®šæœŸåˆ†ææµ‹è¯•ç»“æœï¼Œè¯†åˆ«ç³»ç»Ÿæ”¹è¿›ç‚¹
6. **é…ç½®ç®¡ç†**ï¼šä½¿ç”¨é…ç½®æ–‡ä»¶ç®¡ç†æµ‹è¯•å‚æ•°å’Œç¯å¢ƒè®¾ç½®

## ğŸ“š ç›¸å…³èµ„æº

- [é…ç½®ç®¡ç†æŠ€æœ¯æŒ‡å—](é…ç½®ç®¡ç†æŠ€æœ¯æŒ‡å—.md)
- [HIkyuuæ¶æ„è¿ç§»æŠ€æœ¯æŒ‡å—](HIkyuuæ¶æ„è¿ç§»æŠ€æœ¯æŒ‡å—.md)
- [äº¤æ˜“ç³»ç»Ÿæ¶æ„ä¼˜åŒ–ä¸é‡æ„æŠ€æœ¯æŠ¥å‘Š](äº¤æ˜“ç³»ç»Ÿæ¶æ„ä¼˜åŒ–ä¸é‡æ„æŠ€æœ¯æŠ¥å‘Š.md)