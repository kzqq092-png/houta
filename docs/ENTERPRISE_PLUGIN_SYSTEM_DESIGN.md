# ä¼ä¸šçº§æ’ä»¶ç®¡ç†ç³»ç»Ÿè®¾è®¡æ–¹æ¡ˆ

## ğŸ¯ è®¾è®¡ç›®æ ‡

åŸºäºæ•°æ®åº“ä¸ºä¸­å¿ƒçš„æ’ä»¶ç®¡ç†ç³»ç»Ÿï¼Œæ”¯æŒè¿œç¨‹æˆæƒã€é˜²ç¯¡æ”¹ã€è‡ªåŠ¨åˆ†ç±»å½•å…¥ï¼Œå¯¹æ ‡ä¼ä¸šçº§ä¸“ä¸šè½¯ä»¶ã€‚

## ğŸ—ï¸ ç³»ç»Ÿæ¶æ„è®¾è®¡

### 1. æ•´ä½“æ¶æ„æ¦‚è§ˆ

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    ä¼ä¸šçº§æ’ä»¶ç®¡ç†ç³»ç»Ÿ                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  è¿œç¨‹ç®¡ç†ç«¯        â”‚        æœ¬åœ°å®¢æˆ·ç«¯        â”‚    å®‰å…¨å±‚    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚æˆæƒæœåŠ¡å™¨   â”‚â—„â”€â”€â”¼â”€â”€â–ºâ”‚æ’ä»¶å‘ç°å¼•æ“     â”‚â—„â”€â”€â”¼â”€â”€â”‚æ•°å­—ç­¾å â”‚ â”‚
â”‚  â”‚æ’ä»¶ä»“åº“     â”‚   â”‚   â”‚æ³¨å†ŒæœåŠ¡         â”‚   â”‚  â”‚è¿œç¨‹æˆæƒ â”‚ â”‚
â”‚  â”‚å®‰å…¨æ ¡éªŒ     â”‚   â”‚   â”‚æ•°æ®åº“ç®¡ç†       â”‚   â”‚  â”‚è®¿é—®æ§åˆ¶ â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2. æ ¸å¿ƒè®¾è®¡åŸåˆ™

#### ğŸ”’ å®‰å…¨ä¼˜å…ˆ
- æ•°å­—ç­¾åéªŒè¯æ‰€æœ‰æ’ä»¶
- è¿œç¨‹æˆæƒç®¡ç†
- åŠ å¯†é€šä¿¡ä¼ è¾“
- è®¿é—®æƒé™æ§åˆ¶

#### ğŸ“Š æ•°æ®åº“ä¸­å¿ƒ
- æ‰€æœ‰çŠ¶æ€ä»¥æ•°æ®åº“ä¸ºå‡†
- å†…å­˜ç¼“å­˜ä½œä¸ºæ€§èƒ½ä¼˜åŒ–
- è‡ªåŠ¨æ•°æ®åŒæ­¥æœºåˆ¶
- é˜²é‡å¤å½•å…¥ä¿æŠ¤

#### ğŸš€ ä¼ä¸šçº§ç‰¹æ€§
- è¿œç¨‹ç®¡ç†æ”¯æŒ
- æ‰¹é‡æ“ä½œèƒ½åŠ›
- å®¡è®¡æ—¥å¿—è®°å½•
- é«˜å¯ç”¨è®¾è®¡

## ğŸ’¾ æ•°æ®åº“è®¾è®¡æ–¹æ¡ˆ

### æ ¸å¿ƒè¡¨ç»“æ„æ‰©å±•

```sql
-- 1. æ’ä»¶æ³¨å†Œè¡¨ (æ‰©å±•ç‰ˆ)
CREATE TABLE plugins (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT UNIQUE NOT NULL,
    display_name TEXT NOT NULL,
    version TEXT NOT NULL DEFAULT '1.0.0',
    plugin_type TEXT NOT NULL,  -- è‡ªåŠ¨åˆ†ç±»ç»“æœ
    status TEXT NOT NULL DEFAULT 'discovered',
    description TEXT DEFAULT '',
    author TEXT DEFAULT '',
    file_path TEXT NOT NULL,    -- æºæ–‡ä»¶è·¯å¾„
    file_hash TEXT NOT NULL,    -- æ–‡ä»¶å“ˆå¸Œå€¼ (é˜²ç¯¡æ”¹)
    signature_hash TEXT,        -- æ•°å­—ç­¾åå“ˆå¸Œ
    signature_valid BOOLEAN DEFAULT 0,  -- ç­¾åéªŒè¯çŠ¶æ€
    license_key TEXT,           -- æˆæƒå¯†é’¥
    license_valid BOOLEAN DEFAULT 0,    -- æˆæƒéªŒè¯çŠ¶æ€
    license_expires_at TIMESTAMP,       -- æˆæƒè¿‡æœŸæ—¶é—´
    auto_discovered BOOLEAN DEFAULT 1,  -- æ˜¯å¦è‡ªåŠ¨å‘ç°
    install_source TEXT DEFAULT 'local', -- local/remote/market
    dependencies TEXT DEFAULT '[]',
    capabilities TEXT DEFAULT '[]',     -- æ’ä»¶èƒ½åŠ›åˆ—è¡¨
    security_level INTEGER DEFAULT 1,   -- å®‰å…¨ç­‰çº§ 1-5
    remote_url TEXT DEFAULT '',
    checksum TEXT NOT NULL,             -- å®Œæ•´æ€§æ ¡éªŒ
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    last_scanned_at TIMESTAMP,          -- æœ€åæ‰«ææ—¶é—´
    scan_result TEXT DEFAULT '{}',      -- æ‰«æç»“æœJSON
    UNIQUE(file_path, file_hash)        -- é˜²é‡å¤çº¦æŸ
);

-- 2. æ’ä»¶åˆ†ç±»è§„åˆ™è¡¨
CREATE TABLE plugin_classification_rules (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    rule_name TEXT NOT NULL,
    rule_type TEXT NOT NULL,    -- file_pattern/class_pattern/content_pattern
    pattern TEXT NOT NULL,      -- åŒ¹é…æ¨¡å¼
    target_type TEXT NOT NULL,  -- ç›®æ ‡æ’ä»¶ç±»å‹
    priority INTEGER DEFAULT 100,
    is_active BOOLEAN DEFAULT 1,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 3. è¿œç¨‹æˆæƒç®¡ç†è¡¨
CREATE TABLE remote_licenses (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    plugin_id INTEGER NOT NULL,
    license_server TEXT NOT NULL,
    license_key TEXT NOT NULL,
    license_type TEXT DEFAULT 'standard', -- trial/standard/enterprise
    issued_at TIMESTAMP,
    expires_at TIMESTAMP,
    max_instances INTEGER DEFAULT 1,
    current_instances INTEGER DEFAULT 0,
    last_validated_at TIMESTAMP,
    validation_result TEXT DEFAULT '{}',
    is_active BOOLEAN DEFAULT 1,
    FOREIGN KEY (plugin_id) REFERENCES plugins (id)
);

-- 4. å®‰å…¨å®¡è®¡è¡¨
CREATE TABLE security_audit_log (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    event_type TEXT NOT NULL,   -- signature_check/license_check/access_denied
    plugin_id INTEGER,
    event_level TEXT DEFAULT 'INFO',
    event_message TEXT NOT NULL,
    source_ip TEXT DEFAULT '',
    user_agent TEXT DEFAULT '',
    risk_score INTEGER DEFAULT 0,
    mitigation_action TEXT DEFAULT '',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (plugin_id) REFERENCES plugins (id)
);

-- 5. æ’ä»¶æ–‡ä»¶å®Œæ•´æ€§è¡¨
CREATE TABLE plugin_file_integrity (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    plugin_id INTEGER NOT NULL,
    file_path TEXT NOT NULL,
    original_hash TEXT NOT NULL,
    current_hash TEXT,
    last_verified_at TIMESTAMP,
    integrity_status TEXT DEFAULT 'unknown', -- valid/corrupted/missing
    auto_repair_attempted BOOLEAN DEFAULT 0,
    FOREIGN KEY (plugin_id) REFERENCES plugins (id)
);
```

### ç´¢å¼•ä¼˜åŒ–ç­–ç•¥

```sql
-- æ€§èƒ½ä¼˜åŒ–ç´¢å¼•
CREATE INDEX idx_plugins_type_status ON plugins(plugin_type, status);
CREATE INDEX idx_plugins_hash ON plugins(file_hash);
CREATE INDEX idx_plugins_signature ON plugins(signature_hash);
CREATE INDEX idx_licenses_active ON remote_licenses(is_active, expires_at);
CREATE INDEX idx_audit_type_time ON security_audit_log(event_type, created_at);
CREATE INDEX idx_integrity_status ON plugin_file_integrity(integrity_status);
```

## ğŸ” æ’ä»¶è‡ªåŠ¨å‘ç°ä¸åˆ†ç±»ç³»ç»Ÿ

### 1. æ™ºèƒ½æ’ä»¶å‘ç°å¼•æ“

```python
class EnterprisePluginDiscoveryEngine:
    """ä¼ä¸šçº§æ’ä»¶å‘ç°å¼•æ“"""
    
    def __init__(self, db_service, security_manager):
        self.db_service = db_service
        self.security_manager = security_manager
        self.classification_rules = self._load_classification_rules()
        
    async def discover_and_register_all_plugins(self):
        """å‘ç°å¹¶æ³¨å†Œæ‰€æœ‰æ’ä»¶"""
        discovery_results = {
            'total_scanned': 0,
            'new_discovered': 0,
            'updated': 0,
            'security_issues': 0,
            'classification_results': {}
        }
        
        try:
            # 1. æ‰«ææ‰€æœ‰å¯èƒ½çš„æ’ä»¶ä½ç½®
            scan_paths = [
                'plugins/',
                'plugins/examples/',
                'plugins/third_party/',
                'plugins/enterprise/'
            ]
            
            for scan_path in scan_paths:
                await self._scan_directory(scan_path, discovery_results)
                
            # 2. æ›´æ–°æ‰«æç»Ÿè®¡
            await self._update_discovery_statistics(discovery_results)
            
            return discovery_results
            
        except Exception as e:
            logger.error(f"æ’ä»¶å‘ç°å¤±è´¥: {e}")
            raise
    
    async def _scan_directory(self, directory: str, results: dict):
        """æ‰«ææŒ‡å®šç›®å½•"""
        try:
            for plugin_file in Path(directory).glob("**/*.py"):
                if self._should_skip_file(plugin_file):
                    continue
                    
                results['total_scanned'] += 1
                
                # è®¡ç®—æ–‡ä»¶å“ˆå¸Œ
                file_hash = self._calculate_file_hash(plugin_file)
                
                # æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨
                existing_plugin = await self.db_service.get_plugin_by_hash(file_hash)
                
                if existing_plugin:
                    # æ£€æŸ¥æ–‡ä»¶æ˜¯å¦è¢«ä¿®æ”¹
                    if await self._verify_file_integrity(existing_plugin, plugin_file):
                        continue  # æ–‡ä»¶æœªå˜æ›´ï¼Œè·³è¿‡
                    else:
                        await self._handle_modified_plugin(existing_plugin, plugin_file, results)
                else:
                    # æ–°æ’ä»¶å‘ç°
                    await self._register_new_plugin(plugin_file, file_hash, results)
                    
        except Exception as e:
            logger.error(f"æ‰«æç›®å½•å¤±è´¥ {directory}: {e}")
    
    async def _register_new_plugin(self, plugin_file: Path, file_hash: str, results: dict):
        """æ³¨å†Œæ–°å‘ç°çš„æ’ä»¶"""
        try:
            # 1. åˆ†ææ’ä»¶æ–‡ä»¶
            plugin_analysis = await self._analyze_plugin_file(plugin_file)
            
            # 2. è‡ªåŠ¨åˆ†ç±»
            plugin_type = await self._classify_plugin(plugin_analysis)
            results['classification_results'][plugin_type] = results['classification_results'].get(plugin_type, 0) + 1
            
            # 3. å®‰å…¨éªŒè¯
            security_result = await self._verify_plugin_security(plugin_file, plugin_analysis)
            
            if security_result['has_issues']:
                results['security_issues'] += 1
                await self._log_security_issue(plugin_file, security_result)
                return  # è·³è¿‡æœ‰å®‰å…¨é—®é¢˜çš„æ’ä»¶
            
            # 4. åˆ›å»ºæ’ä»¶è®°å½•
            plugin_record = {
                'name': plugin_analysis['name'],
                'display_name': plugin_analysis.get('display_name', plugin_analysis['name']),
                'version': plugin_analysis.get('version', '1.0.0'),
                'plugin_type': plugin_type,
                'description': plugin_analysis.get('description', ''),
                'author': plugin_analysis.get('author', ''),
                'file_path': str(plugin_file),
                'file_hash': file_hash,
                'signature_hash': security_result.get('signature_hash', ''),
                'signature_valid': security_result.get('signature_valid', False),
                'capabilities': json.dumps(plugin_analysis.get('capabilities', [])),
                'dependencies': json.dumps(plugin_analysis.get('dependencies', [])),
                'security_level': security_result.get('security_level', 1),
                'checksum': self._calculate_checksum(plugin_file),
                'scan_result': json.dumps(plugin_analysis),
                'last_scanned_at': datetime.now().isoformat()
            }
            
            # 5. æ’å…¥æ•°æ®åº“
            plugin_id = await self.db_service.register_plugin(plugin_record)
            
            # 6. è®°å½•æ–‡ä»¶å®Œæ•´æ€§
            await self._record_file_integrity(plugin_id, plugin_file, file_hash)
            
            results['new_discovered'] += 1
            logger.info(f"æ–°æ’ä»¶æ³¨å†ŒæˆåŠŸ: {plugin_analysis['name']} (ç±»å‹: {plugin_type})")
            
        except Exception as e:
            logger.error(f"æ³¨å†Œæ’ä»¶å¤±è´¥ {plugin_file}: {e}")
```

### 2. æ™ºèƒ½åˆ†ç±»ç³»ç»Ÿ

```python
class PluginClassificationSystem:
    """æ’ä»¶æ™ºèƒ½åˆ†ç±»ç³»ç»Ÿ"""
    
    CLASSIFICATION_RULES = [
        # åŸºäºæ–‡ä»¶åæ¨¡å¼
        {'pattern': r'.*indicator.*', 'type': 'indicator', 'priority': 90},
        {'pattern': r'.*strategy.*', 'type': 'strategy', 'priority': 90},
        {'pattern': r'.*data.*source.*', 'type': 'data_source', 'priority': 85},
        {'pattern': r'.*analysis.*', 'type': 'analysis', 'priority': 80},
        
        # åŸºäºç±»ç»§æ‰¿æ¨¡å¼
        {'pattern': r'.*Indicator\b', 'type': 'indicator', 'priority': 95},
        {'pattern': r'.*Strategy\b', 'type': 'strategy', 'priority': 95},
        {'pattern': r'.*DataSource\b', 'type': 'data_source', 'priority': 95},
        
        # åŸºäºåŠŸèƒ½ç‰¹å¾
        {'pattern': r'.*chart.*tool.*', 'type': 'chart_tool', 'priority': 85},
        {'pattern': r'.*notification.*', 'type': 'notification', 'priority': 85},
        {'pattern': r'.*export.*', 'type': 'export', 'priority': 80},
    ]
    
    async def classify_plugin(self, plugin_analysis: dict) -> str:
        """æ™ºèƒ½åˆ†ç±»æ’ä»¶"""
        try:
            classification_scores = {}
            
            # 1. åŸºäºæ–‡ä»¶ååˆ†æ
            file_scores = self._analyze_filename(plugin_analysis.get('file_name', ''))
            self._merge_scores(classification_scores, file_scores)
            
            # 2. åŸºäºç±»ååˆ†æ
            class_scores = self._analyze_class_names(plugin_analysis.get('classes', []))
            self._merge_scores(classification_scores, class_scores)
            
            # 3. åŸºäºæ–¹æ³•ååˆ†æ
            method_scores = self._analyze_methods(plugin_analysis.get('methods', []))
            self._merge_scores(classification_scores, method_scores)
            
            # 4. åŸºäºå¯¼å…¥æ¨¡å—åˆ†æ
            import_scores = self._analyze_imports(plugin_analysis.get('imports', []))
            self._merge_scores(classification_scores, import_scores)
            
            # 5. åŸºäºæ³¨é‡Šå’Œæ–‡æ¡£åˆ†æ
            doc_scores = self._analyze_documentation(plugin_analysis.get('docstring', ''))
            self._merge_scores(classification_scores, doc_scores)
            
            # 6. é€‰æ‹©æœ€é«˜åˆ†ç±»å‹
            if classification_scores:
                best_type = max(classification_scores.keys(), 
                              key=lambda k: classification_scores[k])
                
                # ç½®ä¿¡åº¦æ£€æŸ¥
                confidence = classification_scores[best_type] / sum(classification_scores.values())
                
                if confidence >= 0.6:
                    return best_type
                else:
                    return 'analysis'  # é»˜è®¤åˆ†ç±»
            
            return 'analysis'  # æ— æ³•åˆ†ç±»æ—¶çš„é»˜è®¤å€¼
            
        except Exception as e:
            logger.error(f"æ’ä»¶åˆ†ç±»å¤±è´¥: {e}")
            return 'analysis'
    
    def _analyze_filename(self, filename: str) -> dict:
        """åŸºäºæ–‡ä»¶ååˆ†æ"""
        scores = {}
        filename_lower = filename.lower()
        
        for rule in self.CLASSIFICATION_RULES:
            if 'filename' in rule['pattern']:
                if re.search(rule['pattern'], filename_lower):
                    scores[rule['type']] = scores.get(rule['type'], 0) + rule['priority']
        
        return scores
    
    def _analyze_class_names(self, class_names: list) -> dict:
        """åŸºäºç±»ååˆ†æ"""
        scores = {}
        
        for class_name in class_names:
            # æŒ‡æ ‡ç±»è¯†åˆ«
            if re.search(r'(Indicator|MA|RSI|MACD|KDJ|BOLL)', class_name):
                scores['indicator'] = scores.get('indicator', 0) + 100
            
            # ç­–ç•¥ç±»è¯†åˆ«
            elif re.search(r'(Strategy|Signal|Trading)', class_name):
                scores['strategy'] = scores.get('strategy', 0) + 100
            
            # æ•°æ®æºç±»è¯†åˆ«
            elif re.search(r'(DataSource|Provider|Feed)', class_name):
                scores['data_source'] = scores.get('data_source', 0) + 100
            
            # åˆ†æå·¥å…·ç±»è¯†åˆ«
            elif re.search(r'(Analyzer|Analysis|Calculator)', class_name):
                scores['analysis'] = scores.get('analysis', 0) + 80
        
        return scores
```

## ğŸ” å®‰å…¨ä¸æˆæƒç³»ç»Ÿè®¾è®¡

### 1. æ•°å­—ç­¾åéªŒè¯ç³»ç»Ÿ

```python
class PluginSecurityManager:
    """æ’ä»¶å®‰å…¨ç®¡ç†å™¨"""
    
    def __init__(self, certificate_store):
        self.certificate_store = certificate_store
        self.trusted_publishers = self._load_trusted_publishers()
        
    async def verify_plugin_security(self, plugin_file: Path, analysis: dict) -> dict:
        """ç»¼åˆå®‰å…¨éªŒè¯"""
        security_result = {
            'signature_valid': False,
            'signature_hash': '',
            'trust_level': 0,
            'security_level': 1,
            'has_issues': False,
            'issues': [],
            'recommendations': []
        }
        
        try:
            # 1. æ•°å­—ç­¾åéªŒè¯
            signature_result = await self._verify_digital_signature(plugin_file)
            security_result.update(signature_result)
            
            # 2. ä»£ç å®‰å…¨æ‰«æ
            code_scan_result = await self._scan_code_security(plugin_file, analysis)
            security_result['has_issues'] = security_result['has_issues'] or code_scan_result['has_issues']
            security_result['issues'].extend(code_scan_result['issues'])
            
            # 3. æƒé™éœ€æ±‚åˆ†æ
            permission_analysis = await self._analyze_permissions(analysis)
            security_result['required_permissions'] = permission_analysis['permissions']
            security_result['risk_score'] = permission_analysis['risk_score']
            
            # 4. è®¡ç®—ç»¼åˆå®‰å…¨ç­‰çº§
            security_result['security_level'] = self._calculate_security_level(security_result)
            
            return security_result
            
        except Exception as e:
            logger.error(f"å®‰å…¨éªŒè¯å¤±è´¥: {e}")
            security_result['has_issues'] = True
            security_result['issues'].append(f"å®‰å…¨éªŒè¯å¼‚å¸¸: {e}")
            return security_result
    
    async def _verify_digital_signature(self, plugin_file: Path) -> dict:
        """éªŒè¯æ•°å­—ç­¾å"""
        result = {
            'signature_valid': False,
            'signature_hash': '',
            'trust_level': 0,
            'signer_info': {}
        }
        
        try:
            # æ£€æŸ¥æ˜¯å¦æœ‰ç­¾åæ–‡ä»¶
            signature_file = plugin_file.with_suffix('.py.sig')
            
            if signature_file.exists():
                # éªŒè¯ç­¾å
                signature_data = signature_file.read_bytes()
                file_data = plugin_file.read_bytes()
                
                # ä½¿ç”¨å…¬é’¥éªŒè¯ç­¾å
                is_valid, signer_info = await self._validate_signature(
                    file_data, signature_data
                )
                
                result['signature_valid'] = is_valid
                result['signature_hash'] = hashlib.sha256(signature_data).hexdigest()
                result['signer_info'] = signer_info
                
                # æ£€æŸ¥ç­¾åè€…ä¿¡ä»»çº§åˆ«
                if is_valid and signer_info.get('publisher') in self.trusted_publishers:
                    result['trust_level'] = self.trusted_publishers[signer_info['publisher']]['trust_level']
            
            return result
            
        except Exception as e:
            logger.error(f"æ•°å­—ç­¾åéªŒè¯å¤±è´¥: {e}")
            return result
    
    async def _scan_code_security(self, plugin_file: Path, analysis: dict) -> dict:
        """ä»£ç å®‰å…¨æ‰«æ"""
        scan_result = {
            'has_issues': False,
            'issues': [],
            'risk_patterns': []
        }
        
        # å±é™©æ¨¡å¼æ£€æµ‹
        DANGEROUS_PATTERNS = [
            (r'exec\s*\(', 'HIGH', 'åŠ¨æ€ä»£ç æ‰§è¡Œ'),
            (r'eval\s*\(', 'HIGH', 'è¡¨è¾¾å¼æ±‚å€¼'),
            (r'__import__\s*\(', 'MEDIUM', 'åŠ¨æ€å¯¼å…¥'),
            (r'subprocess\.(call|run|Popen)', 'HIGH', 'ç³»ç»Ÿå‘½ä»¤æ‰§è¡Œ'),
            (r'os\.system\s*\(', 'HIGH', 'ç³»ç»Ÿå‘½ä»¤æ‰§è¡Œ'),
            (r'open\s*\([^)]*[\'"]w', 'MEDIUM', 'æ–‡ä»¶å†™å…¥æ“ä½œ'),
            (r'socket\.socket\s*\(', 'MEDIUM', 'ç½‘ç»œè¿æ¥'),
            (r'urllib\.request', 'MEDIUM', 'ç½‘ç»œè¯·æ±‚'),
            (r'pickle\.loads?\s*\(', 'HIGH', 'ååºåˆ—åŒ–æ“ä½œ'),
        ]
        
        try:
            plugin_code = plugin_file.read_text(encoding='utf-8')
            
            for pattern, risk_level, description in DANGEROUS_PATTERNS:
                matches = re.findall(pattern, plugin_code, re.IGNORECASE)
                
                if matches:
                    issue = {
                        'type': 'dangerous_pattern',
                        'risk_level': risk_level,
                        'description': description,
                        'pattern': pattern,
                        'matches': len(matches)
                    }
                    
                    scan_result['risk_patterns'].append(issue)
                    
                    if risk_level == 'HIGH':
                        scan_result['has_issues'] = True
                        scan_result['issues'].append(f"é«˜é£é™©ä»£ç æ¨¡å¼: {description}")
            
            return scan_result
            
        except Exception as e:
            logger.error(f"ä»£ç å®‰å…¨æ‰«æå¤±è´¥: {e}")
            scan_result['has_issues'] = True
            scan_result['issues'].append(f"ä»£ç æ‰«æå¼‚å¸¸: {e}")
            return scan_result
```

### 2. è¿œç¨‹æˆæƒç®¡ç†ç³»ç»Ÿ

```python
class RemoteLicenseManager:
    """è¿œç¨‹æˆæƒç®¡ç†å™¨"""
    
    def __init__(self, license_server_config):
        self.license_servers = license_server_config
        self.local_cache = {}
        self.session = aiohttp.ClientSession()
        
    async def validate_plugin_license(self, plugin_id: int, plugin_name: str) -> dict:
        """éªŒè¯æ’ä»¶æˆæƒ"""
        validation_result = {
            'is_valid': False,
            'license_type': 'none',
            'expires_at': None,
            'remaining_days': 0,
            'features': [],
            'restrictions': {}
        }
        
        try:
            # 1. æ£€æŸ¥æœ¬åœ°ç¼“å­˜
            cached_license = await self._get_cached_license(plugin_id)
            
            if cached_license and not self._is_cache_expired(cached_license):
                return cached_license['validation_result']
            
            # 2. è¿œç¨‹éªŒè¯
            for server_config in self.license_servers:
                try:
                    remote_result = await self._validate_with_server(
                        server_config, plugin_id, plugin_name
                    )
                    
                    if remote_result['is_valid']:
                        validation_result = remote_result
                        break
                        
                except Exception as e:
                    logger.warning(f"æˆæƒæœåŠ¡å™¨ {server_config['url']} éªŒè¯å¤±è´¥: {e}")
                    continue
            
            # 3. æ›´æ–°æœ¬åœ°ç¼“å­˜
            await self._update_license_cache(plugin_id, validation_result)
            
            return validation_result
            
        except Exception as e:
            logger.error(f"æˆæƒéªŒè¯å¤±è´¥: {e}")
            return validation_result
    
    async def _validate_with_server(self, server_config: dict, plugin_id: int, plugin_name: str) -> dict:
        """ä¸æˆæƒæœåŠ¡å™¨éªŒè¯"""
        try:
            # æ„å»ºéªŒè¯è¯·æ±‚
            validation_request = {
                'plugin_id': plugin_id,
                'plugin_name': plugin_name,
                'client_id': self._get_client_id(),
                'machine_fingerprint': self._get_machine_fingerprint(),
                'version': self._get_app_version(),
                'timestamp': int(time.time())
            }
            
            # æ·»åŠ æ•°å­—ç­¾å
            validation_request['signature'] = self._sign_request(validation_request, server_config['private_key'])
            
            # å‘é€éªŒè¯è¯·æ±‚
            async with self.session.post(
                f"{server_config['url']}/api/v1/validate_license",
                json=validation_request,
                headers={'Authorization': f"Bearer {server_config['api_key']}"},
                ssl=True,
                timeout=aiohttp.ClientTimeout(total=10)
            ) as response:
                
                if response.status == 200:
                    result = await response.json()
                    
                    # éªŒè¯æœåŠ¡å™¨å“åº”ç­¾å
                    if self._verify_server_response(result, server_config['public_key']):
                        return result['validation_result']
                    else:
                        raise SecurityError("æœåŠ¡å™¨å“åº”ç­¾åéªŒè¯å¤±è´¥")
                else:
                    raise ConnectionError(f"æœåŠ¡å™¨è¿”å›é”™è¯¯: {response.status}")
                    
        except Exception as e:
            logger.error(f"è¿œç¨‹æˆæƒéªŒè¯å¤±è´¥: {e}")
            raise
    
    def _get_machine_fingerprint(self) -> str:
        """è·å–æœºå™¨æŒ‡çº¹"""
        import platform
        import uuid
        
        # æ”¶é›†ç¡¬ä»¶ä¿¡æ¯
        hardware_info = [
            platform.machine(),
            platform.processor(),
            str(uuid.getnode()),  # MACåœ°å€
            platform.system(),
            platform.release()
        ]
        
        # ç”ŸæˆæŒ‡çº¹
        fingerprint_data = '|'.join(hardware_info)
        return hashlib.sha256(fingerprint_data.encode()).hexdigest()
```

## ğŸŒ è¿œç¨‹ç®¡ç†ç«¯è®¾è®¡

### 1. æˆæƒæœåŠ¡å™¨æ¶æ„

```python
# æˆæƒæœåŠ¡å™¨ (Flask/FastAPI)
class LicenseAuthorizationServer:
    """æˆæƒæœåŠ¡å™¨"""
    
    def __init__(self):
        self.app = FastAPI(title="HIkyuu Plugin License Server")
        self.db = AsyncSQLAlchemy()
        self.security = SecurityManager()
        self._setup_routes()
    
    def _setup_routes(self):
        """è®¾ç½®APIè·¯ç”±"""
        
        @self.app.post("/api/v1/validate_license")
        async def validate_license(request: LicenseValidationRequest):
            """éªŒè¯æ’ä»¶æˆæƒ"""
            try:
                # 1. éªŒè¯è¯·æ±‚ç­¾å
                if not self.security.verify_request_signature(request):
                    raise HTTPException(401, "è¯·æ±‚ç­¾åéªŒè¯å¤±è´¥")
                
                # 2. æŸ¥è¯¢æˆæƒè®°å½•
                license_record = await self.db.get_license_record(
                    request.plugin_name, request.client_id
                )
                
                if not license_record:
                    return LicenseValidationResponse(
                        is_valid=False,
                        reason="æœªæ‰¾åˆ°æœ‰æ•ˆæˆæƒ"
                    )
                
                # 3. éªŒè¯æˆæƒçŠ¶æ€
                validation_result = await self._validate_license_record(
                    license_record, request
                )
                
                # 4. è®°å½•éªŒè¯æ—¥å¿—
                await self._log_validation_attempt(request, validation_result)
                
                # 5. ç­¾åå“åº”
                response = LicenseValidationResponse(**validation_result)
                response.signature = self.security.sign_response(response)
                
                return response
                
            except Exception as e:
                logger.error(f"æˆæƒéªŒè¯å¼‚å¸¸: {e}")
                raise HTTPException(500, "å†…éƒ¨æœåŠ¡å™¨é”™è¯¯")
        
        @self.app.post("/api/v1/register_plugin")
        async def register_plugin(request: PluginRegistrationRequest):
            """æ³¨å†Œæ–°æ’ä»¶"""
            # æ’ä»¶æ³¨å†Œé€»è¾‘
            pass
        
        @self.app.get("/api/v1/plugin_market")
        async def get_plugin_market():
            """è·å–æ’ä»¶å¸‚åœºåˆ—è¡¨"""
            # æ’ä»¶å¸‚åœºé€»è¾‘
            pass
        
        @self.app.post("/api/v1/download_plugin")
        async def download_plugin(request: PluginDownloadRequest):
            """ä¸‹è½½æ’ä»¶"""
            # æ’ä»¶ä¸‹è½½é€»è¾‘
            pass
```

### 2. ç®¡ç†æ§åˆ¶å°

```python
class PluginManagementConsole:
    """æ’ä»¶ç®¡ç†æ§åˆ¶å° (Webç•Œé¢)"""
    
    def __init__(self):
        self.app = FastAPI()
        self.auth = AuthenticationManager()
        self._setup_admin_routes()
    
    def _setup_admin_routes(self):
        """è®¾ç½®ç®¡ç†å‘˜è·¯ç”±"""
        
        @self.app.get("/admin/dashboard")
        async def admin_dashboard():
            """ç®¡ç†å‘˜ä»ªè¡¨æ¿"""
            return {
                'total_clients': await self._get_total_clients(),
                'active_licenses': await self._get_active_licenses(),
                'plugin_downloads': await self._get_download_stats(),
                'security_alerts': await self._get_security_alerts()
            }
        
        @self.app.get("/admin/clients")
        async def list_clients():
            """å®¢æˆ·ç«¯åˆ—è¡¨"""
            return await self._get_client_list()
        
        @self.app.post("/admin/licenses/issue")
        async def issue_license(request: LicenseIssueRequest):
            """é¢å‘æˆæƒ"""
            return await self._issue_new_license(request)
        
        @self.app.delete("/admin/licenses/{license_id}/revoke")
        async def revoke_license(license_id: int):
            """æ’¤é”€æˆæƒ"""
            return await self._revoke_license(license_id)
```

## ğŸ“Š ç¼“å­˜ç­–ç•¥è®¾è®¡

### ä¸‰çº§ç¼“å­˜æ¶æ„

```python
class PluginCacheManager:
    """æ’ä»¶ç¼“å­˜ç®¡ç†å™¨"""
    
    def __init__(self, db_service, remote_service):
        self.db_service = db_service
        self.remote_service = remote_service
        
        # L1: å†…å­˜ç¼“å­˜ (æœ€å¿«è®¿é—®)
        self.memory_cache = {}
        self.memory_cache_ttl = {}
        
        # L2: æ•°æ®åº“ç¼“å­˜ (æŒä¹…åŒ–)
        self.db_cache_ttl = 3600  # 1å°æ—¶
        
        # L3: è¿œç¨‹åŒæ­¥ (æƒå¨æº)
        self.remote_sync_interval = 86400  # 24å°æ—¶
    
    async def get_plugin_info(self, plugin_name: str, force_refresh: bool = False):
        """è·å–æ’ä»¶ä¿¡æ¯ (ä¸‰çº§ç¼“å­˜ç­–ç•¥)"""
        
        # L1: æ£€æŸ¥å†…å­˜ç¼“å­˜
        if not force_refresh and self._is_memory_cache_valid(plugin_name):
            logger.debug(f"ä»å†…å­˜ç¼“å­˜è·å–æ’ä»¶ä¿¡æ¯: {plugin_name}")
            return self.memory_cache[plugin_name]
        
        # L2: æ£€æŸ¥æ•°æ®åº“ç¼“å­˜
        db_cached = await self.db_service.get_cached_plugin_info(plugin_name)
        if not force_refresh and db_cached and self._is_db_cache_valid(db_cached):
            logger.debug(f"ä»æ•°æ®åº“ç¼“å­˜è·å–æ’ä»¶ä¿¡æ¯: {plugin_name}")
            # æ›´æ–°L1ç¼“å­˜
            self._update_memory_cache(plugin_name, db_cached['data'])
            return db_cached['data']
        
        # L3: è¿œç¨‹åŒæ­¥
        try:
            remote_data = await self.remote_service.get_plugin_info(plugin_name)
            
            # æ›´æ–°æ‰€æœ‰ç¼“å­˜å±‚
            await self._update_all_caches(plugin_name, remote_data)
            
            logger.info(f"ä»è¿œç¨‹åŒæ­¥è·å–æ’ä»¶ä¿¡æ¯: {plugin_name}")
            return remote_data
            
        except Exception as e:
            logger.warning(f"è¿œç¨‹åŒæ­¥å¤±è´¥ï¼Œä½¿ç”¨æœ¬åœ°ç¼“å­˜: {e}")
            
            # é™çº§åˆ°æœ¬åœ°æ•°æ®
            if db_cached:
                self._update_memory_cache(plugin_name, db_cached['data'])
                return db_cached['data']
            
            raise CacheError(f"æ— æ³•è·å–æ’ä»¶ä¿¡æ¯: {plugin_name}")
    
    async def _update_all_caches(self, plugin_name: str, data: dict):
        """æ›´æ–°æ‰€æœ‰ç¼“å­˜å±‚"""
        try:
            # æ›´æ–°L1 (å†…å­˜)
            self._update_memory_cache(plugin_name, data)
            
            # æ›´æ–°L2 (æ•°æ®åº“)
            await self.db_service.update_plugin_cache(plugin_name, data)
            
            logger.debug(f"ç¼“å­˜æ›´æ–°å®Œæˆ: {plugin_name}")
            
        except Exception as e:
            logger.error(f"ç¼“å­˜æ›´æ–°å¤±è´¥: {e}")
```

## ğŸ”„ å®æ–½è®¡åˆ’

### é˜¶æ®µä¸€ï¼šæ ¸å¿ƒæ¶æ„ (2å‘¨)
1. æ‰©å±•æ•°æ®åº“è¡¨ç»“æ„
2. å®ç°æ’ä»¶å‘ç°å¼•æ“
3. åŸºç¡€å®‰å…¨éªŒè¯ç³»ç»Ÿ
4. è‡ªåŠ¨åˆ†ç±»ç®—æ³•

### é˜¶æ®µäºŒï¼šå®‰å…¨å¢å¼º (2å‘¨)
1. æ•°å­—ç­¾åéªŒè¯ç³»ç»Ÿ
2. ä»£ç å®‰å…¨æ‰«æ
3. æ–‡ä»¶å®Œæ•´æ€§ç›‘æ§
4. è®¿é—®æƒé™æ§åˆ¶

### é˜¶æ®µä¸‰ï¼šè¿œç¨‹ç®¡ç† (3å‘¨)
1. æˆæƒæœåŠ¡å™¨å¼€å‘
2. è¿œç¨‹APIæ¥å£
3. ç®¡ç†æ§åˆ¶å°
4. å®¢æˆ·ç«¯é›†æˆ

### é˜¶æ®µå››ï¼šä¼˜åŒ–å®Œå–„ (1å‘¨)
1. ç¼“å­˜æ€§èƒ½ä¼˜åŒ–
2. ç›‘æ§å’Œå‘Šè­¦
3. æ–‡æ¡£å’Œæµ‹è¯•
4. éƒ¨ç½²å’Œä¸Šçº¿

## ğŸ“ˆ æŠ€æœ¯æŒ‡æ ‡

### æ€§èƒ½æŒ‡æ ‡
- æ’ä»¶å‘ç°é€Ÿåº¦: < 5ç§’ (100ä¸ªæ’ä»¶)
- ç¼“å­˜å‘½ä¸­ç‡: > 90%
- æˆæƒéªŒè¯å“åº”: < 500ms
- æ•°æ®åº“æŸ¥è¯¢: < 100ms

### å®‰å…¨æŒ‡æ ‡
- ç­¾åéªŒè¯ç‡: 100%
- ä»£ç æ‰«æè¦†ç›–: > 95%
- æˆæƒå‡†ç¡®ç‡: > 99.9%
- å®‰å…¨äº‹ä»¶å“åº”: < 1åˆ†é’Ÿ

### å¯ç”¨æ€§æŒ‡æ ‡
- ç³»ç»Ÿå¯ç”¨æ€§: > 99.5%
- è¿œç¨‹æœåŠ¡å¯ç”¨æ€§: > 99%
- ç¼“å­˜ä¸€è‡´æ€§: > 99.9%
- é”™è¯¯æ¢å¤æ—¶é—´: < 30ç§’

è¿™ä¸ªè®¾è®¡æ–¹æ¡ˆæä¾›äº†ä¼ä¸šçº§çš„æ’ä»¶ç®¡ç†èƒ½åŠ›ï¼Œç¡®ä¿äº†å®‰å…¨æ€§ã€å¯é æ€§å’Œå¯æ‰©å±•æ€§ã€‚ 