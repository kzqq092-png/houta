# 智能模型选择机制实施指导文档

## 概述

本文档提供了智能模型选择机制的详细实施指导，包括架构设计、实现细节、配置选项和集成方案。该机制基于市场状态检测、模型性能评估、动态选择策略和预测结果融合四个核心模块构建。

## 项目结构

### 新增目录结构

```
core/ai/intelligent_selection/
├── __init__.py
├── market_detector.py         # 市场状态检测模块
├── performance_evaluator.py   # 模型性能评估模块  
├── selection_strategy.py      # 动态选择策略模块
├── fusion_engine.py          # 预测结果融合引擎
├── intelligent_selector.py   # 智能选择器主类
└── config/
    ├── __init__.py
    ├── selector_config.py     # 配置管理
    └── model_profiles.py      # 模型档案配置
```

## 核心组件实现

### 1. 市场状态检测模块 (MarketStateDetector)

#### 核心功能
- 波动率状态检测
- 趋势强度分析
- 市场体制分类
- 流动性状态评估

#### 关键实现
```python
class MarketStateDetector:
    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.volatility_analyzer = VolatilityAnalyzer(config.get('volatility', {}))
        self.trend_analyzer = TrendStrengthAnalyzer(config.get('trend', {}))
        self.regime_classifier = MarketRegimeClassifier(config.get('regime', {}))
        self.liquidity_assessor = LiquidityStateAssessor(config.get('liquidity', {}))
    
    def detect_market_state(self, 
                          kdata: pd.DataFrame,
                          market_data: Dict[str, Any]) -> MarketState:
        """
        综合检测市场状态
        
        Returns:
            MarketState: 包含所有市场状态信息的数据类
        """
        try:
            # 波动率分析
            volatility = self.volatility_analyzer.analyze(kdata)
            
            # 趋势强度分析  
            trend_strength = self.trend_analyzer.analyze(kdata, market_data)
            
            # 市场体制分类
            market_regime = self.regime_classifier.classify(
                kdata, volatility, trend_strength
            )
            
            # 流动性状态评估
            liquidity = self.liquidity_assessor.assess(market_data)
            
            return MarketState(
                volatility=volatility,
                trend_strength=trend_strength,
                market_regime=market_regime,
                liquidity=liquidity,
                timestamp=datetime.now()
            )
            
        except Exception as e:
            logger.error(f"市场状态检测失败: {e}")
            return self._get_default_market_state()
```

#### 波动率分析器 (VolatilityAnalyzer)
```python
class VolatilityAnalyzer:
    def analyze(self, kdata: pd.DataFrame) -> VolatilityState:
        """波动率状态分析"""
        returns = kdata['close'].pct_change().dropna()
        
        # 计算历史波动率
        historical_vol = returns.std() * np.sqrt(252)
        
        # 计算实现波动率
        realized_vol = returns.tail(20).std() * np.sqrt(252)
        
        # 波动率状态分类
        if historical_vol > self.config['high_vol_threshold']:
            state = VolatilityState.HIGH
        elif historical_vol < self.config['low_vol_threshold']:
            state = VolatilityState.LOW
        else:
            state = VolatilityState.NORMAL
            
        return VolatilityState(
            level=state,
            historical_volatility=historical_vol,
            realized_volatility=realized_vol,
            volatility_ratio=realized_vol / historical_vol if historical_vol > 0 else 1.0
        )
```

### 2. 模型性能评估模块 (ModelPerformanceEvaluator)

#### 核心功能
- 历史性能跟踪
- 实时性能监控
- 模型可靠性评估
- 预测准确率分析

#### 关键实现
```python
class ModelPerformanceEvaluator:
    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.performance_db = PerformanceDatabase(config.get('database', {}))
        self.metric_calculators = {
            'accuracy': AccuracyCalculator(),
            'precision': PrecisionCalculator(),
            'recall': RecallCalculator(),
            'f1_score': F1ScoreCalculator(),
            'mape': MAPECalculator(),
            'sharpe_ratio': SharpeRatioCalculator()
        }
    
    def evaluate_model_performance(self,
                                 model_type: str,
                                 prediction_results: List[Dict[str, Any]],
                                 actual_results: List[Dict[str, Any]]) -> ModelPerformance:
        """评估模型性能"""
        
        if len(prediction_results) != len(actual_results):
            raise ValueError("预测结果与实际结果数量不匹配")
        
        # 计算各项指标
        metrics = {}
        for metric_name, calculator in self.metric_calculators.items():
            try:
                metrics[metric_name] = calculator.calculate(
                    prediction_results, actual_results
                )
            except Exception as e:
                logger.warning(f"计算{metric_name}指标失败: {e}")
                metrics[metric_name] = 0.0
        
        # 计算综合评分
        composite_score = self._calculate_composite_score(metrics)
        
        # 评估可靠性
        reliability = self._assess_reliability(prediction_results, actual_results)
        
        performance = ModelPerformance(
            model_type=model_type,
            metrics=metrics,
            composite_score=composite_score,
            reliability_score=reliability,
            sample_size=len(prediction_results),
            evaluation_timestamp=datetime.now()
        )
        
        # 保存性能数据
        self.performance_db.save_performance(performance)
        
        return performance
    
    def _calculate_composite_score(self, metrics: Dict[str, float]) -> float:
        """计算综合评分"""
        weights = self.config.get('metric_weights', {
            'accuracy': 0.3,
            'precision': 0.2,
            'recall': 0.2,
            'f1_score': 0.15,
            'mape': 0.1,
            'sharpe_ratio': 0.05
        })
        
        score = 0.0
        total_weight = 0.0
        
        for metric_name, weight in weights.items():
            if metric_name in metrics:
                # 标准化指标值 (假设0-1范围)
                normalized_value = min(max(metrics[metric_name], 0), 1)
                score += normalized_value * weight
                total_weight += weight
        
        return score / total_weight if total_weight > 0 else 0.0
```

### 3. 动态选择策略模块 (ModelSelectionStrategy)

#### 核心功能
- 多标准决策分析
- 动态权重调整
- 约束条件处理
- 最优模型组合选择

#### 关键实现
```python
class ModelSelectionStrategy:
    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.performance_evaluator = None  # 将在外部设置
        
        # 策略配置
        self.decision_matrix = MultiCriteriaDecisionMatrix(config.get('decision_matrix', {}))
        self.constraint_handler = ConstraintHandler(config.get('constraints', {}))
        self.ensemble_builder = EnsembleBuilder(config.get('ensemble', {}))
    
    def select_optimal_models(self, criteria: SelectionCriteria) -> List[ModelSelection]:
        """选择最优模型组合"""
        
        try:
            # 1. 获取历史性能数据
            historical_performance = self._get_historical_performance(criteria.available_models)
            
            # 2. 构建决策矩阵
            decision_matrix = self._build_decision_matrix(
                criteria, historical_performance
            )
            
            # 3. 应用约束条件
            constrained_options = self.constraint_handler.apply_constraints(
                decision_matrix, criteria
            )
            
            if not constrained_options:
                logger.warning("应用约束条件后没有可用选项")
                return []
            
            # 4. 多标准决策分析
            ranked_options = self.decision_matrix.rank_options(constrained_options)
            
            # 5. 构建最优组合
            optimal_selection = self._build_optimal_ensemble(
                ranked_options, criteria
            )
            
            return optimal_selection
            
        except Exception as e:
            logger.error(f"模型选择失败: {e}")
            return self._get_fallback_selection(criteria)
    
    def _build_decision_matrix(self,
                             criteria: SelectionCriteria,
                             performance_data: Dict[str, ModelPerformance]) -> DecisionMatrix:
        """构建决策矩阵"""
        
        matrix = DecisionMatrix()
        
        for model_type in criteria.available_models:
            if model_type in performance_data:
                performance = performance_data[model_type]
                
                # 计算各项评分
                accuracy_score = self._normalize_score(performance.metrics.get('accuracy', 0))
                speed_score = self._calculate_speed_score(model_type, criteria)
                stability_score = performance.reliability_score
                market_fit_score = self._calculate_market_fit_score(
                    model_type, criteria.market_state
                )
                
                matrix.add_option(model_type, {
                    'accuracy': accuracy_score,
                    'speed': speed_score,
                    'stability': stability_score,
                    'market_fit': market_fit_score
                })
        
        return matrix
    
    def _build_optimal_ensemble(self,
                              ranked_options: List[RankedOption],
                              criteria: SelectionCriteria) -> List[ModelSelection]:
        """构建最优模型组合"""
        
        selections = []
        remaining_budget = criteria.ensemble_size
        
        for ranked_option in ranked_options[:remaining_budget]:
            model_type = ranked_option.option_id
            score = ranked_option.total_score
            
            # 计算权重
            weight = self._calculate_ensemble_weight(score, ranked_options)
            
            selection = ModelSelection(
                model_type=model_type,
                confidence=ranked_option.confidence,
                weight=weight,
                selection_reason=f"基于多标准决策分析排名第{ranked_option.rank}位"
            )
            
            selections.append(selection)
        
        # 归一化权重
        self._normalize_weights(selections)
        
        return selections
```

### 4. 预测结果融合引擎 (PredictionFusionEngine)

#### 核心功能
- 多模型结果融合
- 权重动态调整
- 置信度计算
- 不确定性评估

#### 关键实现
```python
class PredictionFusionEngine:
    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.fusion_strategies = {
            'weighted_average': WeightedAverageFusion(config.get('weighted_average', {})),
            'stacking': StackingFusion(config.get('stacking', {})),
            'voting': VotingFusion(config.get('voting', {})),
            'bayesian': BayesianFusion(config.get('bayesian', {}))
        }
        
        self.default_strategy = config.get('default_strategy', 'weighted_average')
    
    def ensemble_prediction(self,
                          model_selections: List[ModelSelection],
                          predictions: List[Dict[str, Any]],
                          market_state: MarketState) -> Dict[str, Any]:
        """融合多模型预测结果"""
        
        if len(model_selections) != len(predictions):
            raise ValueError("模型选择与预测结果数量不匹配")
        
        if len(predictions) == 1:
            return predictions[0]  # 单模型直接返回
        
        try:
            # 选择融合策略
            strategy_name = self._select_fusion_strategy(market_state)
            fusion_strategy = self.fusion_strategies[strategy_name]
            
            # 执行融合
            fused_result = fusion_strategy.fuse(
                model_selections, predictions, market_state
            )
            
            # 添加融合元数据
            fused_result.update({
                'fusion_metadata': {
                    'strategy_used': strategy_name,
                    'contributing_models': [s.model_type for s in model_selections],
                    'fusion_confidence': self._calculate_fusion_confidence(
                        model_selections, predictions
                    ),
                    'ensemble_size': len(model_selections),
                    'weight_distribution': [s.weight for s in model_selections]
                }
            })
            
            return fused_result
            
        except Exception as e:
            logger.error(f"预测融合失败: {e}")
            return self._simple_average_fusion(predictions)
    
    def _select_fusion_strategy(self, market_state: MarketState) -> str:
        """根据市场状态选择融合策略"""
        
        # 高波动市场使用贝叶斯融合
        if market_state.volatility.level == VolatilityState.HIGH:
            return 'bayesian'
        
        # 强趋势市场使用 stacking
        if market_state.trend_strength.level == TrendStrengthState.STRONG:
            return 'stacking'
        
        # 正常市场使用加权平均
        return 'weighted_average'
```

### 5. 智能选择器主类 (IntelligentModelSelector)

#### 核心功能
- 统一接口管理
- 组件协调
- 缓存管理
- 性能监控

#### 关键实现
```python
class IntelligentModelSelector:
    def __init__(self, ai_prediction_service, config: Optional[Dict[str, Any]] = None):
        """初始化智能选择器"""
        self.ai_service = ai_prediction_service
        self.config = config or self._get_default_config()
        
        # 初始化核心组件
        self.market_detector = MarketStateDetector(self.config.get('market_detector', {}))
        self.performance_evaluator = ModelPerformanceEvaluator(self.config.get('performance_evaluator', {}))
        self.selection_strategy = ModelSelectionStrategy(self.config.get('selection_strategy', {}))
        self.fusion_engine = PredictionFusionEngine(self.config.get('fusion_engine', {}))
        
        # 设置组件依赖
        self.selection_strategy.performance_evaluator = self.performance_evaluator
        
        # 缓存管理
        self._state_cache = {}
        self._selection_cache = {}
        self._cache_ttl = 300  # 5分钟
        
        # 性能统计
        self.stats = {
            'total_predictions': 0,
            'successful_selections': 0,
            'fallback_selections': 0,
            'cache_hits': 0,
            'cache_misses': 0
        }
        
        logger.info("智能模型选择器初始化完成")

    def intelligent_predict(self, 
                          prediction_type: str, 
                          data: Dict[str, Any],** kwargs) -> Optional[Dict[str, Any]]:
        """
        智能预测接口
        
        Args:
            prediction_type: 预测类型
            data: 输入数据
            **kwargs: 其他参数
            
        Returns:
            智能选择后的预测结果
        """
        start_time = datetime.now()
        self.stats['total_predictions'] += 1
        
        try:
            # 1. 数据预处理和验证
            processed_data = self._preprocess_data(data, prediction_type)
            if not processed_data:
                return self._fallback_prediction(prediction_type, data)
            
            # 2. 生成缓存键
            cache_key = self._generate_cache_key(processed_data, prediction_type)
            
            # 3. 检查缓存
            if self.config['enable_cache'] and self._is_cache_valid(cache_key):
                cached_result = self._get_cached_result(cache_key)
                if cached_result:
                    self._update_cache_hit_stats()
                    return cached_result
            
            # 4. 检测市场状态
            market_state = self._detect_market_state(processed_data, cache_key)
            
            # 5. 评估数据质量
            data_quality = self._assess_data_quality(processed_data)
            
            # 6. 获取可用模型
            available_models = self._get_available_models(prediction_type, processed_data)
            if not available_models:
                logger.warning(f"没有可用的{prediction_type}模型")
                return self._fallback_prediction(prediction_type, data)
            
            # 7. 构建选择标准
            criteria = SelectionCriteria(
                prediction_type=prediction_type,
                market_state={
                    'volatility': market_state.volatility,
                    'trend_strength': market_state.trend_strength,
                    'market_regime': market_state.market_regime,
                    'liquidity': market_state.liquidity
                },
                data_quality=data_quality,
                latency_requirement=kwargs.get('max_latency', 1000),  # 默认1秒
                accuracy_requirement=kwargs.get('min_accuracy', 0.6),
                available_models=available_models,
                ensemble_size=min(kwargs.get('ensemble_size', 3), self.config['max_ensemble_size'])
            )
            
            # 8. 选择最优模型
            model_selections = self.selection_strategy.select_optimal_models(criteria)
            
            if not model_selections:
                logger.warning("模型选择失败，使用后备策略")
                self.stats['fallback_selections'] += 1
                return self._fallback_prediction(prediction_type, data)
            
            # 9. 执行多模型预测
            predictions = self._execute_model_predictions(model_selections, processed_data)
            
            if not predictions:
                logger.warning("所有模型预测失败，使用后备策略")
                self.stats['fallback_selections'] += 1
                return self._fallback_prediction(prediction_type, data)
            
            # 10. 融合预测结果
            if self.config['enable_fusion'] and len(predictions) > 1:
                final_prediction = self.fusion_engine.ensemble_prediction(
                    model_selections[:len(predictions)], predictions, market_state
                )
            else:
                final_prediction = predictions[0]
            
            # 11. 添加元数据
            final_prediction.update({
                'selection_metadata': {
                    'selected_models': [s.model_type for s in model_selections],
                    'market_state': market_state.__dict__,
                    'data_quality': data_quality,
                    'selection_confidence': np.mean([s.confidence for s in model_selections]),
                    'processing_time_ms': (datetime.now() - start_time).total_seconds() * 1000
                }
            })
            
            # 12. 记录性能数据（异步）
            if self.config['performance_tracking']:
                self._record_performance_async(
                    prediction_type, model_selections, market_state, 
                    final_prediction, processed_data
                )
            
            # 13. 缓存结果
            if self.config['enable_cache']:
                self._cache_result(cache_key, final_prediction)
            
            # 14. 更新统计
            self._update_selection_stats(start_time, True)
            self.stats['successful_selections'] += 1
            
            return final_prediction
            
        except Exception as e:
            logger.error(f"智能预测失败: {e}")
            self._update_selection_stats(start_time, False)
            return self._fallback_prediction(prediction_type, data)
```

## 配置管理

### 模型档案配置 (ModelProfiles)
```python
class ModelProfiles:
    """模型档案配置管理"""
    
    PROFILES = {
        'pattern_recognition': {
            'models': ['deep_learning', 'rule_based', 'statistical'],
            'default_ensemble_size': 2,
            'performance_weights': {
                'accuracy': 0.4,
                'speed': 0.3,
                'stability': 0.3
            },
            'market_conditions': {
                'high_volatility': ['rule_based', 'statistical'],
                'strong_trend': ['deep_learning', 'statistical'],
                'normal': ['deep_learning', 'rule_based']
            }
        },
        'trend_prediction': {
            'models': ['lstm', 'transformer', 'arima', 'rule_based'],
            'default_ensemble_size': 3,
            'performance_weights': {
                'accuracy': 0.5,
                'speed': 0.2,
                'stability': 0.3
            },
            'market_conditions': {
                'high_volatility': ['rule_based', 'arima'],
                'strong_trend': ['lstm', 'transformer'],
                'normal': ['lstm', 'arima', 'rule_based']
            }
        },
        'sentiment_analysis': {
            'models': ['bert', 'vader', 'textblob', 'rule_based'],
            'default_ensemble_size': 2,
            'performance_weights': {
                'accuracy': 0.6,
                'speed': 0.2,
                'stability': 0.2
            },
            'market_conditions': {
                'high_volatility': ['vader', 'rule_based'],
                'strong_trend': ['bert', 'textblob'],
                'normal': ['bert', 'vader']
            }
        }
    }
    
    @classmethod
    def get_profile(cls, prediction_type: str) -> Dict[str, Any]:
        """获取模型档案配置"""
        return cls.PROFILES.get(prediction_type, cls.PROFILES['pattern_recognition'])
```

### 选择器配置 (SelectorConfig)
```python
class SelectorConfig:
    """智能选择器配置"""
    
    DEFAULT_CONFIG = {
        'enable_cache': True,
        'cache_ttl': 300,  # 5分钟
        'enable_fusion': True,
        'max_ensemble_size': 3,
        'performance_tracking': True,
        
        'market_detector': {
            'volatility': {
                'high_vol_threshold': 0.3,
                'low_vol_threshold': 0.1,
                'lookback_period': 60
            },
            'trend': {
                'strong_trend_threshold': 0.7,
                'weak_trend_threshold': 0.3,
                'ma_periods': [20, 50, 200]
            },
            'regime': {
                'bull_market_threshold': 0.6,
                'bear_market_threshold': -0.6,
                'sideways_threshold': 0.2
            },
            'liquidity': {
                'high_liquidity_threshold': 1000000,
                'low_liquidity_threshold': 100000
            }
        },
        
        'performance_evaluator': {
            'database': {
                'type': 'sqlite',
                'path': 'data/performance.db'
            },
            'metric_weights': {
                'accuracy': 0.3,
                'precision': 0.2,
                'recall': 0.2,
                'f1_score': 0.15,
                'mape': 0.1,
                'sharpe_ratio': 0.05
            },
            'min_samples': 100
        },
        
        'selection_strategy': {
            'decision_matrix': {
                'method': 'topsis',
                'normalize': True
            },
            'constraints': {
                'max_latency_ms': 1000,
                'min_accuracy': 0.6,
                'max_memory_mb': 2048
            },
            'ensemble': {
                'min_models': 1,
                'max_models': 3,
                'weight_calculation': 'performance_based'
            }
        },
        
        'fusion_engine': {
            'default_strategy': 'weighted_average',
            'weighted_average': {
                'method': 'performance_weighted'
            },
            'stacking': {
                'meta_learner': 'linear_regression'
            },
            'bayesian': {
                'prior_strength': 0.1
            }
        }
    }
    
    @classmethod
    def get_config(cls, prediction_type: str = None) -> Dict[str, Any]:
        """获取配置，支持按预测类型定制"""
        config = cls.DEFAULT_CONFIG.copy()
        
        if prediction_type:
            profile = ModelProfiles.get_profile(prediction_type)
            # 合并档案特定配置
            config.update(profile)
        
        return config
```

## 集成方案

### 1. 服务集成

#### 修改 core/services/ai_prediction_service.py
```python
# 在 AIPredictionService 类中添加智能选择器
from core.ai.intelligent_selection import IntelligentModelSelector

class AIPredictionService:
    def __init__(self, config: Dict[str, Any]):
        # ... 现有初始化代码 ...
        
        # 初始化智能选择器
        self.intelligent_selector = IntelligentModelSelector(
            self, 
            config.get('intelligent_selector', {})
        )
        
        logger.info("AI预测服务智能选择器初始化完成")
    
    def intelligent_predict_patterns(self, 
                                   kdata: pd.DataFrame, 
                                   patterns: List[Dict],
                                   **kwargs) -> Dict[str, Any]:
        """
        智能形态预测接口
        
        Args:
            kdata: K线数据
            patterns: 检测到的形态列表
            **kwargs: 智能选择参数
            
        Returns:
            智能选择后的预测结果
        """
        return self.intelligent_selector.intelligent_predict(
            prediction_type="pattern_recognition",
            data={
                'kdata': kdata,
                'patterns': patterns
            },
            **kwargs
        )
    
    def intelligent_predict_trends(self,
                                 kdata: pd.DataFrame,
                                 market_data: Dict[str, Any],
                                 **kwargs) -> Dict[str, Any]:
        """智能趋势预测接口"""
        return self.intelligent_selector.intelligent_predict(
            prediction_type="trend_prediction",
            data={
                'kdata': kdata,
                'market_data': market_data
            },
            **kwargs
        )
    
    def intelligent_predict_sentiment(self,
                                    news_data: List[Dict],
                                    social_data: List[Dict],
                                    **kwargs) -> Dict[str, Any]:
        """智能情绪分析接口"""
        return self.intelligent_selector.intelligent_predict(
            prediction_type="sentiment_analysis",
            data={
                'news_data': news_data,
                'social_data': social_data
            },
            **kwargs
        )
```

### 2. 配置集成

#### 修改配置文件
```json
{
  "ai_prediction_service": {
    "intelligent_selector": {
      "enable_cache": true,
      "cache_ttl": 300,
      "enable_fusion": true,
      "max_ensemble_size": 3,
      "performance_tracking": true,
      "market_detector": {
        "volatility": {
          "high_vol_threshold": 0.3,
          "low_vol_threshold": 0.1
        }
      },
      "performance_evaluator": {
        "database": {
          "type": "sqlite",
          "path": "data/performance.db"
        }
      }
    }
  }
}
```

### 3. 主程序集成

#### 修改 main.py
```python
# 在 FactorWeaveQuantApplication 类中添加智能选择器初始化
def _initialize_core_components(self):
    """初始化核心组件"""
    # ... 现有代码 ...
    
    # 初始化AI预测服务（包含智能选择器）
    ai_service = AIPredictionService(self.config.get('ai_prediction_service', {}))
    self.services['ai_prediction'] = ai_service
    
    logger.info("AI预测服务（智能选择器）初始化完成")
```

## 使用示例

### 基本使用
```python
# 获取AI预测服务
ai_service = self.services['ai_prediction']

# 执行智能形态预测
patterns_result = ai_service.intelligent_predict_patterns(
    kdata=kline_data,
    patterns=detected_patterns,
    max_latency=500,  # 最大延迟500ms
    min_accuracy=0.7,  # 最低准确率要求
    ensemble_size=2   # 模型组合大小
)

# 执行智能趋势预测
trend_result = ai_service.intelligent_predict_trends(
    kdata=kline_data,
    market_data=market_info,
    max_latency=1000,
    min_accuracy=0.6
)
```

### 高级配置
```python
# 自定义配置
custom_config = {
    'enable_cache': True,
    'max_ensemble_size': 4,
    'performance_tracking': True,
    'market_detector': {
        'volatility': {
            'high_vol_threshold': 0.25,
            'low_vol_threshold': 0.15
        }
    }
}

# 使用自定义配置创建选择器
selector = IntelligentModelSelector(ai_service, custom_config)
result = selector.intelligent_predict(
    prediction_type="pattern_recognition",
    data={'kdata': data, 'patterns': patterns}
)
```

## 性能监控

### 统计信息
```python
class PerformanceMonitor:
    """性能监控器"""
    
    def __init__(self):
        self.metrics = {
            'selection_accuracy': [],
            'processing_time': [],
            'cache_hit_rate': [],
            'fusion_improvement': []
        }
    
    def record_selection_performance(self, 
                                   prediction_type: str,
                                   selection_metadata: Dict[str, Any],
                                   actual_result: Dict[str, Any]):
        """记录选择性能"""
        
        # 记录选择准确率
        accuracy = self._calculate_selection_accuracy(
            selection_metadata, actual_result
        )
        self.metrics['selection_accuracy'].append(accuracy)
        
        # 记录处理时间
        processing_time = selection_metadata.get('processing_time_ms', 0)
        self.metrics['processing_time'].append(processing_time)
        
        # 记录融合改进
        if 'fusion_metadata' in selection_metadata:
            improvement = self._calculate_fusion_improvement(
                selection_metadata['fusion_metadata']
            )
            self.metrics['fusion_improvement'].append(improvement)
    
    def generate_performance_report(self) -> Dict[str, Any]:
        """生成性能报告"""
        return {
            'avg_selection_accuracy': np.mean(self.metrics['selection_accuracy']),
            'avg_processing_time': np.mean(self.metrics['processing_time']),
            'cache_hit_rate': self._calculate_cache_hit_rate(),
            'fusion_improvement': np.mean(self.metrics['fusion_improvement']),
            'total_selections': len(self.metrics['selection_accuracy'])
        }
```

## 故障处理

### 后备策略
```python
class FallbackStrategy:
    """后备策略处理器"""
    
    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.fallback_models = {
            'pattern_recognition': 'rule_based',
            'trend_prediction': 'rule_based',
            'sentiment_analysis': 'rule_based',
            'price_prediction': 'statistical'
        }
    
    def handle_selection_failure(self,
                               prediction_type: str,
                               original_data: Dict[str, Any]) -> Dict[str, Any]:
        """处理选择失败"""
        
        fallback_model = self.fallback_models.get(prediction_type, 'rule_based')
        
        logger.warning(f"智能选择失败，使用后备模型: {fallback_model}")
        
        # 返回后备预测结果
        return {
            'prediction': self._generate_fallback_prediction(
                fallback_model, original_data
            ),
            'selection_metadata': {
                'used_fallback': True,
                'fallback_model': fallback_model,
                'fallback_reason': 'intelligent_selection_failed'
            }
        }
```

## 总结

智能模型选择机制通过市场状态检测、模型性能评估、动态选择策略和预测结果融合四个核心模块，实现了基于市场环境的自适应模型选择。该机制具备以下特点：

1. **智能化**: 根据市场状态自动选择最适合的模型组合
2. **自适应性**: 动态调整选择策略以适应不同市场环境
3. **高性能**: 通过缓存和多模型融合提升预测准确率
4. **可扩展性**: 模块化设计便于添加新的模型和策略
5. **可靠性**: 完善的错误处理和后备策略确保系统稳定运行

通过本实施指导，开发团队可以完整地实现和集成智能模型选择机制，显著提升AI预测服务的智能化水平和预测准确率。