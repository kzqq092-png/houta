# FactorWeave-Quantè¿œç¨‹æ’ä»¶åŠ è½½ç³»ç»Ÿè®¾è®¡

> **ä¼ä¸šçº§è¿œç¨‹æ’ä»¶ç®¡ç†**: å®‰å…¨ + ä¾¿åˆ© + æ‰©å±•æ€§
> **å…¼å®¹ç°æœ‰æ¶æ„**: 100%å…¼å®¹ç°æœ‰æ’ä»¶æ¥å£å’Œè£…é¥°å™¨
> **å•†ä¸šåŒ–æ”¯æŒ**: æ”¯æŒä»˜è´¹æ’ä»¶ã€ä¼ä¸šç§æœ‰ä»“åº“ã€æˆæƒç®¡ç†

## ğŸ¯ è®¾è®¡ç›®æ ‡

### æ ¸å¿ƒéœ€æ±‚
```python
å®‰å…¨æ€§: æ•°å­—ç­¾å + å®Œæ•´æ€§éªŒè¯ + æ²™ç®±æ‰§è¡Œ
ä¾¿åˆ©æ€§: ä¸€é”®å®‰è£… + è‡ªåŠ¨æ›´æ–° + ç¦»çº¿æ”¯æŒ  
æ‰©å±•æ€§: å¤šä»“åº“æº + ç¬¬ä¸‰æ–¹é›†æˆ + ä¼ä¸šçº§ç®¡ç†
å…¼å®¹æ€§: ç°æœ‰@plugin_metadataè£…é¥°å™¨100%å…¼å®¹
å•†ä¸šåŒ–: ä»˜è´¹æ’ä»¶ + æˆæƒç®¡ç† + ä½¿ç”¨ç»Ÿè®¡
```

### ä¸šåŠ¡åœºæ™¯
```python
1. å…¬å…±æ’ä»¶å¸‚åœº: å…è´¹å¼€æºæ’ä»¶çš„è¿œç¨‹åˆ†å‘
2. å•†ä¸šæ’ä»¶ç”Ÿæ€: ä»˜è´¹æ’ä»¶çš„æˆæƒå’Œäº¤ä»˜
3. ä¼ä¸šå†…éƒ¨ç®¡ç†: ç§æœ‰æ’ä»¶ä»“åº“çš„é›†ä¸­ç®¡ç†
4. ç¬¬ä¸‰æ–¹é›†æˆ: åˆä½œä¼™ä¼´æ’ä»¶çš„è¿œç¨‹å‘å¸ƒ
5. è‡ªåŠ¨åŒ–è¿ç»´: æ’ä»¶çš„æ‰¹é‡éƒ¨ç½²å’Œæ›´æ–°
```

## ğŸ—ï¸ ç³»ç»Ÿæ¶æ„è®¾è®¡

### åˆ†å±‚æ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                FactorWeave-Quantè¿œç¨‹æ’ä»¶åŠ è½½ç³»ç»Ÿæ¶æ„                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  UIäº¤äº’å±‚        â”‚    ä¸šåŠ¡é€»è¾‘å±‚      â”‚    æ•°æ®ä¼ è¾“å±‚       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚æ’ä»¶å¸‚åœºç•Œé¢  â”‚â—„â”¼â”€â”€â”‚è¿œç¨‹æ’ä»¶ç®¡ç†å™¨  â”‚â—„â”¼â”€â”€â”‚å®‰å…¨ä¼ è¾“åè®®   â”‚  â”‚
â”‚  â”‚å®‰è£…è¿›åº¦æ˜¾ç¤º  â”‚ â”‚  â”‚ç‰ˆæœ¬æ§åˆ¶å™¨     â”‚ â”‚  â”‚æ•°å­—ç­¾åéªŒè¯   â”‚  â”‚
â”‚  â”‚æƒé™ç¡®è®¤å¯¹è¯  â”‚ â”‚  â”‚æˆæƒç®¡ç†å™¨     â”‚ â”‚  â”‚å®Œæ•´æ€§æ ¡éªŒ     â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ç¼“å­˜å­˜å‚¨å±‚      â”‚    å®‰å…¨æ‰§è¡Œå±‚      â”‚    å…¼å®¹é€‚é…å±‚       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚æœ¬åœ°æ’ä»¶ç¼“å­˜  â”‚ â”‚  â”‚æ²™ç®±æ‰§è¡Œç¯å¢ƒ   â”‚ â”‚  â”‚ç°æœ‰æ¥å£æ¡¥æ¥   â”‚  â”‚
â”‚  â”‚ç‰ˆæœ¬ä¾èµ–ç®¡ç†  â”‚â—„â”¼â”€â”€â”‚èµ„æºé™åˆ¶æ§åˆ¶   â”‚â—„â”¼â”€â”€â”‚è£…é¥°å™¨å…¼å®¹     â”‚  â”‚
â”‚  â”‚ç¦»çº¿æ¨¡å¼æ”¯æŒ  â”‚ â”‚  â”‚æƒé™ç»†ç²’æ§åˆ¶   â”‚ â”‚  â”‚PluginManager â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### æ ¸å¿ƒç»„ä»¶è®¾è®¡

#### 1. è¿œç¨‹æ’ä»¶ä»“åº“æœåŠ¡ (Remote Plugin Registry)

```python
class RemotePluginRegistry:
    """è¿œç¨‹æ’ä»¶ä»“åº“å®¢æˆ·ç«¯"""
    
    def __init__(self, config_manager, security_manager):
        self.config = config_manager
        self.security = security_manager
        self.repositories = self._load_repository_configs()
        self.auth_manager = RemoteAuthManager()
        
    async def search_plugins(self, query: str, filters: dict = None) -> List[RemotePluginInfo]:
        """æœç´¢è¿œç¨‹æ’ä»¶"""
        search_results = []
        
        for repo in self.repositories:
            try:
                # æ„å»ºæœç´¢è¯·æ±‚
                search_request = {
                    'query': query,
                    'filters': filters or {},
                    'client_version': '2.0.1',
                    'supported_types': [t.value for t in PluginType],
                    'auth_token': await self.auth_manager.get_token(repo['name'])
                }
                
                # å‘é€HTTPSè¯·æ±‚
                async with aiohttp.ClientSession() as session:
                    headers = {
                        'Authorization': f"Bearer {search_request['auth_token']}",
                        'Content-Type': 'application/json',
                        'User-Agent': 'FactorWeave-Quant-Plugin-Client/2.0.1'
                    }
                    
                    async with session.post(
                        f"{repo['url']}/api/v1/plugins/search",
                        json=search_request,
                        headers=headers,
                        ssl=True  # å¼ºåˆ¶HTTPS
                    ) as response:
                        
                        if response.status == 200:
                            data = await response.json()
                            plugins = [RemotePluginInfo.from_dict(p) for p in data['plugins']]
                            search_results.extend(plugins)
                        else:
                            logger.warning(f"æœç´¢å¤±è´¥ {repo['name']}: {response.status}")
                            
            except Exception as e:
                logger.error(f"ä»“åº“æœç´¢å¼‚å¸¸ {repo['name']}: {e}")
                continue
        
        return search_results
    
    async def get_plugin_details(self, plugin_id: str, repository: str) -> RemotePluginDetails:
        """è·å–æ’ä»¶è¯¦ç»†ä¿¡æ¯"""
        repo_config = self._get_repository_config(repository)
        if not repo_config:
            raise RepositoryNotFoundError(f"ä»“åº“æœªé…ç½®: {repository}")
        
        try:
            auth_token = await self.auth_manager.get_token(repository)
            
            async with aiohttp.ClientSession() as session:
                headers = {
                    'Authorization': f"Bearer {auth_token}",
                    'User-Agent': 'FactorWeave-Quant-Plugin-Client/2.0.1'
                }
                
                async with session.get(
                    f"{repo_config['url']}/api/v1/plugins/{plugin_id}",
                    headers=headers,
                    ssl=True
                ) as response:
                    
                    if response.status == 200:
                        data = await response.json()
                        return RemotePluginDetails.from_dict(data['plugin'])
                    elif response.status == 404:
                        raise PluginNotFoundError(f"æ’ä»¶ä¸å­˜åœ¨: {plugin_id}")
                    elif response.status == 403:
                        raise AuthorizationError(f"æ— æƒé™è®¿é—®æ’ä»¶: {plugin_id}")
                    else:
                        raise RemoteRegistryError(f"è·å–æ’ä»¶è¯¦æƒ…å¤±è´¥: {response.status}")
                        
        except Exception as e:
            logger.error(f"è·å–æ’ä»¶è¯¦æƒ…å¼‚å¸¸ {plugin_id}: {e}")
            raise

@dataclass
class RemotePluginInfo:
    """è¿œç¨‹æ’ä»¶ä¿¡æ¯"""
    plugin_id: str
    name: str
    version: str
    plugin_type: PluginType
    category: PluginCategory
    description: str
    author: str
    
    # è¿œç¨‹ç‰¹æœ‰å­—æ®µ
    repository: str
    download_url: str
    signature_url: str
    file_size: int
    file_hash: str
    
    # å•†ä¸šåŒ–å­—æ®µ
    is_paid: bool = False
    price: float = 0.0
    license_type: str = "MIT"
    required_permissions: List[str] = field(default_factory=list)
    
    # ç»Ÿè®¡å­—æ®µ
    download_count: int = 0
    rating: float = 0.0
    rating_count: int = 0
    
    @classmethod
    def from_dict(cls, data: dict) -> 'RemotePluginInfo':
        """ä»å­—å…¸åˆ›å»ºå®ä¾‹"""
        return cls(
            plugin_id=data['plugin_id'],
            name=data['name'],
            version=data['version'],
            plugin_type=PluginType(data['plugin_type']),
            category=PluginCategory(data['category']),
            description=data['description'],
            author=data['author'],
            repository=data['repository'],
            download_url=data['download_url'],
            signature_url=data['signature_url'],
            file_size=data['file_size'],
            file_hash=data['file_hash'],
            is_paid=data.get('is_paid', False),
            price=data.get('price', 0.0),
            license_type=data.get('license_type', 'MIT'),
            required_permissions=data.get('required_permissions', []),
            download_count=data.get('download_count', 0),
            rating=data.get('rating', 0.0),
            rating_count=data.get('rating_count', 0)
        )
```

#### 2. å®‰å…¨ä¸‹è½½å’ŒéªŒè¯æ¨¡å—

```python
class SecurePluginDownloader:
    """å®‰å…¨æ’ä»¶ä¸‹è½½å™¨"""
    
    def __init__(self, security_manager, cache_manager):
        self.security = security_manager
        self.cache = cache_manager
        self.download_progress = {}
        
    async def download_and_verify_plugin(
        self, 
        plugin_info: RemotePluginInfo,
        progress_callback: Optional[Callable] = None
    ) -> PluginPackage:
        """å®‰å…¨ä¸‹è½½å’ŒéªŒè¯æ’ä»¶"""
        
        download_id = f"{plugin_info.repository}_{plugin_info.plugin_id}_{plugin_info.version}"
        
        try:
            # 1. æ£€æŸ¥æœ¬åœ°ç¼“å­˜
            cached_plugin = await self.cache.get_cached_plugin(
                plugin_info.plugin_id, 
                plugin_info.version,
                plugin_info.file_hash
            )
            
            if cached_plugin and await self._verify_cached_plugin(cached_plugin):
                logger.info(f"ä½¿ç”¨ç¼“å­˜æ’ä»¶: {plugin_info.name}")
                return cached_plugin
            
            # 2. åˆ›å»ºä¸´æ—¶ä¸‹è½½ç›®å½•
            download_dir = Path(tempfile.mkdtemp(prefix=f"FactorWeave-Quant_plugin_{download_id}_"))
            
            try:
                # 3. ä¸‹è½½æ’ä»¶æ–‡ä»¶
                plugin_file_path = await self._download_plugin_file(
                    plugin_info, download_dir, progress_callback
                )
                
                # 4. ä¸‹è½½æ•°å­—ç­¾å
                signature_file_path = await self._download_signature_file(
                    plugin_info, download_dir
                )
                
                # 5. éªŒè¯æ•°å­—ç­¾å
                signature_valid = await self.security.verify_plugin_signature(
                    plugin_file_path, signature_file_path, plugin_info.repository
                )
                
                if not signature_valid:
                    raise SecurityError(f"æ’ä»¶æ•°å­—ç­¾åéªŒè¯å¤±è´¥: {plugin_info.name}")
                
                # 6. éªŒè¯æ–‡ä»¶å®Œæ•´æ€§
                file_hash = await self._calculate_file_hash(plugin_file_path)
                if file_hash != plugin_info.file_hash:
                    raise IntegrityError(f"æ’ä»¶æ–‡ä»¶å®Œæ•´æ€§éªŒè¯å¤±è´¥: {plugin_info.name}")
                
                # 7. åˆ›å»ºæ’ä»¶åŒ…
                plugin_package = await self._create_plugin_package(
                    plugin_info, plugin_file_path, download_dir
                )
                
                # 8. ç¼“å­˜å·²éªŒè¯çš„æ’ä»¶
                await self.cache.cache_plugin(plugin_package)
                
                logger.info(f"æ’ä»¶ä¸‹è½½éªŒè¯æˆåŠŸ: {plugin_info.name}")
                return plugin_package
                
            finally:
                # æ¸…ç†ä¸´æ—¶ç›®å½•
                shutil.rmtree(download_dir, ignore_errors=True)
                
        except Exception as e:
            logger.error(f"æ’ä»¶ä¸‹è½½å¤±è´¥ {plugin_info.name}: {e}")
            raise
        finally:
            # æ¸…ç†è¿›åº¦è®°å½•
            self.download_progress.pop(download_id, None)
    
    async def _download_plugin_file(
        self,
        plugin_info: RemotePluginInfo, 
        download_dir: Path,
        progress_callback: Optional[Callable]
    ) -> Path:
        """ä¸‹è½½æ’ä»¶æ–‡ä»¶"""
        
        file_path = download_dir / f"{plugin_info.plugin_id}.hpk"
        download_id = f"{plugin_info.repository}_{plugin_info.plugin_id}"
        
        try:
            async with aiohttp.ClientSession() as session:
                async with session.get(plugin_info.download_url) as response:
                    
                    if response.status != 200:
                        raise DownloadError(f"ä¸‹è½½å¤±è´¥: HTTP {response.status}")
                    
                    # éªŒè¯å†…å®¹é•¿åº¦
                    content_length = int(response.headers.get('Content-Length', 0))
                    if content_length != plugin_info.file_size:
                        raise DownloadError(f"æ–‡ä»¶å¤§å°ä¸åŒ¹é…: æœŸæœ›{plugin_info.file_size}, å®é™…{content_length}")
                    
                    # æµå¼ä¸‹è½½å¹¶æ˜¾ç¤ºè¿›åº¦
                    downloaded = 0
                    chunk_size = 8192
                    
                    with open(file_path, 'wb') as f:
                        async for chunk in response.content.iter_chunked(chunk_size):
                            f.write(chunk)
                            downloaded += len(chunk)
                            
                            # æ›´æ–°è¿›åº¦
                            progress = (downloaded / content_length) * 100 if content_length > 0 else 0
                            self.download_progress[download_id] = {
                                'downloaded': downloaded,
                                'total': content_length,
                                'progress': progress
                            }
                            
                            # å›è°ƒè¿›åº¦æ›´æ–°
                            if progress_callback:
                                await progress_callback(progress, downloaded, content_length)
            
            return file_path
            
        except Exception as e:
            logger.error(f"ä¸‹è½½æ’ä»¶æ–‡ä»¶å¤±è´¥: {e}")
            raise
    
    async def _create_plugin_package(
        self,
        plugin_info: RemotePluginInfo,
        plugin_file_path: Path,
        extract_dir: Path
    ) -> PluginPackage:
        """åˆ›å»ºæ’ä»¶åŒ…å¯¹è±¡"""
        
        # è§£å‹æ’ä»¶åŒ… (å‡è®¾æ˜¯.hpkæ ¼å¼çš„zipæ–‡ä»¶)
        with zipfile.ZipFile(plugin_file_path, 'r') as zip_ref:
            zip_ref.extractall(extract_dir)
        
        # æŸ¥æ‰¾ä¸»æ’ä»¶æ–‡ä»¶
        plugin_main_file = None
        manifest_file = extract_dir / "manifest.json"
        
        if manifest_file.exists():
            # ä»manifest.jsonè¯»å–ä¸»æ–‡ä»¶ä¿¡æ¯
            with open(manifest_file, 'r', encoding='utf-8') as f:
                manifest = json.load(f)
                plugin_main_file = extract_dir / manifest['main_file']
        else:
            # æœç´¢.pyæ–‡ä»¶
            py_files = list(extract_dir.glob("*.py"))
            if py_files:
                plugin_main_file = py_files[0]
        
        if not plugin_main_file or not plugin_main_file.exists():
            raise InvalidPluginError(f"æœªæ‰¾åˆ°æœ‰æ•ˆçš„æ’ä»¶ä¸»æ–‡ä»¶: {plugin_info.name}")
        
        return PluginPackage(
            plugin_info=plugin_info,
            main_file_path=plugin_main_file,
            extract_directory=extract_dir,
            manifest=manifest if 'manifest' in locals() else None,
            verified=True,
            cached=False
        )

@dataclass
class PluginPackage:
    """æ’ä»¶åŒ…"""
    plugin_info: RemotePluginInfo
    main_file_path: Path
    extract_directory: Path
    manifest: Optional[dict] = None
    verified: bool = False
    cached: bool = False
    
    def get_plugin_metadata(self) -> dict:
        """è·å–æ’ä»¶å…ƒæ•°æ®"""
        if self.manifest:
            return self.manifest.get('metadata', {})
        
        # ä»æ’ä»¶æ–‡ä»¶è§£æ@plugin_metadataè£…é¥°å™¨
        return self._extract_metadata_from_file()
    
    def _extract_metadata_from_file(self) -> dict:
        """ä»æ–‡ä»¶æå–å…ƒæ•°æ® - å…¼å®¹ç°æœ‰è£…é¥°å™¨"""
        try:
            with open(self.main_file_path, 'r', encoding='utf-8') as f:
                content = f.read()
            
            # è§£æASTæŸ¥æ‰¾@plugin_metadataè£…é¥°å™¨
            tree = ast.parse(content)
            
            for node in ast.walk(tree):
                if isinstance(node, ast.ClassDef):
                    for decorator in node.decorator_list:
                        if (isinstance(decorator, ast.Call) and 
                            hasattr(decorator.func, 'id') and 
                            decorator.func.id == 'plugin_metadata'):
                            
                            metadata = {}
                            for keyword in decorator.keywords:
                                try:
                                    if keyword.arg in ['plugin_type', 'category']:
                                        # å¤„ç†æšä¸¾å€¼
                                        if isinstance(keyword.value, ast.Attribute):
                                            metadata[keyword.arg] = keyword.value.attr.lower()
                                    else:
                                        # å¤„ç†æ™®é€šå€¼
                                        metadata[keyword.arg] = ast.literal_eval(keyword.value)
                                except:
                                    pass
                            
                            return metadata
            
            return {}
            
        except Exception as e:
            logger.warning(f"æå–æ’ä»¶å…ƒæ•°æ®å¤±è´¥: {e}")
            return {}
```

#### 3. æˆæƒå’Œè®¸å¯ç®¡ç†ç³»ç»Ÿ

```python
class RemoteAuthManager:
    """è¿œç¨‹æˆæƒç®¡ç†å™¨"""
    
    def __init__(self, config_manager, db_service):
        self.config = config_manager
        self.db = db_service
        self.token_cache = {}
        self.license_manager = PluginLicenseManager(db_service)
        
    async def authenticate_repository(self, repository: str, credentials: dict) -> str:
        """ä»“åº“è®¤è¯"""
        try:
            repo_config = self._get_repository_config(repository)
            
            auth_request = {
                'client_id': credentials.get('client_id'),
                'client_secret': credentials.get('client_secret'),
                'grant_type': 'client_credentials',
                'scope': 'plugin:read plugin:download'
            }
            
            async with aiohttp.ClientSession() as session:
                async with session.post(
                    f"{repo_config['auth_url']}/oauth/token",
                    data=auth_request,
                    headers={'Content-Type': 'application/x-www-form-urlencoded'}
                ) as response:
                    
                    if response.status == 200:
                        data = await response.json()
                        token = data['access_token']
                        expires_in = data.get('expires_in', 3600)
                        
                        # ç¼“å­˜token
                        self.token_cache[repository] = {
                            'token': token,
                            'expires_at': datetime.now() + timedelta(seconds=expires_in)
                        }
                        
                        # ä¿å­˜åˆ°æ•°æ®åº“
                        await self.db.save_auth_token(repository, token, expires_in)
                        
                        logger.info(f"ä»“åº“è®¤è¯æˆåŠŸ: {repository}")
                        return token
                    else:
                        raise AuthenticationError(f"ä»“åº“è®¤è¯å¤±è´¥: {response.status}")
                        
        except Exception as e:
            logger.error(f"ä»“åº“è®¤è¯å¼‚å¸¸ {repository}: {e}")
            raise
    
    async def get_token(self, repository: str) -> str:
        """è·å–æœ‰æ•ˆtoken"""
        # æ£€æŸ¥ç¼“å­˜
        cached_token = self.token_cache.get(repository)
        if cached_token and cached_token['expires_at'] > datetime.now():
            return cached_token['token']
        
        # ä»æ•°æ®åº“è·å–
        db_token = await self.db.get_auth_token(repository)
        if db_token and db_token['expires_at'] > datetime.now():
            self.token_cache[repository] = db_token
            return db_token['token']
        
        # éœ€è¦é‡æ–°è®¤è¯
        credentials = await self._get_repository_credentials(repository)
        if credentials:
            return await self.authenticate_repository(repository, credentials)
        else:
            raise AuthenticationError(f"ä»“åº“æ— è®¤è¯å‡­æ®: {repository}")
    
    async def check_plugin_license(self, plugin_info: RemotePluginInfo) -> LicenseCheckResult:
        """æ£€æŸ¥æ’ä»¶è®¸å¯è¯"""
        if not plugin_info.is_paid:
            return LicenseCheckResult(
                valid=True,
                license_type='free',
                message='å…è´¹æ’ä»¶'
            )
        
        # æ£€æŸ¥å·²è´­ä¹°è®¸å¯è¯
        license_record = await self.license_manager.get_plugin_license(
            plugin_info.plugin_id, 
            plugin_info.version
        )
        
        if license_record:
            # éªŒè¯è®¸å¯è¯æœ‰æ•ˆæ€§
            if await self._verify_license_validity(license_record, plugin_info):
                return LicenseCheckResult(
                    valid=True,
                    license_type='purchased',
                    license_info=license_record,
                    message='è®¸å¯è¯æœ‰æ•ˆ'
                )
            else:
                return LicenseCheckResult(
                    valid=False,
                    license_type='expired',
                    license_info=license_record,
                    message='è®¸å¯è¯å·²è¿‡æœŸ'
                )
        else:
            return LicenseCheckResult(
                valid=False,
                license_type='required',
                message=f'éœ€è¦è´­ä¹°è®¸å¯è¯ï¼Œä»·æ ¼: ${plugin_info.price}'
            )
    
    async def purchase_plugin_license(
        self, 
        plugin_info: RemotePluginInfo,
        payment_info: dict
    ) -> PurchaseResult:
        """è´­ä¹°æ’ä»¶è®¸å¯è¯"""
        try:
            repo_config = self._get_repository_config(plugin_info.repository)
            auth_token = await self.get_token(plugin_info.repository)
            
            purchase_request = {
                'plugin_id': plugin_info.plugin_id,
                'version': plugin_info.version,
                'payment_method': payment_info['method'],
                'client_id': self.config.get('client_id'),
                'client_info': {
                    'platform': 'FactorWeave-Quant',
                    'version': '2.0.1',
                    'machine_id': self._get_machine_id()
                }
            }
            
            async with aiohttp.ClientSession() as session:
                headers = {
                    'Authorization': f"Bearer {auth_token}",
                    'Content-Type': 'application/json'
                }
                
                async with session.post(
                    f"{repo_config['url']}/api/v1/plugins/{plugin_info.plugin_id}/purchase",
                    json=purchase_request,
                    headers=headers
                ) as response:
                    
                    if response.status == 200:
                        data = await response.json()
                        
                        # ä¿å­˜è®¸å¯è¯
                        license_info = LicenseInfo(
                            plugin_id=plugin_info.plugin_id,
                            version=plugin_info.version,
                            license_key=data['license_key'],
                            issued_at=datetime.fromisoformat(data['issued_at']),
                            expires_at=datetime.fromisoformat(data['expires_at']) if data.get('expires_at') else None,
                            license_type=data['license_type'],
                            repository=plugin_info.repository
                        )
                        
                        await self.license_manager.save_license(license_info)
                        
                        return PurchaseResult(
                            success=True,
                            license_info=license_info,
                            message='è´­ä¹°æˆåŠŸ'
                        )
                    else:
                        return PurchaseResult(
                            success=False,
                            message=f'è´­ä¹°å¤±è´¥: {response.status}'
                        )
                        
        except Exception as e:
            logger.error(f"è´­ä¹°æ’ä»¶è®¸å¯è¯å¤±è´¥: {e}")
            return PurchaseResult(
                success=False,
                message=f'è´­ä¹°å¼‚å¸¸: {e}'
            )

@dataclass
class LicenseCheckResult:
    """è®¸å¯è¯æ£€æŸ¥ç»“æœ"""
    valid: bool
    license_type: str  # free/purchased/expired/required
    license_info: Optional['LicenseInfo'] = None
    message: str = ""

@dataclass  
class PurchaseResult:
    """è´­ä¹°ç»“æœ"""
    success: bool
    license_info: Optional['LicenseInfo'] = None
    message: str = ""

@dataclass
class LicenseInfo:
    """è®¸å¯è¯ä¿¡æ¯"""
    plugin_id: str
    version: str
    license_key: str
    issued_at: datetime
    expires_at: Optional[datetime]
    license_type: str  # perpetual/subscription/trial
    repository: str
    machine_bindings: List[str] = field(default_factory=list)
```

#### 4. è¿œç¨‹æ’ä»¶ç®¡ç†å™¨é›†æˆ

```python
class RemotePluginManager:
    """è¿œç¨‹æ’ä»¶ç®¡ç†å™¨ - é›†æˆåˆ°ç°æœ‰ç³»ç»Ÿ"""
    
    def __init__(self, existing_plugin_manager, db_service):
        self.existing_manager = existing_plugin_manager
        self.db = db_service
        self.registry = RemotePluginRegistry(
            existing_plugin_manager.config_manager,
            SecurityManager(db_service)
        )
        self.downloader = SecurePluginDownloader(
            SecurityManager(db_service),
            PluginCacheManager(db_service)
        )
        self.auth_manager = RemoteAuthManager(
            existing_plugin_manager.config_manager,
            db_service
        )
        
    async def install_remote_plugin(
        self, 
        plugin_info: RemotePluginInfo,
        progress_callback: Optional[Callable] = None
    ) -> InstallResult:
        """å®‰è£…è¿œç¨‹æ’ä»¶"""
        try:
            # 1. æ£€æŸ¥è®¸å¯è¯
            license_check = await self.auth_manager.check_plugin_license(plugin_info)
            if not license_check.valid:
                if license_check.license_type == 'required':
                    return InstallResult(
                        success=False,
                        error_type='license_required',
                        message=license_check.message,
                        plugin_info=plugin_info
                    )
                else:
                    return InstallResult(
                        success=False, 
                        error_type='license_invalid',
                        message=license_check.message
                    )
            
            # 2. æ£€æŸ¥ä¾èµ–å’Œå…¼å®¹æ€§
            compatibility_check = await self._check_plugin_compatibility(plugin_info)
            if not compatibility_check.compatible:
                return InstallResult(
                    success=False,
                    error_type='compatibility',
                    message=compatibility_check.reason
                )
            
            # 3. ä¸‹è½½å’ŒéªŒè¯æ’ä»¶
            plugin_package = await self.downloader.download_and_verify_plugin(
                plugin_info, progress_callback
            )
            
            # 4. æ£€æŸ¥æƒé™éœ€æ±‚
            if plugin_info.required_permissions:
                permission_granted = await self._request_user_permissions(
                    plugin_info.required_permissions
                )
                if not permission_granted:
                    return InstallResult(
                        success=False,
                        error_type='permission_denied',
                        message='ç”¨æˆ·æ‹’ç»æˆæƒæ‰€éœ€æƒé™'
                    )
            
            # 5. å®‰è£…æ’ä»¶åˆ°æœ¬åœ°
            local_install_result = await self._install_plugin_locally(plugin_package)
            if not local_install_result.success:
                return local_install_result
            
            # 6. æ³¨å†Œåˆ°ç°æœ‰æ’ä»¶ç®¡ç†å™¨
            success = self.existing_manager.load_plugin(
                plugin_package.plugin_info.name,
                plugin_package.main_file_path
            )
            
            if success:
                # 7. æ›´æ–°æ•°æ®åº“è®°å½•
                await self.db.record_plugin_installation(
                    plugin_info,
                    local_install_result.install_path,
                    'remote_install'
                )
                
                # 8. è®°å½•ä½¿ç”¨ç»Ÿè®¡
                await self._record_usage_statistics(plugin_info, 'install')
                
                return InstallResult(
                    success=True,
                    message=f'æ’ä»¶å®‰è£…æˆåŠŸ: {plugin_info.name}',
                    install_path=local_install_result.install_path
                )
            else:
                return InstallResult(
                    success=False,
                    error_type='load_failed',
                    message='æ’ä»¶åŠ è½½å¤±è´¥'
                )
                
        except Exception as e:
            logger.error(f"è¿œç¨‹æ’ä»¶å®‰è£…å¤±è´¥ {plugin_info.name}: {e}")
            return InstallResult(
                success=False,
                error_type='install_error',
                message=str(e)
            )
    
    async def check_plugin_updates(self) -> List[PluginUpdateInfo]:
        """æ£€æŸ¥æ’ä»¶æ›´æ–°"""
        update_list = []
        
        try:
            # è·å–æ‰€æœ‰å·²å®‰è£…çš„è¿œç¨‹æ’ä»¶
            installed_remote_plugins = await self.db.get_installed_remote_plugins()
            
            for plugin_record in installed_remote_plugins:
                try:
                    # æŸ¥è¯¢è¿œç¨‹æœ€æ–°ç‰ˆæœ¬
                    latest_info = await self.registry.get_plugin_details(
                        plugin_record['plugin_id'],
                        plugin_record['repository']
                    )
                    
                    # æ¯”è¾ƒç‰ˆæœ¬
                    if self._is_newer_version(latest_info.version, plugin_record['version']):
                        update_info = PluginUpdateInfo(
                            plugin_id=plugin_record['plugin_id'],
                            current_version=plugin_record['version'],
                            latest_version=latest_info.version,
                            repository=plugin_record['repository'],
                            update_available=True,
                            release_notes=latest_info.changelog,
                            breaking_changes=latest_info.breaking_changes
                        )
                        update_list.append(update_info)
                        
                except Exception as e:
                    logger.warning(f"æ£€æŸ¥æ›´æ–°å¤±è´¥ {plugin_record['plugin_id']}: {e}")
                    continue
            
            return update_list
            
        except Exception as e:
            logger.error(f"æ£€æŸ¥æ’ä»¶æ›´æ–°å¤±è´¥: {e}")
            return []
    
    async def update_plugin(
        self, 
        plugin_id: str,
        target_version: str = None,
        progress_callback: Optional[Callable] = None
    ) -> UpdateResult:
        """æ›´æ–°æ’ä»¶"""
        try:
            # 1. è·å–å½“å‰æ’ä»¶ä¿¡æ¯
            current_plugin = await self.db.get_installed_plugin(plugin_id)
            if not current_plugin:
                return UpdateResult(
                    success=False,
                    message=f'æ’ä»¶æœªå®‰è£…: {plugin_id}'
                )
            
            # 2. è·å–ç›®æ ‡ç‰ˆæœ¬ä¿¡æ¯
            if not target_version:
                latest_info = await self.registry.get_plugin_details(
                    plugin_id, current_plugin['repository']
                )
                target_version = latest_info.version
            
            target_plugin_info = await self.registry.get_plugin_details(
                plugin_id, current_plugin['repository']
            )
            
            # 3. å¤‡ä»½å½“å‰ç‰ˆæœ¬
            backup_path = await self._backup_current_plugin(current_plugin)
            
            try:
                # 4. å¸è½½å½“å‰ç‰ˆæœ¬
                unload_success = self.existing_manager.unload_plugin(plugin_id)
                if not unload_success:
                    logger.warning(f"å¸è½½å½“å‰æ’ä»¶å¤±è´¥: {plugin_id}")
                
                # 5. å®‰è£…æ–°ç‰ˆæœ¬
                install_result = await self.install_remote_plugin(
                    target_plugin_info, progress_callback
                )
                
                if install_result.success:
                    # 6. æ¸…ç†å¤‡ä»½
                    await self._cleanup_backup(backup_path)
                    
                    # 7. æ›´æ–°æ•°æ®åº“è®°å½•
                    await self.db.update_plugin_version(
                        plugin_id, 
                        target_version,
                        'updated_from_remote'
                    )
                    
                    return UpdateResult(
                        success=True,
                        message=f'æ’ä»¶æ›´æ–°æˆåŠŸ: {plugin_id} -> {target_version}',
                        old_version=current_plugin['version'],
                        new_version=target_version
                    )
                else:
                    # 8. å›æ»šåˆ°å¤‡ä»½ç‰ˆæœ¬
                    await self._restore_from_backup(backup_path, current_plugin)
                    return UpdateResult(
                        success=False,
                        message=f'æ’ä»¶æ›´æ–°å¤±è´¥ï¼Œå·²å›æ»š: {install_result.message}'
                    )
                    
            except Exception as e:
                # å¼‚å¸¸æƒ…å†µä¸‹å›æ»š
                await self._restore_from_backup(backup_path, current_plugin)
                raise
                
        except Exception as e:
            logger.error(f"æ’ä»¶æ›´æ–°å¼‚å¸¸ {plugin_id}: {e}")
            return UpdateResult(
                success=False,
                message=f'æ›´æ–°å¼‚å¸¸: {e}'
            )

@dataclass
class InstallResult:
    """å®‰è£…ç»“æœ"""
    success: bool
    message: str = ""
    error_type: str = ""  # license_required/compatibility/permission_denied/install_error
    plugin_info: Optional[RemotePluginInfo] = None
    install_path: Optional[str] = None

@dataclass
class UpdateResult:
    """æ›´æ–°ç»“æœ"""
    success: bool
    message: str = ""
    old_version: str = ""
    new_version: str = ""

@dataclass
class PluginUpdateInfo:
    """æ’ä»¶æ›´æ–°ä¿¡æ¯"""
    plugin_id: str
    current_version: str
    latest_version: str
    repository: str
    update_available: bool
    release_notes: str = ""
    breaking_changes: List[str] = field(default_factory=list)
```

## ğŸ›ï¸ UIé›†æˆå’Œç”¨æˆ·ä½“éªŒ

### è¿œç¨‹æ’ä»¶å¸‚åœºç•Œé¢å¢å¼º

```python
class EnhancedPluginMarketDialog(QDialog):
    """å¢å¼ºçš„æ’ä»¶å¸‚åœºå¯¹è¯æ¡† - æ”¯æŒè¿œç¨‹æ’ä»¶"""
    
    def __init__(self, existing_plugin_manager, parent=None):
        super().__init__(parent)
        self.existing_manager = existing_plugin_manager
        self.remote_manager = RemotePluginManager(existing_plugin_manager, PluginDatabaseService())
        self.current_search_results = []
        
        self.setup_ui()
        self.setup_connections()
        
    def setup_ui(self):
        """è®¾ç½®UI"""
        self.setWindowTitle("FactorWeave-Quantæ’ä»¶å¸‚åœº - è¿œç¨‹æ’ä»¶æ”¯æŒ")
        self.setMinimumSize(1200, 800)
        
        layout = QVBoxLayout(self)
        
        # === æœç´¢åŒºåŸŸ === #
        search_layout = QHBoxLayout()
        
        self.search_input = QLineEdit()
        self.search_input.setPlaceholderText("æœç´¢æ’ä»¶åç§°ã€ä½œè€…æˆ–å…³é”®è¯...")
        search_layout.addWidget(self.search_input)
        
        self.search_btn = QPushButton("ğŸ” æœç´¢")
        search_layout.addWidget(self.search_btn)
        
        # ä»“åº“é€‰æ‹©
        self.repository_combo = QComboBox()
        self.repository_combo.addItem("æ‰€æœ‰ä»“åº“", "all")
        self.repository_combo.addItem("å®˜æ–¹ä»“åº“", "official")
        self.repository_combo.addItem("ç¤¾åŒºä»“åº“", "community")
        search_layout.addWidget(self.repository_combo)
        
        layout.addLayout(search_layout)
        
        # === ç­›é€‰åŒºåŸŸ === #
        filter_layout = QHBoxLayout()
        
        # æ’ä»¶ç±»å‹ç­›é€‰
        type_group = QGroupBox("æ’ä»¶ç±»å‹")
        type_layout = QHBoxLayout(type_group)
        
        self.type_filters = {}
        for plugin_type in PluginType:
            cb = QCheckBox(plugin_type.value)
            cb.setChecked(True)
            self.type_filters[plugin_type] = cb
            type_layout.addWidget(cb)
        
        filter_layout.addWidget(type_group)
        
        # ä»·æ ¼ç­›é€‰
        price_group = QGroupBox("ä»·æ ¼")
        price_layout = QHBoxLayout(price_group)
        
        self.free_only_cb = QCheckBox("ä»…å…è´¹")
        self.free_only_cb.setChecked(True)
        price_layout.addWidget(self.free_only_cb)
        
        self.paid_cb = QCheckBox("åŒ…å«ä»˜è´¹")
        price_layout.addWidget(self.paid_cb)
        
        filter_layout.addWidget(price_group)
        
        layout.addLayout(filter_layout)
        
        # === ç»“æœæ˜¾ç¤ºåŒºåŸŸ === #
        results_splitter = QSplitter(Qt.Horizontal)
        
        # æ’ä»¶åˆ—è¡¨
        self.plugin_list = QListWidget()
        self.plugin_list.setMinimumWidth(350)
        results_splitter.addWidget(self.plugin_list)
        
        # æ’ä»¶è¯¦æƒ…
        details_widget = QWidget()
        details_layout = QVBoxLayout(details_widget)
        
        # æ’ä»¶åŸºæœ¬ä¿¡æ¯
        self.plugin_name_label = QLabel("<b>é€‰æ‹©æ’ä»¶æŸ¥çœ‹è¯¦æƒ…</b>")
        self.plugin_name_label.setStyleSheet("font-size: 16px; padding: 10px;")
        details_layout.addWidget(self.plugin_name_label)
        
        # æ’ä»¶æè¿°
        self.plugin_description = QTextEdit()
        self.plugin_description.setReadOnly(True)
        self.plugin_description.setMaximumHeight(150)
        details_layout.addWidget(self.plugin_description)
        
        # æ’ä»¶è¯¦ç»†ä¿¡æ¯
        info_group = QGroupBox("æ’ä»¶ä¿¡æ¯")
        info_layout = QFormLayout(info_group)
        
        self.version_label = QLabel()
        self.author_label = QLabel()
        self.license_label = QLabel()
        self.downloads_label = QLabel()
        self.rating_label = QLabel()
        
        info_layout.addRow("ç‰ˆæœ¬:", self.version_label)
        info_layout.addRow("ä½œè€…:", self.author_label)
        info_layout.addRow("è®¸å¯è¯:", self.license_label)
        info_layout.addRow("ä¸‹è½½é‡:", self.downloads_label)
        info_layout.addRow("è¯„åˆ†:", self.rating_label)
        
        details_layout.addWidget(info_group)
        
        # æƒé™ä¿¡æ¯
        self.permissions_group = QGroupBox("æ‰€éœ€æƒé™")
        self.permissions_layout = QVBoxLayout(self.permissions_group)
        details_layout.addWidget(self.permissions_group)
        
        # æ“ä½œæŒ‰é’®
        button_layout = QHBoxLayout()
        
        self.install_btn = QPushButton("ğŸ“¥ å®‰è£…æ’ä»¶")
        self.install_btn.setEnabled(False)
        self.install_btn.setStyleSheet("""
            QPushButton {
                background-color: #4CAF50;
                color: white;
                border: none;
                padding: 8px 16px;
                border-radius: 4px;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #45a049;
            }
            QPushButton:disabled {
                background-color: #cccccc;
            }
        """)
        button_layout.addWidget(self.install_btn)
        
        self.purchase_btn = QPushButton("ğŸ’³ è´­ä¹°è®¸å¯è¯")
        self.purchase_btn.setVisible(False)
        self.purchase_btn.setStyleSheet("""
            QPushButton {
                background-color: #2196F3;
                color: white;
                border: none;
                padding: 8px 16px;
                border-radius: 4px;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #1976D2;
            }
        """)
        button_layout.addWidget(self.purchase_btn)
        
        details_layout.addLayout(button_layout)
        
        # è¿›åº¦æ¡
        self.progress_bar = QProgressBar()
        self.progress_bar.setVisible(False)
        details_layout.addWidget(self.progress_bar)
        
        # çŠ¶æ€æ ‡ç­¾
        self.status_label = QLabel()
        self.status_label.setStyleSheet("color: #666; font-size: 12px;")
        details_layout.addWidget(self.status_label)
        
        results_splitter.addWidget(details_widget)
        results_splitter.setSizes([350, 850])
        
        layout.addWidget(results_splitter)
        
        # === åº•éƒ¨æŒ‰é’® === #
        bottom_layout = QHBoxLayout()
        
        self.refresh_btn = QPushButton("ğŸ”„ åˆ·æ–°")
        bottom_layout.addWidget(self.refresh_btn)
        
        self.settings_btn = QPushButton("âš™ï¸ è®¾ç½®")
        bottom_layout.addWidget(self.settings_btn)
        
        bottom_layout.addStretch()
        
        self.close_btn = QPushButton("å…³é—­")
        bottom_layout.addWidget(self.close_btn)
        
        layout.addLayout(bottom_layout)
    
    def setup_connections(self):
        """è®¾ç½®ä¿¡å·è¿æ¥"""
        self.search_btn.clicked.connect(self.search_plugins)
        self.search_input.returnPressed.connect(self.search_plugins)
        self.plugin_list.currentItemChanged.connect(self.on_plugin_selected)
        self.install_btn.clicked.connect(self.install_selected_plugin)
        self.purchase_btn.clicked.connect(self.purchase_plugin_license)
        self.refresh_btn.clicked.connect(self.refresh_plugin_list)
        self.close_btn.clicked.connect(self.accept)
        
        # ç­›é€‰å™¨å˜åŒ–
        for cb in self.type_filters.values():
            cb.toggled.connect(self.apply_filters)
        self.free_only_cb.toggled.connect(self.apply_filters)
        self.paid_cb.toggled.connect(self.apply_filters)
    
    async def search_plugins(self):
        """æœç´¢æ’ä»¶"""
        try:
            self.status_label.setText("æ­£åœ¨æœç´¢æ’ä»¶...")
            self.search_btn.setEnabled(False)
            
            # æ„å»ºæœç´¢æ¡ä»¶
            query = self.search_input.text().strip()
            filters = self.build_search_filters()
            
            # æ‰§è¡Œè¿œç¨‹æœç´¢
            search_results = await self.remote_manager.registry.search_plugins(query, filters)
            
            # æ›´æ–°æœç´¢ç»“æœ
            self.current_search_results = search_results
            self.update_plugin_list(search_results)
            
            self.status_label.setText(f"æ‰¾åˆ° {len(search_results)} ä¸ªæ’ä»¶")
            
        except Exception as e:
            self.status_label.setText(f"æœç´¢å¤±è´¥: {e}")
            QMessageBox.warning(self, "æœç´¢å¤±è´¥", f"æ’ä»¶æœç´¢å¤±